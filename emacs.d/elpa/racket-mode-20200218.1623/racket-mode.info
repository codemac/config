This is racket-mode.info, produced by makeinfo version 6.5 from
racket-mode.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Racket Mode: (racket-mode). Edit and REPL major modes for Racket lang.
END-INFO-DIR-ENTRY


File: racket-mode.info,  Node: Top,  Next: Introduction,  Up: (dir)

Racket Mode
***********

* Menu:

* Introduction::
* Install::
* Configure::
* Reference::
* Commands::
* Variables::
* Faces::

â€” The Detailed Node Listing â€”

Install

* Configure Emacs to use MELPA::
* Install Racket Mode::
* Minimal Racket::
* Uninstall::
* Update::

Configure

* Key bindings::
* Font-lock (syntax highlighting)::
* Completion::
* paredit::
* smartparens::
* eldoc::
* Start faster::
* Unicode input method::

Commands

* Run::
* Test::
* Eval::
* Visit::
* Learn::
* Edit::
* Macro expand::
* Other::

Run

* racket-run::
* racket-repl::
* racket-racket::
* racket-profile::
* racket-profile-mode::
* racket-logger::
* racket-logger-mode::
* racket-debug-mode::

Test

* racket-test::
* racket-raco-test::

Eval

* racket-send-region::
* racket-send-definition::
* racket-send-last-sexp::

Visit

* racket-visit-definition::
* racket-visit-module::
* racket-unvisit::
* racket-open-require-path::
* racket-find-collection::

Learn

* racket-describe::
* racket-doc::

Edit

* racket-insert-lambda::
* racket-fold-all-tests::
* racket-unfold-all-tests::
* racket-tidy-requires::
* racket-trim-requires::
* racket-base-requires::
* racket-indent-line::
* racket-smart-open-bracket-mode::
* racket-insert-closing::
* racket-cycle-paren-shapes::
* racket-backward-up-list::
* racket-check-syntax-mode::
* racket-unicode-input-method-enable::
* racket-align::
* racket-unalign::
* racket-complete-at-point::

Macro expand

* racket-stepper-mode::
* racket-expand-file::
* racket-expand-region::
* racket-expand-definition::
* racket-expand-last-sexp::

Other

* racket-mode-start-faster::
Variables

* General variables::
* REPL variables::
* Other variables::
* Experimental debugger variables::

General variables

* racket-program::
* racket-command-port::
* racket-command-startup::
* racket-command-timeout::
* racket-memory-limit::
* racket-error-context::
* racket-retry-as-skeleton::
* racket-user-command-line-arguments::
* racket-path-from-emacs-to-racket-function::
* racket-path-from-racket-to-emacs-function::

REPL variables

* racket-history-filter-regexp::
* racket-images-inline::
* racket-images-keep-last::
* racket-images-system-viewer::
* racket-pretty-print::

Other variables

* racket-indent-curly-as-sequence::
* racket-indent-sequence-depth::
* racket-pretty-lambda::
* racket-smart-open-bracket-enable::
* racket-logger-config::

Experimental debugger variables

* racket-debuggable-files::
Faces

* All::

All

* racket-keyword-argument-face::
* racket-selfeval-face::
* racket-here-string-face::
* racket-check-syntax-def-face::
* racket-check-syntax-use-face::
* racket-logger-config-face::
* racket-logger-topic-face::
* racket-logger-fatal-face::
* racket-logger-error-face::
* racket-logger-warning-face::
* racket-logger-info-face::
* racket-logger-debug-face::


File: racket-mode.info,  Node: Introduction,  Next: Install,  Prev: Top,  Up: Top

1 Introduction
**************

The Racket Mode (https://www.racket-mode.com/) package consists of a
variety of Emacs major and minor modes, including:

   â€¢ â€˜racket-modeâ€™: A major mode for editing â€˜.rktâ€™ files.

   â€¢ â€˜racket-repl-modeâ€™: A major mode for a Racket REPL. This uses a
     â€œback end serverâ€ written in Racket, which is responsible for
     running files and implementing commands that cannot be implemented
     in Emacs Lisp.(1)

   â€¢ Modes to support specific features, such as:
        â€¢ *note racket-logger-mode::
        â€¢ *note racket-profile-mode::
        â€¢ *note racket-check-syntax-mode::
        â€¢ *note racket-debug-mode::

   For code, issues, and pull requests, see the Git repo
(https://github.com/greghendershott/racket-mode).

   To fund this work, see GitHub Sponsors
(https://github.com/users/greghendershott/sponsorship) or PayPal
(https://www.paypal.me/greghendershott).

   ---------- Footnotes ----------

   (1) Racket Modeâ€™s Racket code is also delivered as part of the Emacs
package â€” _not_ as a Racket package.  Delivering both Emacs and Racket
code in one Emacs package simplifies installation and updates.  The main
drawback is that the Racket code is not automatically byte-compiled, as
would normally be done by â€˜raco pkg installâ€™.  To address this: *Note
racket-mode-start-faster::.


File: racket-mode.info,  Node: Install,  Next: Configure,  Prev: Introduction,  Up: Top

2 Install
*********

The recommended way to use Racket Mode is to install the package from
MELPA (https://melpa.org/).
* Menu:

* Configure Emacs to use MELPA::
* Install Racket Mode::
* Minimal Racket::
* Uninstall::
* Update::


File: racket-mode.info,  Node: Configure Emacs to use MELPA,  Next: Install Racket Mode,  Up: Install

2.1 Configure Emacs to use MELPA
================================

To use MELPA:

   â€¢ Add the following to your ~/.emacs or ~/.emacs.d/init.el:

     (require 'package)
     (add-to-list 'package-archives
     	      '("melpa" . "https://melpa.org/packages/")
     	      t)

   â€¢ Restart Emacs.

   â€¢ Type â€˜M-xâ€™ â€˜package-refresh-contentsâ€™ â€˜RETâ€™ .


File: racket-mode.info,  Node: Install Racket Mode,  Next: Minimal Racket,  Prev: Configure Emacs to use MELPA,  Up: Install

2.2 Install Racket Mode
=======================

When Emacs is configured to use MELPA, simply type â€˜M-xâ€™ package-install
â€˜RETâ€™ racket-mode â€˜RETâ€™ .


File: racket-mode.info,  Node: Minimal Racket,  Next: Uninstall,  Prev: Install Racket Mode,  Up: Install

2.3 Minimal Racket
==================

If you have installed the minimal Racket distribution (for example by
using the homebrew formula
(https://github.com/Homebrew/homebrew-core/blob/master/Formula/minimal-racket.rb))
Racket Mode needs some additional packages (like â€˜errortraceâ€™ and
â€˜macro-debuggerâ€™).  A simple way to get all these packages is to install
the â€˜drracketâ€™ Racket package.  In a command shell:

     raco pkg install drracket


File: racket-mode.info,  Node: Uninstall,  Next: Update,  Prev: Minimal Racket,  Up: Install

2.4 Uninstall
=============

To uninstall Racket Mode, simply type â€˜M-xâ€™ â€˜package-deleteâ€™ â€˜RETâ€™
â€˜racket-modeâ€™ â€˜RETâ€™ .

   You should probably also exit and restart Emacs.


File: racket-mode.info,  Node: Update,  Prev: Uninstall,  Up: Install

2.5 Update
==========

Be aware that updating an Emacs package doesnâ€™t necessarily fully update
Emacsâ€™ state.  (One example symptom: an â€œinvalid functionâ€ error
message.)

   After updating the package, you might need to restart Emacs.

   In some cases, you might even need to:

  1. Uninstall Racket Mode.

  2. Exit and restart Emacs.

  3. Install Racket Mode.


File: racket-mode.info,  Node: Configure,  Next: Reference,  Prev: Install,  Up: Top

3 Configure
***********

Although Racket Mode can be customized with many *note Variables::,
there is only one that you might _need_ to set: *note racket-program::.
This is the name or pathname of the Racket executable.  It defaults to
â€˜Racket.exeâ€™ on Windows else â€˜racketâ€™.

   On Windows or Linux, this default will probably work for you.

   On macOS, downloading Racket doesnâ€™t add its â€˜binâ€™ directory to your
â€˜PATHâ€™.  Even after you add it, GUI Emacs doesnâ€™t automatically use your
path (unless you use the handy exec-path-from-shell
(https://melpa.org/#/exec-path-from-shell) package).  Therefore you
might want to set â€˜racket-programâ€™ to a full pathname like
â€˜/usr/racket/bin/racketâ€™.

   You can â€˜setqâ€™ this directly in your Emacs init file (~/.emacs or
~/.emacs.d/init.el), or, use â€˜M-xâ€™ â€˜customizeâ€™, as you prefer.
* Menu:

* Key bindings::
* Font-lock (syntax highlighting)::
* Completion::
* paredit::
* smartparens::
* eldoc::
* Start faster::
* Unicode input method::


File: racket-mode.info,  Node: Key bindings,  Next: Font-lock (syntax highlighting),  Up: Configure

3.1 Key bindings
================

To customize things like key bindings, you can use â€˜racket-mode-hookâ€™ in
your Emacs init file to modify â€˜racket-mode-mapâ€™.  For example, although
â€˜C-c C-câ€™ is bound by default to the â€˜racket-runâ€™ command, letâ€™s say you
wanted â€˜F5â€™ to be an additional binding:

     (add-hook 'racket-mode-hook
     	  (lambda ()
     	    (define-key racket-mode-map (kbd "<f5>") 'racket-run)))

   Likewise for â€˜racket-repl-mode-hookâ€™ and â€˜racket-repl-mode-mapâ€™.


File: racket-mode.info,  Node: Font-lock (syntax highlighting),  Next: Completion,  Prev: Key bindings,  Up: Configure

3.2 Font-lock (syntax highlighting)
===================================

Font-lock (as Emacs calls syntax highlighting) can be controlled using
the variable â€˜font-lock-maximum-decorationâ€™, which defaults to â€˜tâ€™
(maximum).  You can set it to a number, where â€˜0â€™ is the lowest level.
You can even supply an association list to specify different values for
different major modes.

   Historically you might choose a lower level for speed.  These days
you might do so because you prefer a simpler appearance.

   Racket Mode supports four, increasing levels of font-lock:

   â€¢ â€˜0â€™: Just strings, comments, and â€˜#langâ€™.
   â€¢ â€˜1â€™: â€˜#:keywordâ€™ and self-evaluating literals like numbers, quoted
     symbols (including symbols with spaces delimited by â€˜|â€™
     characters), and â€˜#rxâ€™ and â€˜#pxâ€™ regular expressions.
   â€¢ â€˜2â€™: Identifiers in â€˜defineâ€™-like and â€˜letâ€™-like forms.
   â€¢ â€˜3â€™: Identifiers provided by â€˜racketâ€™, â€˜typed/racketâ€™,
     â€˜racket/syntaxâ€™, and â€˜syntax/parseâ€™.  (This level effectively
     treats Racket as a language, instead of a language for making
     languages.).


File: racket-mode.info,  Node: Completion,  Next: paredit,  Prev: Font-lock (syntax highlighting),  Up: Configure

3.3 Completion
==============

In Emacs, a major mode may supply a â€œcompletion-at-point functionâ€.
This function is used by manual completion commands like
â€˜complete-symbolâ€™ (bound by default to â€˜C-M-iâ€™ ), as well as by
auto-completion packages like â€˜company-modeâ€™.

   Racket Mode supplies such a function, which draws on all identifiers
_currently defined in the Racket namespace_.

   Of course that means there must exist some Racket namespace.  When
you first visit a â€˜.rktâ€™ file, you need to â€˜C-c C-câ€™ to *note
racket-run::.  That makes the namespace match the file, and makes its
identifiers available to Racket Mode.  (Otherwise, as a fallback, Racket
Mode uses the same list of identifiers for which it has defined *note
Font-lock (syntax highlighting)::.)

   Similarly, after you change the file, including its â€˜requireâ€™ forms,
youâ€™ll need to â€˜C-c C-câ€™ again to make the resulting set of identifiers
available for completion.

   To have â€˜TABâ€™ do completion as well as indent, add the following to
your Emacs init file:

     (setq tab-always-indent 'complete)

   This changes the behavior of Emacsâ€™ standard
â€˜indent-for-tab-commandâ€™, to which â€˜TABâ€™ is bound by default in
â€˜racket-modeâ€™ and â€˜racket-repl-modeâ€™.


File: racket-mode.info,  Node: paredit,  Next: smartparens,  Prev: Completion,  Up: Configure

3.4 paredit
===========

If you use paredit (https://melpa.org/#/paredit), you might want to add
keybindings to â€˜paredit-mode-mapâ€™:

   â€¢ Bind the curly brace keys to â€˜paredit-open-curlyâ€™ and
     â€˜paredit-close-curlyâ€™.

   â€¢ Bind whatever keys you prefer for â€˜paredit-wrap-squareâ€™ and
     â€˜paredit-wrap-curlyâ€™.

   For example, with â€˜use-packageâ€™ (https://melpa.org/#/use-package):

     (use-package paredit
       :ensure t
       :config
       (dolist (m '(emacs-lisp-mode-hook
     	       racket-mode-hook
     	       racket-repl-mode-hook))
         (add-hook m #'paredit-mode))
       (bind-keys :map paredit-mode-map
     	     ("{"   . paredit-open-curly)
     	     ("}"   . paredit-close-curly))
       (unless terminal-frame
         (bind-keys :map paredit-mode-map
     	       ("M-[" . paredit-wrap-square)
     	       ("M-{" . paredit-wrap-curly))))


File: racket-mode.info,  Node: smartparens,  Next: eldoc,  Prev: paredit,  Up: Configure

3.5 smartparens
===============

If instead of paredit you prefer smartparens
(https://melpa.org/#/smartparens), you can use the default configuration
it provides for Lisp modes generally and for Racket Mode specifically:

     (require 'smartparens-config)


File: racket-mode.info,  Node: eldoc,  Next: Start faster,  Prev: smartparens,  Up: Configure

3.6 eldoc
=========

By default Racket Mode sets â€˜eldoc-documentation-functionâ€™ to â€˜nilâ€™ â€” no
â€˜eldoc-modeâ€™ support.  You may set it to â€˜racket-eldoc-functionâ€™ in a
â€˜racket-mode-hookâ€™ if you really want to use â€˜eldoc-modeâ€™ with Racket.
But it is not a very satisfying experience because Racket is not a very
â€œeldoc-friendlyâ€ language.  Although Racket Mode attempts to discover
argument lists, contracts, or types this doesnâ€™t work in many common
cases:

   â€¢ Many Racket primitives are defined in â€˜#%kernelâ€™ or â€˜#%runtimeâ€™.
     Thereâ€™s no easy way to determine their argument lists.  Most do not
     â€˜provideâ€™ a contract.

   â€¢ Many of the interesting Racket forms are syntax (macros) not
     functions.  Thereâ€™s no easy way to determine their â€œargument
     listsâ€.

   A more satisfying experience is to use *note racket-describe:: or
*note racket-doc::.


File: racket-mode.info,  Node: Start faster,  Next: Unicode input method,  Prev: eldoc,  Up: Configure

3.7 Start faster
================

You can use *note racket-mode-start-faster:: to make the Racket REPL
start faster.


File: racket-mode.info,  Node: Unicode input method,  Prev: Start faster,  Up: Configure

3.8 Unicode input method
========================

An optional Emacs input method, â€˜racket-unicodeâ€™, lets you easily type
various Unicode symbols that might be useful when writing Racket code.

   To automatically enable the â€˜racket-unicodeâ€™ input method in
â€˜racket-modeâ€™ and â€˜racket-repl-modeâ€™ buffers, put the following code in
your Emacs init file:

     (add-hook 'racket-mode-hook      #'racket-unicode-input-method-enable)
     (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)

   *Note racket-unicode-input-method-enable::.

   *Note racket-insert-lambda::.


File: racket-mode.info,  Node: Reference,  Next: Commands,  Prev: Configure,  Up: Top

4 Reference
***********

The following sections are generated from the doc strings for each
command, variable, or face.  (As a result, some of the formatting might
not be quite as nice or correct as the previous sections.)

   You can also view these by using the normal Emacs help mechanism:

   â€¢ â€˜C-h fâ€™ and enter the name of a command.
   â€¢ â€˜C-h vâ€™ and enter the name of a variable.


File: racket-mode.info,  Node: Commands,  Next: Variables,  Prev: Reference,  Up: Top

5 Commands
**********

* Menu:

* Run::
* Test::
* Eval::
* Visit::
* Learn::
* Edit::
* Macro expand::
* Other::


File: racket-mode.info,  Node: Run,  Next: Test,  Up: Commands

5.1 Run
=======

* Menu:

* racket-run::
* racket-repl::
* racket-racket::
* racket-profile::
* racket-profile-mode::
* racket-logger::
* racket-logger-mode::
* racket-debug-mode::


File: racket-mode.info,  Node: racket-run,  Next: racket-repl,  Up: Run

5.1.1 racket-run
----------------

â€˜C-c C-kâ€™ or â€˜C-c C-câ€™

   Save and evaluate the buffer in REPL.

   With one C-u prefix, uses errortrace for improved stack traces.
Otherwise follows the *note racket-error-context:: setting.

   With two C-u prefixes, instruments code for step debugging.  See
*note racket-debug-mode:: and the variable *note
racket-debuggable-files::.

   If point is within a Racket module form, the REPL â€œentersâ€ that
submodule (uses its language info and namespace).

   When you run again, the file is evaluated from scratch â€” the
custodian releases resources like threads and the evaluation environment
is reset to the contents of the file.  In other words, like DrRacket,
this provides the predictability of a â€œstaticâ€ baseline, plus the
ability to explore interactively using the REPL.

   See also â€˜racket-run-and-switch-to-replâ€™, which is even more like
DrRacketâ€™s Run because it selects the REPL window (gives it the focus),
too.

   When *note racket-retry-as-skeleton:: is true, if your source file
has an error, a â€œskeletonâ€ of your file is evaluated to get identifiers
from module languages, require forms, and definitions.  That way, things
like completion and *note racket-describe:: are more likely to work
while you edit the file to fix the error.  If not even the â€œskeletonâ€
evaluation succeeds, youâ€™ll have only identifiers provided by
racket/base, until you fix the error and run again.

   Output in the Racket REPL buffer that describes a file and position
is automatically â€œlinkifiedâ€.  Examples of such text include:

   â€¢ Racket error messages.
   â€¢ rackunit test failure location messages.
   â€¢ print representation of path objects.

   To visit these locations, move point there and press RET or mouse
click.  Or, use the standard â€˜next-errorâ€™ and â€˜previous-errorâ€™ commands.


File: racket-mode.info,  Node: racket-repl,  Next: racket-racket,  Prev: racket-run,  Up: Run

5.1.2 racket-repl
-----------------

â€˜C-c C-zâ€™

   Show the Racket REPL buffer in some window.

   If NOSELECT is not nil, does not also select the REPL window.

   *IMPORTANT*

   The main, intended use of Racket Modeâ€™s REPL is that you â€˜find-fileâ€™
some specific .rkt file, then *note racket-run:: it.  The REPL will then
match that file.  Also, various Racket Mode features will work, such as
completion, visiting definitions, and so on.

   If the REPL isnâ€™t running, and you want to start it for no file in
particular?  Then you could use this command.  But the resulting REPL
will have a minimal â€œ#lang racket/baseâ€ namespace.  You could enter
"(require racket)" if you want the equivalent of â€œ#lang racketâ€.  You
could also "(require racket/enter)" if you want things like â€œenter!â€.
But in some sense youâ€™d be â€œusing it wrongâ€.  If you really donâ€™t want
to use Racket Modeâ€™s REPL as intended, then you might as well use a
plain Emacs shell buffer to run command-line Racket.


File: racket-mode.info,  Node: racket-racket,  Next: racket-profile,  Prev: racket-repl,  Up: Run

5.1.3 racket-racket
-------------------

â€˜<C-M-f5>â€™

   Do â€œracket <file>â€ in a shell buffer.


File: racket-mode.info,  Node: racket-profile,  Next: racket-profile-mode,  Prev: racket-racket,  Up: Run

5.1.4 racket-profile
--------------------

â€˜C-c C-oâ€™

   Runs with profiling instrumentation and shows results.

   Results are presented in a *note racket-profile-mode:: buffer, which
also lets you quickly view the source code.

   You may evaluate expressions in the REPL. They are also profiled.
Use â€˜racket--profile-refreshâ€™ to see the updated results.  (In other
words a possible workflow is: *note racket-profile:: a .rkt file, call
one its functions in the REPL, and refresh the profile results.)

   Caveat: Only source files are instrumented.  You may need to delete
compiled/*.zo files.


File: racket-mode.info,  Node: racket-profile-mode,  Next: racket-logger,  Prev: racket-profile,  Up: Run

5.1.5 racket-profile-mode
-------------------------

â€˜M-xâ€™ â€˜racket-profile-modeâ€™ â€˜RETâ€™

   Major mode for results of *note racket-profile::.

Key                                             Binding
â€˜,â€™                                             â€˜racket--profile-sortâ€™
â€˜RETâ€™                                           â€˜racket--profile-visitâ€™
â€˜zâ€™                                             â€˜racket--profile-show-zeroâ€™
â€˜pâ€™                                             â€˜racket--profile-prevâ€™
â€˜nâ€™                                             â€˜racket--profile-nextâ€™
â€˜gâ€™                                             â€˜racket--profile-refreshâ€™
â€˜qâ€™                                             â€˜racket--profile-quitâ€™

   In addition to any hooks its parent mode â€˜special-modeâ€™ might have
run, this mode runs the hook â€˜racket-profile-mode-hookâ€™, as the final
step during initialization.


File: racket-mode.info,  Node: racket-logger,  Next: racket-logger-mode,  Prev: racket-profile-mode,  Up: Run

5.1.6 racket-logger
-------------------

â€˜C-c C-lâ€™

   Create the *note racket-logger-mode:: buffer and connect to logger
output.

   If the â€˜racket-repl-modeâ€™ buffer is displayed in a window, split that
window and put the logger in the bottom window.  Otherwise, use
â€˜pop-to-bufferâ€™.


File: racket-mode.info,  Node: racket-logger-mode,  Next: racket-debug-mode,  Prev: racket-logger,  Up: Run

5.1.7 racket-logger-mode
------------------------

â€˜M-xâ€™ â€˜racket-logger-modeâ€™ â€˜RETâ€™

   Major mode for Racket logger output.

   The customization variable *note racket-logger-config:: determines
the levels for topics.  During a session you may change topic levels
using â€˜racket-logger-topic-levelâ€™.

   For more information see:
<https://docs.racket-lang.org/reference/logging.html>

Key                                                     Binding
â€˜C-c C-zâ€™                                               *note racket-repl::
â€˜xâ€™                                                     â€˜racket-logger-exitâ€™
â€˜gâ€™                                                     â€˜racket-logger-clearâ€™
â€˜pâ€™                                                     â€˜racket-logger-previous-itemâ€™
â€˜nâ€™                                                     â€˜racket-logger-next-itemâ€™
â€˜wâ€™                                                     â€˜toggle-truncate-linesâ€™
â€˜lâ€™                                                     â€˜racket-logger-topic-levelâ€™

   In addition to any hooks its parent mode â€˜special-modeâ€™ might have
run, this mode runs the hook â€˜racket-logger-mode-hookâ€™, as the final
step during initialization.


File: racket-mode.info,  Node: racket-debug-mode,  Prev: racket-logger-mode,  Up: Run

5.1.8 racket-debug-mode
-----------------------

â€˜M-xâ€™ â€˜racket-debug-modeâ€™ â€˜RETâ€™

   Minor mode for debug breaks.

   This feature is **EXPERIMENTAL**!!! It is likely to have significant
limitations and bugs.  You are welcome to open an issue to provide
feedback.  Please understand that this feature might never be improved â€“
it might even be removed someday if it turns out to have too little
value and/or too much cost.

   How to debug:

  1. â€œInstrumentâ€ code for step debugging.  You can instrument entire
     files, and also individual functions.

     a.  Entire Files

     Choose *note racket-run:: with two prefixes â€“ C-u C-u C-c C-c.  The
     file will be instrumented for step debugging before it is run.
     Also instrumented are files determined by the variable *note
     racket-debuggable-files::.

     The run will break at the first breakable position.

     Tip: After you run to completion and return to a normal REPL
     prompt, the code remains instrumented.  You may enter expressions
     that evaluate instrumented code and it will break so you can step
     debug again.

     b.  Function Definitions

     Put point in a function â€˜defineâ€™ form and C-u C-M-x to â€œinstrumentâ€
     the function for step debugging.  Then in the REPL, enter an
     expression that causes the instrumented function to be run,
     directly or indirectly.

     You can instrument any number of functions.

     You can even instrument while stopped at a break.  For example, to
     instrument a function you are about to call, so you can â€œstep intoâ€
     it:

        â€¢ M-.  a.k.a.  *note racket-visit-definition::.
        â€¢ C-u C-M-x to instrument the definition.
        â€¢ M-, a.k.a.  *note racket-unvisit::.
        â€¢ Continue stepping.
     Limitation: Instrumenting a function ~require~d from another module
     wonâ€™t redefine that function.  Instead, it attempts to define an
     instrumented function of the same name, in the module the REPL is
     inside.  The define will fail if it needs definitions visible only
     in that other module.  In that case youâ€™ll probably need to use
     entire-file instrumentation as described above.

  2. When a break occurs, the â€˜racket-repl-modeâ€™ prompt changes.  In
     this debug REPL, local variables are available for you to use and
     even to â€˜set!â€™.

     Also, in the â€˜racket-modeâ€™ buffer where the break is located, *note
     racket-debug-mode:: is enabled.  This minor mode makes the buffer
     read-only, provides visual feedback â€“ about the break position,
     local variable values, and result values â€“ and provides shortcut
     keys:

Key                                             Binding
â€˜?â€™                                             â€˜racket-debug-helpâ€™
â€˜hâ€™                                             â€˜racket-debug-run-to-hereâ€™
â€˜pâ€™                                             â€˜racket-debug-prev-breakableâ€™
â€˜nâ€™                                             â€˜racket-debug-next-breakableâ€™
â€˜câ€™                                             â€˜racket-debug-continueâ€™
â€˜uâ€™                                             â€˜racket-debug-step-outâ€™
â€˜oâ€™                                             â€˜racket-debug-step-overâ€™
â€˜SPCâ€™                                           â€˜racket-debug-stepâ€™


File: racket-mode.info,  Node: Test,  Next: Eval,  Prev: Run,  Up: Commands

5.2 Test
========

* Menu:

* racket-test::
* racket-raco-test::


File: racket-mode.info,  Node: racket-test,  Next: racket-raco-test,  Up: Test

5.2.1 racket-test
-----------------

â€˜<C-f5>â€™ or â€˜C-c C-tâ€™

   Run the â€œtestâ€ submodule.

   With prefix, runs with coverage instrumentation and highlights
uncovered code.

   Put your tests in a â€œtestâ€ submodule.  For example:

     (module+ test
       (require rackunit)
       (check-true #t))

   Any rackunit test failure messages show the location.  You may use
â€˜next-errorâ€™ to jump to the location of each failing test.

   See also:
   â€¢ *note racket-fold-all-tests::
   â€¢ *note racket-unfold-all-tests::


File: racket-mode.info,  Node: racket-raco-test,  Prev: racket-test,  Up: Test

5.2.2 racket-raco-test
----------------------

â€˜M-xâ€™ â€˜racket-raco-testâ€™ â€˜RETâ€™

   Do â€œraco test -x <file>â€ in a shell buffer to run the â€œtestâ€
submodule.


File: racket-mode.info,  Node: Eval,  Next: Visit,  Prev: Test,  Up: Commands

5.3 Eval
========

* Menu:

* racket-send-region::
* racket-send-definition::
* racket-send-last-sexp::


File: racket-mode.info,  Node: racket-send-region,  Next: racket-send-definition,  Up: Eval

5.3.1 racket-send-region
------------------------

â€˜C-c C-râ€™

   Send the current region (if any) to the Racket REPL.


File: racket-mode.info,  Node: racket-send-definition,  Next: racket-send-last-sexp,  Prev: racket-send-region,  Up: Eval

5.3.2 racket-send-definition
----------------------------

â€˜C-M-xâ€™

   Send the current definition to the Racket REPL.


File: racket-mode.info,  Node: racket-send-last-sexp,  Prev: racket-send-definition,  Up: Eval

5.3.3 racket-send-last-sexp
---------------------------

â€˜C-x C-eâ€™

   Send the previous sexp to the Racket REPL.

   When the previous sexp is a sexp comment the sexp itself is sent,
without the #; prefix.


File: racket-mode.info,  Node: Visit,  Next: Learn,  Prev: Eval,  Up: Commands

5.4 Visit
=========

* Menu:

* racket-visit-definition::
* racket-visit-module::
* racket-unvisit::
* racket-open-require-path::
* racket-find-collection::


File: racket-mode.info,  Node: racket-visit-definition,  Next: racket-visit-module,  Up: Visit

5.4.1 racket-visit-definition
-----------------------------

â€˜M-.â€™

   Visit definition of identifier at point.

   If there is no identifier at point, prompt for it.

   With a prefix, always prompt for the identifier.

   Use *note racket-unvisit:: to return.

   Please keep in mind the following limitations:

   â€¢ Only finds symbols defined in the current namespace.  You may need
     to *note racket-run:: the current buffer, first.

   â€¢ Only visits the definition of module-level identifiers â€“ things for
     which Racketâ€™s â€œidentifier-bindingâ€ function returns information.
     This does NOT include things such as local (nested) function
     definitions or â€œracket/classâ€ member functions.  To find those in
     the same file, youâ€™ll need to use a normal Emacs text search
     function like â€˜isearch-forwardâ€™.

   â€¢ If the definition is found in Racketâ€™s â€œ#%kernelâ€ module, it will
     tell you so but wonâ€™t visit the definition site.


File: racket-mode.info,  Node: racket-visit-module,  Next: racket-unvisit,  Prev: racket-visit-definition,  Up: Visit

5.4.2 racket-visit-module
-------------------------

â€˜C-M-.â€™

   Visit definition of module at point, e.g.  net/url or â€œfile.rktâ€.

   If there is no module at point, prompt for it.

   With a prefix, always prompt for the module.

   Use *note racket-unvisit:: to return.

   See also: *note racket-find-collection::.


File: racket-mode.info,  Node: racket-unvisit,  Next: racket-open-require-path,  Prev: racket-visit-module,  Up: Visit

5.4.3 racket-unvisit
--------------------

â€˜M-,â€™

   Return from previous *note racket-visit-definition:: or *note
racket-visit-module::.


File: racket-mode.info,  Node: racket-open-require-path,  Next: racket-find-collection,  Prev: racket-unvisit,  Up: Visit

5.4.4 racket-open-require-path
------------------------------

â€˜C-c C-x C-fâ€™

   Like Dr Racketâ€™s Open Require Path.

   Type (or delete) characters that are part of a module path name.
â€œFuzzyâ€ matches appear.  For example try typing â€œt/t/râ€.

   Choices are displayed in a vertical list.  The current choice is at
the top, marked with â€œ->â€.

   â€¢ C-n and C-p move among the choices.
   â€¢ RET on a directory adds its contents to the choices.
   â€¢ RET on a file exits doing â€˜find-fileâ€™.
   â€¢ C-g aborts.

   Note: This requires Racket 6.1.1.6 or newer.  Otherwise it wonâ€™t
error, it will just never return any matches.


File: racket-mode.info,  Node: racket-find-collection,  Prev: racket-open-require-path,  Up: Visit

5.4.5 racket-find-collection
----------------------------

â€˜M-xâ€™ â€˜racket-find-collectionâ€™ â€˜RETâ€™

   Given a collection name, try to find its directory and files.

   Takes a collection name from point (or, with a prefix, prompts you).

   If only one directory is found, â€˜ido-find-file-in-dirâ€™ lets you pick
a file there.

   If more than one directory is found, â€˜ido-completing-readâ€™ lets you
pick one, then â€˜ido-find-file-in-dirâ€™ lets you pick a file there.

   Note: This requires the â€˜raco-find-collectionâ€™ package to be
installed.  To install it, in â€˜shellâ€™ enter:

   raco pkg install raco-find-collection

   Tip: This works best with â€˜ido-enable-flex-matchingâ€™ set to t.  Also
handy is the â€˜flx-idoâ€™ package from MELPA.

   See also: *note racket-visit-module:: and *note
racket-open-require-path::.


File: racket-mode.info,  Node: Learn,  Next: Edit,  Prev: Visit,  Up: Commands

5.5 Learn
=========

* Menu:

* racket-describe::
* racket-doc::


File: racket-mode.info,  Node: racket-describe,  Next: racket-doc,  Up: Learn

5.5.1 racket-describe
---------------------

â€˜C-c C-.â€™

   Describe the identifier at point in a â€˜*Racket Describe*â€™ buffer.

   The intent is to give a quick reminder or introduction to something,
regardless of whether it has installed documentation â€“ and to do so
within Emacs, without switching to a web browser.

   This buffer is also displayed when you use â€˜company-modeâ€™ and press
F1 or C-h in its pop up completion list.

   â€¢ If the identifier has installed Racket documentation, then a
     simplified version of the HTML is presented in the buffer,
     including the â€œblue boxâ€, documentation prose, and examples.

   â€¢ Otherwise, if the identifier is a function, then its signature is
     displayed, for example â€˜(name arg-1-name arg-2-name)â€™.  If it has a
     contract or a Typed Racket type, that is also displayed.

   You can quit the buffer by pressing q.  Also, at the bottom of the
buffer are Emacs buttons â€“ which you may navigate among using TAB, and
activate using RET â€“ for *note racket-visit-definition:: and *note
racket-doc::.


File: racket-mode.info,  Node: racket-doc,  Prev: racket-describe,  Up: Learn

5.5.2 racket-doc
----------------

â€˜C-c C-dâ€™

   View documentation of the identifier or string at point.

   Uses the default external web browser.

   If point is an identifier required in the current namespace that has
help, opens the web browser directly at that help topic.  (i.e.  Uses
the identifier variant of racket/help.)

   Otherwise, opens the â€˜search for a termâ€™ page, where you can choose
among multiple possibilities.  (i.e.  Uses the string variant of
racket/help.)

   With a C-u prefix, prompts for the identifier or quoted string,
instead of looking at point.


File: racket-mode.info,  Node: Edit,  Next: Macro expand,  Prev: Learn,  Up: Commands

5.6 Edit
========

* Menu:

* racket-insert-lambda::
* racket-fold-all-tests::
* racket-unfold-all-tests::
* racket-tidy-requires::
* racket-trim-requires::
* racket-base-requires::
* racket-indent-line::
* racket-smart-open-bracket-mode::
* racket-insert-closing::
* racket-cycle-paren-shapes::
* racket-backward-up-list::
* racket-check-syntax-mode::
* racket-unicode-input-method-enable::
* racket-align::
* racket-unalign::
* racket-complete-at-point::


File: racket-mode.info,  Node: racket-insert-lambda,  Next: racket-fold-all-tests,  Up: Edit

5.6.1 racket-insert-lambda
--------------------------

â€˜C-M-yâ€™

   Insert Î».

   To insert Unicode symbols generally, see *note
racket-unicode-input-method-enable::.


File: racket-mode.info,  Node: racket-fold-all-tests,  Next: racket-unfold-all-tests,  Prev: racket-insert-lambda,  Up: Edit

5.6.2 racket-fold-all-tests
---------------------------

â€˜C-c C-fâ€™

   Fold (hide) all test submodules.


File: racket-mode.info,  Node: racket-unfold-all-tests,  Next: racket-tidy-requires,  Prev: racket-fold-all-tests,  Up: Edit

5.6.3 racket-unfold-all-tests
-----------------------------

â€˜C-c C-uâ€™

   Unfold (show) all test submodules.


File: racket-mode.info,  Node: racket-tidy-requires,  Next: racket-trim-requires,  Prev: racket-unfold-all-tests,  Up: Edit

5.6.4 racket-tidy-requires
--------------------------

â€˜M-xâ€™ â€˜racket-tidy-requiresâ€™ â€˜RETâ€™

   Make a single top-level â€œrequireâ€ form, modules sorted, one per line.

   All top-level require forms are combined into a single form.  Within
that form:

   â€¢ A single subform is used for each phase level, sorted in this
     order: for-syntax, for-template, for-label, for-meta, and plain
     (phase 0).

        â€¢ Within each level subform, the modules are sorted:

             â€¢ Collection path modules â€“ sorted alphabetically.

             â€¢ Subforms such as only-in.

             â€¢ Quoted relative requires â€“ sorted alphabetically.

   At most one module is listed per line.

   Note: This only works for requires at the top level of a source file
using #lang.  It does NOT work for require forms inside module forms.

   See also: *note racket-trim-requires:: and *note
racket-base-requires::.


File: racket-mode.info,  Node: racket-trim-requires,  Next: racket-base-requires,  Prev: racket-tidy-requires,  Up: Edit

5.6.5 racket-trim-requires
--------------------------

â€˜M-xâ€™ â€˜racket-trim-requiresâ€™ â€˜RETâ€™

   Like *note racket-tidy-requires:: but also deletes unnecessary
requires.

   Note: This only works when the source file can be evaluated with no
errors.

   Note: This only works for requires at the top level of a source file
using #lang.  It does NOT work for require forms inside module forms.
Furthermore, it is not smart about module+ or module* forms â€“ it might
delete top level requires that are actually needed by such submodules.

   See also: *note racket-base-requires::.


File: racket-mode.info,  Node: racket-base-requires,  Next: racket-indent-line,  Prev: racket-trim-requires,  Up: Edit

5.6.6 racket-base-requires
--------------------------

â€˜M-xâ€™ â€˜racket-base-requiresâ€™ â€˜RETâ€™

   Change from â€œ#lang racketâ€ to â€œ#lang racket/baseâ€.

   Adds explicit requires for imports that are provided by â€œracketâ€ but
not by â€œracket/baseâ€.

   This is a recommended optimization for Racket applications.  Avoiding
loading all of â€œracketâ€ can reduce load time and memory footprint.

   Also, as does *note racket-trim-requires::, this removes unneeded
modules and tidies everything into a single, sorted require form.

   Note: This only works when the source file can be evaluated with no
errors.

   Note: This only works for requires at the top level of a source file
using #lang.  It does NOT work for require forms inside module forms.
Furthermore, it is not smart about module+ or module* forms â€“ it might
delete top level requires that are actually needed by such submodules.

   Note: Currently this only helps change â€œ#lang racketâ€ to â€œ#lang
racket/baseâ€.  It does not help with other similar conversions, such as
changing â€œ#lang typed/racketâ€ to â€œ#lang typed/racket/baseâ€.


File: racket-mode.info,  Node: racket-indent-line,  Next: racket-smart-open-bracket-mode,  Prev: racket-base-requires,  Up: Edit

5.6.7 racket-indent-line
------------------------

â€˜M-xâ€™ â€˜racket-indent-lineâ€™ â€˜RETâ€™

   Indent current line as Racket code.

   This behaves like â€˜lisp-indent-lineâ€™, except that whole-line comments
are treated the same regardless of whether they start with single or
double semicolons.

   â€¢ Automatically indents forms that start with â€˜beginâ€™ in the usual
     way that â€˜beginâ€™ is indented.

   â€¢ Automatically indents forms that start with â€˜defâ€™ or â€˜with-â€™ in the
     usual way that â€˜defineâ€™ is indented.

   â€¢ Has rules for many specific standard Racket forms.

   To extend, use your Emacs init file to

   (put SYMBOL â€˜racket-indent-function INDENT)

   where â€˜SYMBOLâ€™ is the name of the Racket form (e.g.  ~â€™test-case~)
and â€˜INDENTâ€™ is an integer or the symbol ~â€™defun~.  When â€˜INDENTâ€™ is an
integer, the meaning is the same as for â€˜lisp-indent-functionâ€™ and
â€˜scheme-indent-functionâ€™: Indent the first â€˜nâ€™ arguments specially and
then indent any further arguments like a body.

   For example in your â€˜.emacsâ€™ file you could use:

   (put â€˜test-case â€˜racket-indent-function 1)

   to change the indent of â€˜test-caseâ€™ from this:

   (test-case foo blah blah)

   to this:

   (test-case foo blah blah)

   If â€˜racket-indent-functionâ€™ has no property for a symbol,
â€˜scheme-indent-functionâ€™ is also considered (although the with-x indents
defined by â€˜scheme-modeâ€™ are ignored).  This is only to help people who
may have extensive â€˜scheme-indent-functionâ€™ settings, particularly in
the form of file or dir local variables.  Otherwise prefer
â€˜racket-indent-functionâ€™.


File: racket-mode.info,  Node: racket-smart-open-bracket-mode,  Next: racket-insert-closing,  Prev: racket-indent-line,  Up: Edit

5.6.8 racket-smart-open-bracket-mode
------------------------------------

â€˜M-xâ€™ â€˜racket-smart-open-bracket-modeâ€™ â€˜RETâ€™

   Minor mode to let you always type â€˜[â€™â€™ to insert â€˜(â€™ or â€˜[â€™
automatically.

   Behaves like the â€œAutomatically adjust opening square bracketsâ€
feature in Dr.  Racket.

   By default, inserts a â€˜(â€™.  Inserts a â€˜[â€™ in the following cases:

   â€¢ â€˜letâ€™-like bindings â€“ forms with â€˜letâ€™ in the name as well as
     things like â€˜parameterizeâ€™, â€˜with-handlersâ€™, and â€˜with-syntaxâ€™.

   â€¢ â€˜caseâ€™, â€˜condâ€™, â€˜matchâ€™, â€˜syntax-caseâ€™, â€˜syntax-parseâ€™, and
     â€˜syntax-rulesâ€™ clauses.

   â€¢ â€˜forâ€™-like bindings and â€˜for/foldâ€™ accumulators.

   â€¢ â€˜classâ€™ declaration syntax, such as â€˜initâ€™ and â€˜inheritâ€™.

   When the previous s-expression in a sequence is a compound
expression, uses the same kind of delimiter.

   To force insert â€˜[â€™, use â€˜quoted-insertâ€™.

   Combined with *note racket-insert-closing:: this means that you can
press the unshifted â€˜[â€™ and â€˜]â€™ keys to get whatever delimiters follow
the Racket conventions for these forms.  When something like
â€˜electric-pair-modeâ€™ or â€˜paredit-modeâ€™ is active, you need not even
press â€˜]â€™.

   Tip: When also using â€˜paredit-modeâ€™, enable that first so that the
binding for the â€˜[â€™â€™ key in the map for *note
racket-smart-open-bracket-mode:: has higher priority.  See also the
variable â€˜minor-mode-map-alistâ€™.


File: racket-mode.info,  Node: racket-insert-closing,  Next: racket-cycle-paren-shapes,  Prev: racket-smart-open-bracket-mode,  Up: Edit

5.6.9 racket-insert-closing
---------------------------

â€˜]â€™ or â€˜)â€™

   Insert a matching closing delimiter.

   With a prefix, insert the typed character as-is.

   This is handy if youâ€™re not yet using something like â€˜paredit-modeâ€™,
â€˜smartparens-modeâ€™, â€˜parinfer-modeâ€™, or simply â€˜electric-pair-modeâ€™
added in Emacs 24.5.


File: racket-mode.info,  Node: racket-cycle-paren-shapes,  Next: racket-backward-up-list,  Prev: racket-insert-closing,  Up: Edit

5.6.10 racket-cycle-paren-shapes
--------------------------------

â€˜C-c C-pâ€™

   Cycle the sexpr among () [] {}.


File: racket-mode.info,  Node: racket-backward-up-list,  Next: racket-check-syntax-mode,  Prev: racket-cycle-paren-shapes,  Up: Edit

5.6.11 racket-backward-up-list
------------------------------

â€˜C-M-uâ€™

   Like â€˜backward-up-listâ€™ but works when point is in a string or
comment.

   Typically you should not use this command in Emacs Lisp â€“ especially
not repeatedly.  Instead, initially use
â€˜racket--escape-string-or-commentâ€™ to move to the start of a string or
comment, if any, then use normal â€˜backward-up-listâ€™ repeatedly.


File: racket-mode.info,  Node: racket-check-syntax-mode,  Next: racket-unicode-input-method-enable,  Prev: racket-backward-up-list,  Up: Edit

5.6.12 racket-check-syntax-mode
-------------------------------

â€˜M-xâ€™ â€˜racket-check-syntax-modeâ€™ â€˜RETâ€™

   Analyze the buffer and annotate with information.

   The buffer becomes read-only until you exit this minor mode.  However
you may navigate the usual ways.  When point is on a definition or use,
related items are highlighted and information is displayed in the echo
area.  You may also use special commands to navigate among the
definition and its uses.

Key                                             Binding
â€˜râ€™                                             â€˜racket-check-syntax-mode-renameâ€™
â€˜pâ€™                                             â€˜racket-check-syntax-mode-goto-prev-useâ€™
â€˜nâ€™                                             â€˜racket-check-syntax-mode-goto-next-useâ€™
â€˜.â€™                                             â€˜racket-check-syntax-mode-goto-defâ€™
â€˜kâ€™                                             â€˜racket-check-syntax-mode-goto-prev-defâ€™
â€˜TABâ€™                                           â€˜racket-check-syntax-mode-goto-next-defâ€™
â€˜jâ€™                                             â€˜racket-check-syntax-mode-goto-next-defâ€™
â€˜hâ€™                                             â€˜racket-check-syntax-mode-helpâ€™
â€˜qâ€™                                             â€˜racket-check-syntax-mode-quitâ€™


File: racket-mode.info,  Node: racket-unicode-input-method-enable,  Next: racket-align,  Prev: racket-check-syntax-mode,  Up: Edit

5.6.13 racket-unicode-input-method-enable
-----------------------------------------

â€˜M-xâ€™ â€˜racket-unicode-input-method-enableâ€™ â€˜RETâ€™

   Set input method to racket-unicode.

   The racket-unicode input method lets you easily type various Unicode
symbols that might be useful when writing Racket code.

   To automatically enable the racket-unicode input method in
racket-mode and racket-repl-mode buffers, put the following code in your
Emacs init file:

     (add-hook 'racket-mode-hook #'racket-unicode-input-method-enable)
     (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)

   To temporarily enable this input method for a single buffer you can
use â€œM-x racket-unicode-input-method-enableâ€.

   Use the standard Emacs key C-\ to toggle the input method.

   When the racket-unicode input method is active, you can for example
type â€œAllâ€ and it is immediately replaced with â€œâˆ€â€.  A few other
examples:

omega       Ï‰
x_1         xâ‚
x^1         xÂ¹
A           ğ”¸
testâ€“>>E    testâ€“>>âˆƒ (racket/redex)
vdash       âŠ¢

   To see a table of all key sequences use â€œM-x describe-input-method
<RET> racket-unicodeâ€.

   If you want to add your own mappings to the â€œracket-unicodeâ€ input
method, you may add code like the following example in your Emacs init
file:

     ;; Either (require 'racket-mode) here, or, if you use
     ;; use-package, put the code below in the :config section.
     (with-temp-buffer
       (racket-unicode-input-method-enable)
       (set-input-method "racket-unicode")
       (let ((quail-current-package (assoc "racket-unicode"
     				      quail-package-alist)))
         (quail-define-rules ((append . t))
     			("^o" ["áµ’"]))))

   If you donâ€™t like the highlighting of partially matching tokens you
can turn it off by setting â€˜input-method-highlight-flagâ€™ to nil.


File: racket-mode.info,  Node: racket-align,  Next: racket-unalign,  Prev: racket-unicode-input-method-enable,  Up: Edit

5.6.14 racket-align
-------------------

â€˜M-xâ€™ â€˜racket-alignâ€™ â€˜RETâ€™

   Align values in the same column.

   Useful for binding forms like â€œletâ€ and â€œparameterizeâ€, conditionals
like â€œcondâ€ and â€œmatchâ€, association lists, and any series of couples
like the arguments to â€œhashâ€.

   Before choosing this command, put point on the first of a series of
â€œcouplesâ€.  A couple is:

   â€¢ A list of two or more sexprs: "[sexpr val sexpr ...]".
   â€¢ Two sexprs: â€œsexpr valâ€.

   Each â€œvalâ€ moves to the same column and is â€˜prog-indent-sexpâ€™-ed (in
case it is a multi-line form).

   For example with point on the "[" before â€œaâ€:

     Before             After

     (let ([a 12]       (let ([a   12]
           [bar 23])          [bar 23])
       ....)              ....)

     '([a . 12]         '([a   . 12]
       [bar . 23])        [bar . 23])

     (cond [a? #t]      (cond [a?   #t]
           [b? (f x           [b?   (f x
     	     y)]                  y)]
           [else #f])         [else #f])

   Or with point on the quote before â€œaâ€:

     (list 'a 12        (list 'a   12
           'bar 23)           'bar 23)

   If more than one couple is on the same line, none are aligned,
because it is unclear where the value column should be.  For example the
following form will not change; *note racket-align:: will display an
error message:

     (let ([a 0][b 1]
           [c 2])       error; unchanged
       ....)

   When a coupleâ€™s sexprs start on different lines, that couple is
ignored.  Other, single-line couples in the series are aligned as usual.
For example:

     (let ([foo         (let ([foo
            0]                 0]
           [bar 1]            [bar 1]
           [x 2])             [x   2])
       ....)              ....)

   See also: *note racket-unalign::.


File: racket-mode.info,  Node: racket-unalign,  Next: racket-complete-at-point,  Prev: racket-align,  Up: Edit

5.6.15 racket-unalign
---------------------

â€˜M-xâ€™ â€˜racket-unalignâ€™ â€˜RETâ€™

   The opposite of *note racket-align::.

   Effectively does M-x â€˜just-one-spaceâ€™ and â€˜prog-indent-sexpâ€™ for each
coupleâ€™s value.


File: racket-mode.info,  Node: racket-complete-at-point,  Prev: racket-unalign,  Up: Edit

5.6.16 racket-complete-at-point
-------------------------------

Default value for the variable â€˜completion-at-point-functionsâ€™.

   Completion candidates are drawn from the namespace symbols resulting
from the most recent *note racket-run:: of each .rkt file.  If a file
has never been run, candidates default to values also used for font-lock
â€“ an assortment of symbols from common Racket modules such as â€˜racketâ€™,
â€˜typed/racketâ€™, and â€˜syntax/parseâ€™.

   Returns extra :company-doc-buffer and :company-location properties
for use by the â€˜company-modeâ€™ backend â€˜company-capfâ€™ â€“ but not
:company-docsig, because it is frequently impossible to supply this
quickly enough or at all.


File: racket-mode.info,  Node: Macro expand,  Next: Other,  Prev: Edit,  Up: Commands

5.7 Macro expand
================

* Menu:

* racket-stepper-mode::
* racket-expand-file::
* racket-expand-region::
* racket-expand-definition::
* racket-expand-last-sexp::


File: racket-mode.info,  Node: racket-stepper-mode,  Next: racket-expand-file,  Up: Macro expand

5.7.1 racket-stepper-mode
-------------------------

â€˜M-xâ€™ â€˜racket-stepper-modeâ€™ â€˜RETâ€™

   Major mode for Racket stepper output.

   Used by the commands *note racket-expand-file::, *note
racket-expand-definition::, *note racket-expand-region::, and *note
racket-expand-last-sexp::.

Key                                             Binding
â€˜kâ€™                                             â€˜racket-stepper-previous-itemâ€™
â€˜pâ€™                                             â€˜racket-stepper-previous-itemâ€™
â€˜jâ€™                                             â€˜racket-stepper-next-itemâ€™
â€˜nâ€™                                             â€˜racket-stepper-next-itemâ€™
â€˜RETâ€™                                           â€˜racket-stepper-stepâ€™

   In addition to any hooks its parent mode â€˜special-modeâ€™ might have
run, this mode runs the hook â€˜racket-stepper-mode-hookâ€™, as the final
step during initialization.


File: racket-mode.info,  Node: racket-expand-file,  Next: racket-expand-region,  Prev: racket-stepper-mode,  Up: Macro expand

5.7.2 racket-expand-file
------------------------

â€˜C-c C-e fâ€™

   Expand the â€˜racket-modeâ€™ bufferâ€™s file in *note
racket-stepper-mode::.

   Uses the â€˜macro-debuggerâ€™ package to do the expansion.

   You do need to *note racket-run:: the file first; the namespace
active in the REPL is not used.

   If the file is non-trivial and/or is not compiled to a .zo bytecode
file, then it might take many seconds before the original form is
displayed and you can start stepping.

   With a prefix, also expands syntax from racket/base â€“ which can
result in very many expansion steps.


File: racket-mode.info,  Node: racket-expand-region,  Next: racket-expand-definition,  Prev: racket-expand-file,  Up: Macro expand

5.7.3 racket-expand-region
--------------------------

â€˜C-c C-e râ€™

   Expand the active region using *note racket-stepper-mode::.

   Uses Racketâ€™s â€˜expand-onceâ€™ in the namespace from the most recent
*note racket-run::.


File: racket-mode.info,  Node: racket-expand-definition,  Next: racket-expand-last-sexp,  Prev: racket-expand-region,  Up: Macro expand

5.7.4 racket-expand-definition
------------------------------

â€˜C-c C-e xâ€™

   Expand the definition around point using *note racket-stepper-mode::.

   Uses Racketâ€™s â€˜expand-onceâ€™ in the namespace from the most recent
*note racket-run::.


File: racket-mode.info,  Node: racket-expand-last-sexp,  Prev: racket-expand-definition,  Up: Macro expand

5.7.5 racket-expand-last-sexp
-----------------------------

â€˜C-c C-e eâ€™

   Expand the sexp before point using *note racket-stepper-mode::.

   Uses Racketâ€™s â€˜expand-onceâ€™ in the namespace from the most recent
*note racket-run::.


File: racket-mode.info,  Node: Other,  Prev: Macro expand,  Up: Commands

5.8 Other
=========

* Menu:

* racket-mode-start-faster::


File: racket-mode.info,  Node: racket-mode-start-faster,  Up: Other

5.8.1 racket-mode-start-faster
------------------------------

â€˜M-xâ€™ â€˜racket-mode-start-fasterâ€™ â€˜RETâ€™

   Compile Racket Modeâ€™s .rkt files for faster startup.

   Racket Mode is implemented as an Emacs Lisp â€œfront endâ€ that talks to
a Racket process â€œback endâ€.  Because Racket Mode is delivered as an
Emacs package instead of a Racket package, installing it does not do the
â€˜raco setupâ€™ that is normally done for Racket packages.

   This command will do a â€˜raco makeâ€™ of Racket Modeâ€™s .rkt files,
creating bytecode files in â€˜compiled/â€™ subdirectories.  As a result,
when a *note racket-run:: or *note racket-repl:: command must start the
Racket process, it will start faster.

   If you run this command, ever, you should run it again after:

   â€¢ Installing an updated version of Racket Mode.  Otherwise, you might
     lose some of the speed-up.

   â€¢ Installing a new version of Racket and/or changing the value of the
     variable *note racket-program::.  Otherwise, you might get an error
     message due to the bytecode being different versions.


File: racket-mode.info,  Node: Variables,  Next: Faces,  Prev: Commands,  Up: Top

6 Variables
***********

* Menu:

* General variables::
* REPL variables::
* Other variables::
* Experimental debugger variables::


File: racket-mode.info,  Node: General variables,  Next: REPL variables,  Up: Variables

6.1 General variables
=====================

* Menu:

* racket-program::
* racket-command-port::
* racket-command-startup::
* racket-command-timeout::
* racket-memory-limit::
* racket-error-context::
* racket-retry-as-skeleton::
* racket-user-command-line-arguments::
* racket-path-from-emacs-to-racket-function::
* racket-path-from-racket-to-emacs-function::


File: racket-mode.info,  Node: racket-program,  Next: racket-command-port,  Up: General variables

6.1.1 racket-program
--------------------

Pathname of the racket executable.


File: racket-mode.info,  Node: racket-command-port,  Next: racket-command-startup,  Prev: racket-program,  Up: General variables

6.1.2 racket-command-port
-------------------------

Port number for Racket REPL command server.


File: racket-mode.info,  Node: racket-command-startup,  Next: racket-command-timeout,  Prev: racket-command-port,  Up: General variables

6.1.3 racket-command-startup
----------------------------

What to do when the REPL and command server arenâ€™t available to send a
command.

   â€¢ nil: Show an error message explaining that you might need to start
     or restart the Racket REPL.

   â€¢ positive number: Automatically try to start the REPL and wait that
     number of seconds for command server to become available.


File: racket-mode.info,  Node: racket-command-timeout,  Next: racket-memory-limit,  Prev: racket-command-startup,  Up: General variables

6.1.4 racket-command-timeout
----------------------------

How many seconds to wait for Racket REPL command server responses.


File: racket-mode.info,  Node: racket-memory-limit,  Next: racket-error-context,  Prev: racket-command-timeout,  Up: General variables

6.1.5 racket-memory-limit
-------------------------

Terminate the Racket process if memory use exceeds this value in MB.
Changes to this value take effect upon the next *note racket-run::.  A
value of 0 means no limit.

   Caveat: This uses Racketâ€™s â€˜custodian-limit-memoryâ€™, which does not
enforce the limit exactly.  Instead, the program will be terminated upon
the first garbage collection where memory exceeds the limit (maybe by a
significant amount).


File: racket-mode.info,  Node: racket-error-context,  Next: racket-retry-as-skeleton,  Prev: racket-memory-limit,  Up: General variables

6.1.6 racket-error-context
--------------------------

The level of context used for *note racket-run:: error stack traces.

   Each level improves stack trace information, but causes your program
to run more slowly.

   â€¢ â€˜low corresponds to â€˜compile-context-preservation-enabledâ€™ â€˜#fâ€™.

   â€¢ â€˜medium corresponds to â€˜compile-context-preservation-enabledâ€™ â€˜#tâ€™,
     which disables some optimizations like inlining.

   â€¢ â€˜high corresponds to â€˜compile-context-preservation-enabledâ€™ â€˜#tâ€™
     and to use of â€˜errortraceâ€™, which heavily instruments your code and
     therefore may be significantly slower.

   Tip: Regardless of this setting, you can enable â€˜high errortrace for
a specific *note racket-run:: using a C-u prefix.  This lets you
normally run with a faster setting, and temporarily re-run to get a
more-helpful error message.


File: racket-mode.info,  Node: racket-retry-as-skeleton,  Next: racket-user-command-line-arguments,  Prev: racket-error-context,  Up: General variables

6.1.7 racket-retry-as-skeleton
------------------------------

Retry a â€œskeletonâ€ of files with errors, for identifier names?

   When true: If your source file has an error, a â€œskeletonâ€ of your
file is evaluated to get identifiers from module languages, â€˜requireâ€™
forms, and definitions.  That way, things like completion and *note
racket-describe:: are more likely to work while you edit the file to fix
the error.

   Otherwise, youâ€™ll have only identifiers provided by â€˜racket/baseâ€™,
until you fix the error and run again.

   You might want to disable this if you work with files that take a
very long time to expand â€” because this feature needs to expand again
when there is an error.


File: racket-mode.info,  Node: racket-user-command-line-arguments,  Next: racket-path-from-emacs-to-racket-function,  Prev: racket-retry-as-skeleton,  Up: General variables

6.1.8 racket-user-command-line-arguments
----------------------------------------

List of command-line arguments to supply to your Racket program.

   Accessible in your Racket program in the usual way â€” the parameter
â€˜current-command-line-argumentsâ€™ and friends.

   This is an Emacs buffer-local variable â€” convenient to set as a file
local variable.  For example at the end of your .rkt file:

     ;; Local Variables:
     ;; racket-user-command-line-arguments: ("-f" "bar")
     ;; End:

   Set this way, the value must be an *unquoted* list of strings.  For
example:

     ("-f" "bar")

   The following values will _not_ work:

     '("-f" "bar")
     (list "-f" "bar")


File: racket-mode.info,  Node: racket-path-from-emacs-to-racket-function,  Next: racket-path-from-racket-to-emacs-function,  Prev: racket-user-command-line-arguments,  Up: General variables

6.1.9 racket-path-from-emacs-to-racket-function
-----------------------------------------------

A function used to transform Emacs Lisp pathnames before supplying to
the Racket back end.

   If you run Emacs on Windows Subsystem for Linux, and want to run
Racket programs using Windows Racket.exe rather than Linux racket, you
can set this to â€˜racket-wsl-to-windowsâ€™.  In that case you probably also
want to customize the â€œreverseâ€: *note
racket-path-from-racket-to-emacs-function::.


File: racket-mode.info,  Node: racket-path-from-racket-to-emacs-function,  Prev: racket-path-from-emacs-to-racket-function,  Up: General variables

6.1.10 racket-path-from-racket-to-emacs-function
------------------------------------------------

A function used to transform pathnames supplied by the Racket back end
before using them in Emacs.

   The default on Windows replaces back with forward slashes.  The
default elsewhere is â€˜identityâ€™.

   If you run Emacs on Windows Subsystem for Linux, and want to run
Racket programs using Windows Racket.exe rather than Linux racket, you
can set this to â€˜racket-windows-to-wslâ€™.  In that case you probably also
want to customize the â€œreverseâ€: *note
racket-path-from-emacs-to-racket-function::.


File: racket-mode.info,  Node: REPL variables,  Next: Other variables,  Prev: General variables,  Up: Variables

6.2 REPL variables
==================

* Menu:

* racket-history-filter-regexp::
* racket-images-inline::
* racket-images-keep-last::
* racket-images-system-viewer::
* racket-pretty-print::


File: racket-mode.info,  Node: racket-history-filter-regexp,  Next: racket-images-inline,  Up: REPL variables

6.2.1 racket-history-filter-regexp
----------------------------------

Input matching this regexp are not saved on the history list.  Defaults
to a regexp ignoring all inputs of 0, 1, or 2 letters.


File: racket-mode.info,  Node: racket-images-inline,  Next: racket-images-keep-last,  Prev: racket-history-filter-regexp,  Up: REPL variables

6.2.2 racket-images-inline
--------------------------

Whether to display inline images in the REPL.


File: racket-mode.info,  Node: racket-images-keep-last,  Next: racket-images-system-viewer,  Prev: racket-images-inline,  Up: REPL variables

6.2.3 racket-images-keep-last
-----------------------------

How many images to keep in the image cache.


File: racket-mode.info,  Node: racket-images-system-viewer,  Next: racket-pretty-print,  Prev: racket-images-keep-last,  Up: REPL variables

6.2.4 racket-images-system-viewer
---------------------------------

Which system image viewer program to invoke upon M-x
â€˜racket-view-last-imageâ€™.


File: racket-mode.info,  Node: racket-pretty-print,  Prev: racket-images-system-viewer,  Up: REPL variables

6.2.5 racket-pretty-print
-------------------------

Use pretty-print instead of print in REPL.


File: racket-mode.info,  Node: Other variables,  Next: Experimental debugger variables,  Prev: REPL variables,  Up: Variables

6.3 Other variables
===================

* Menu:

* racket-indent-curly-as-sequence::
* racket-indent-sequence-depth::
* racket-pretty-lambda::
* racket-smart-open-bracket-enable::
* racket-logger-config::


File: racket-mode.info,  Node: racket-indent-curly-as-sequence,  Next: racket-indent-sequence-depth,  Up: Other variables

6.3.1 racket-indent-curly-as-sequence
-------------------------------------

Indent â€˜{}â€™ with items aligned with the head item?  This is indirectly
disabled if *note racket-indent-sequence-depth:: is 0.  This is safe to
set as a file-local variable.


File: racket-mode.info,  Node: racket-indent-sequence-depth,  Next: racket-pretty-lambda,  Prev: racket-indent-curly-as-sequence,  Up: Other variables

6.3.2 racket-indent-sequence-depth
----------------------------------

To what depth should *note racket-indent-line:: search.  This affects
the indentation of forms like â€™() â€˜() #() â€“ and {} if *note
racket-indent-curly-as-sequence:: is t â€” but not #â€™() #â€˜() ,() ,@().  A
zero value disables, giving the normal indent behavior of DrRacket or
Emacs â€˜lisp-modeâ€™ derived modes like â€˜scheme-modeâ€™.  Setting this to a
high value can make indentation noticeably slower.  This is safe to set
as a file-local variable.


File: racket-mode.info,  Node: racket-pretty-lambda,  Next: racket-smart-open-bracket-enable,  Prev: racket-indent-sequence-depth,  Up: Other variables

6.3.3 racket-pretty-lambda
--------------------------

Display lambda keywords using Î».  This is DEPRECATED. Instead use
â€˜prettify-symbols-modeâ€™ in newer verisons of Emacs, or, use *note
racket-insert-lambda:: to insert actual Î» characters.


File: racket-mode.info,  Node: racket-smart-open-bracket-enable,  Next: racket-logger-config,  Prev: racket-pretty-lambda,  Up: Other variables

6.3.4 racket-smart-open-bracket-enable
--------------------------------------

This variable is obsolete and has no effect.

   Instead of using this variable, you may bind the â€˜[â€™ key to the
â€˜racket-smart-open-bracketâ€™ command in the â€˜racket-mode-mapâ€™ and/or
â€˜racket-repl-mode-mapâ€™ keymaps.


File: racket-mode.info,  Node: racket-logger-config,  Prev: racket-smart-open-bracket-enable,  Up: Other variables

6.3.5 racket-logger-config
--------------------------

Configuration of *note racket-logger-mode:: topics and levels

   The topic â€˜* respresents the default level used for topics not
assigned a level.  Otherwise, the topic symbols are the same as used by
Racketâ€™s â€˜define-loggerâ€™.

   The levels are those used by Racketâ€™s logging system: â€˜debug, â€˜info,
â€˜warning, â€˜error, â€˜fatal.

   For more information see:
<https://docs.racket-lang.org/reference/logging.html>

   The default value sets some known â€œnoisyâ€ topics to be one level
quieter.  That way you can set the â€˜* topic to a level like â€˜debug and
not get overhwelmed by these noisy topics.


File: racket-mode.info,  Node: Experimental debugger variables,  Prev: Other variables,  Up: Variables

6.4 Experimental debugger variables
===================================

* Menu:

* racket-debuggable-files::


File: racket-mode.info,  Node: racket-debuggable-files,  Up: Experimental debugger variables

6.4.1 racket-debuggable-files
-----------------------------

Used to tell *note racket-run:: what files may be instrumented for
debugging.  Must be a list of strings that are pathnames, such as from
â€˜racket--buffer-file-nameâ€™, -or-, a function that returns such a list
given the pathname of the file being run.  If any path strings are
relative, they are made absolute using â€˜expand-file-nameâ€™ with the
directory of the file being run.  The symbol â€˜run-file may be supplied
in the list; it will be replaced with the pathname of the file being
run.  Safe to set as a file-local variable.


File: racket-mode.info,  Node: Faces,  Prev: Variables,  Up: Top

7 Faces
*******

* Menu:

* All::


File: racket-mode.info,  Node: All,  Up: Faces

7.1 All
=======

* Menu:

* racket-keyword-argument-face::
* racket-selfeval-face::
* racket-here-string-face::
* racket-check-syntax-def-face::
* racket-check-syntax-use-face::
* racket-logger-config-face::
* racket-logger-topic-face::
* racket-logger-fatal-face::
* racket-logger-error-face::
* racket-logger-warning-face::
* racket-logger-info-face::
* racket-logger-debug-face::


File: racket-mode.info,  Node: racket-keyword-argument-face,  Next: racket-selfeval-face,  Up: All

7.1.1 racket-keyword-argument-face
----------------------------------

Face for â€˜#:keywordâ€™ arguments.


File: racket-mode.info,  Node: racket-selfeval-face,  Next: racket-here-string-face,  Prev: racket-keyword-argument-face,  Up: All

7.1.2 racket-selfeval-face
--------------------------

Face for self-evaluating expressions like numbers, symbols, strings.


File: racket-mode.info,  Node: racket-here-string-face,  Next: racket-check-syntax-def-face,  Prev: racket-selfeval-face,  Up: All

7.1.3 racket-here-string-face
-----------------------------

Face for here strings.


File: racket-mode.info,  Node: racket-check-syntax-def-face,  Next: racket-check-syntax-use-face,  Prev: racket-here-string-face,  Up: All

7.1.4 racket-check-syntax-def-face
----------------------------------

Face *note racket-check-syntax-mode:: uses to highlight definitions.


File: racket-mode.info,  Node: racket-check-syntax-use-face,  Next: racket-logger-config-face,  Prev: racket-check-syntax-def-face,  Up: All

7.1.5 racket-check-syntax-use-face
----------------------------------

Face *note racket-check-syntax-mode:: uses to highlight uses.


File: racket-mode.info,  Node: racket-logger-config-face,  Next: racket-logger-topic-face,  Prev: racket-check-syntax-use-face,  Up: All

7.1.6 racket-logger-config-face
-------------------------------

Face for *note racket-logger-mode:: configuration.


File: racket-mode.info,  Node: racket-logger-topic-face,  Next: racket-logger-fatal-face,  Prev: racket-logger-config-face,  Up: All

7.1.7 racket-logger-topic-face
------------------------------

Face for *note racket-logger-mode:: topics.


File: racket-mode.info,  Node: racket-logger-fatal-face,  Next: racket-logger-error-face,  Prev: racket-logger-topic-face,  Up: All

7.1.8 racket-logger-fatal-face
------------------------------

Face for *note racket-logger-mode:: fatal level.


File: racket-mode.info,  Node: racket-logger-error-face,  Next: racket-logger-warning-face,  Prev: racket-logger-fatal-face,  Up: All

7.1.9 racket-logger-error-face
------------------------------

Face for *note racket-logger-mode:: error level.


File: racket-mode.info,  Node: racket-logger-warning-face,  Next: racket-logger-info-face,  Prev: racket-logger-error-face,  Up: All

7.1.10 racket-logger-warning-face
---------------------------------

Face for *note racket-logger-mode:: warning level.


File: racket-mode.info,  Node: racket-logger-info-face,  Next: racket-logger-debug-face,  Prev: racket-logger-warning-face,  Up: All

7.1.11 racket-logger-info-face
------------------------------

Face for *note racket-logger-mode:: info level.


File: racket-mode.info,  Node: racket-logger-debug-face,  Prev: racket-logger-info-face,  Up: All

7.1.12 racket-logger-debug-face
-------------------------------

Face for *note racket-logger-mode:: debug level.



Tag Table:
Node: Top220
Node: Introduction3109
Ref: Introduction-Footnote-14166
Node: Install4561
Node: Configure Emacs to use MELPA4882
Node: Install Racket Mode5355
Node: Minimal Racket5644
Node: Uninstall6208
Node: Update6496
Node: Configure6943
Node: Key bindings8054
Node: Font-lock (syntax highlighting)8671
Node: Completion9955
Node: paredit11352
Node: smartparens12349
Node: eldoc12700
Node: Start faster13714
Node: Unicode input method13939
Node: Reference14635
Node: Commands15124
Node: Run15328
Node: racket-run15576
Node: racket-repl17528
Node: racket-racket18641
Node: racket-profile18845
Node: racket-profile-mode19560
Node: racket-logger20619
Node: racket-logger-mode21030
Node: racket-debug-mode22398
Node: Test25873
Node: racket-test26018
Node: racket-raco-test26639
Node: Eval26896
Node: racket-send-region27082
Node: racket-send-definition27300
Node: racket-send-last-sexp27549
Node: Visit27859
Node: racket-visit-definition28099
Node: racket-visit-module29186
Node: racket-unvisit29635
Node: racket-open-require-path29900
Node: racket-find-collection30676
Node: Learn31627
Node: racket-describe31775
Node: racket-doc32943
Node: Edit33613
Node: racket-insert-lambda34160
Node: racket-fold-all-tests34428
Node: racket-unfold-all-tests34665
Node: racket-tidy-requires34908
Node: racket-trim-requires35965
Node: racket-base-requires36680
Node: racket-indent-line37935
Node: racket-smart-open-bracket-mode39742
Node: racket-insert-closing41397
Node: racket-cycle-paren-shapes41888
Node: racket-backward-up-list42139
Node: racket-check-syntax-mode42689
Node: racket-unicode-input-method-enable44210
Node: racket-align46221
Node: racket-unalign48199
Node: racket-complete-at-point48542
Node: Macro expand49345
Node: racket-stepper-mode49608
Node: racket-expand-file50656
Node: racket-expand-region51380
Node: racket-expand-definition51746
Node: racket-expand-last-sexp52135
Node: Other52487
Node: racket-mode-start-faster52623
Node: Variables53791
Node: General variables54008
Node: racket-program54460
Node: racket-command-port54640
Node: racket-command-startup54870
Node: racket-command-timeout55398
Node: racket-memory-limit55665
Node: racket-error-context56268
Node: racket-retry-as-skeleton57289
Node: racket-user-command-line-arguments58157
Node: racket-path-from-emacs-to-racket-function59020
Node: racket-path-from-racket-to-emacs-function59707
Node: REPL variables60466
Node: racket-history-filter-regexp60772
Node: racket-images-inline61084
Node: racket-images-keep-last61331
Node: racket-images-system-viewer61581
Node: racket-pretty-print61877
Node: Other variables62085
Node: racket-indent-curly-as-sequence62421
Node: racket-indent-sequence-depth62801
Node: racket-pretty-lambda63488
Node: racket-smart-open-bracket-enable63891
Node: racket-logger-config64347
Node: Experimental debugger variables65142
Node: racket-debuggable-files65359
Node: Faces66053
Node: All66156
Node: racket-keyword-argument-face66590
Node: racket-selfeval-face66800
Node: racket-here-string-face67059
Node: racket-check-syntax-def-face67278
Node: racket-check-syntax-use-face67561
Node: racket-logger-config-face67839
Node: racket-logger-topic-face68096
Node: racket-logger-fatal-face68340
Node: racket-logger-error-face68588
Node: racket-logger-warning-face68838
Node: racket-logger-info-face69095
Node: racket-logger-debug-face69343

End Tag Table


Local Variables:
coding: utf-8
End:
