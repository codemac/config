This is racket-mode.info, produced by makeinfo version 6.7 from
racket-mode.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Racket Mode: (racket-mode). Edit and REPL major modes for Racket lang.
END-INFO-DIR-ENTRY


File: racket-mode.info,  Node: Top,  Next: Introduction,  Up: (dir)

Racket Mode
***********

* Menu:

* Introduction::
* Install::
* Configure::
* Reference::
* Commands::
* Variables::
* Faces::

â€” The Detailed Node Listing â€”

Install

* Configure Emacs to use MELPA::
* Install Racket Mode::
* Minimal Racket::
* Uninstall::
* Update::

Update

* Upgrading all packages::
* Updating just Racket Mode::
Configure

* Key bindings::
* Font-lock (syntax highlighting)::
* Completion::
* Xref (definitions and references)::
* Indent::
* paredit::
* smartparens::
* Edit buffers and REPL buffers::
* eldoc::
* Start faster::
* Unicode input method::
* Ligatures::

Commands

* Edit::
* Explore::
* Run::
* Test::
* Eval::
* Collections::
* Macro expand::
* Other::
* Showing information::
* Associating edit buffers with REPL buffers::
* Browsing file URLs with anchors::

Edit

* racket-mode::
* racket-insert-lambda::
* racket-fold-all-tests::
* racket-unfold-all-tests::
* racket-tidy-requires::
* racket-trim-requires::
* racket-base-requires::
* racket-add-require-for-identifier::
* racket-indent-line::
* racket-smart-open-bracket-mode::
* racket-insert-closing::
* racket-cycle-paren-shapes::
* racket-backward-up-list::
* racket-unicode-input-method-enable::
* racket-align::
* racket-unalign::
* racket-complete-at-point::

Explore

* racket-xp-mode::
* racket-xp-describe::
* racket-xp-documentation::
* racket-xp-next-definition::
* racket-xp-previous-definition::
* racket-xp-next-use::
* racket-xp-previous-use::
* racket-xp-next-error::
* racket-xp-previous-error::
* racket-xp-tail-up::
* racket-xp-tail-down::
* racket-xp-tail-next-sibling::
* racket-xp-tail-previous-sibling::
* racket-documentation-search::

Run

* racket-repl-mode::
* racket-run::
* racket-run-and-switch-to-repl::
* racket-run-module-at-point::
* racket-repl::
* racket-repl-describe::
* racket-repl-documentation::
* racket-racket::
* racket-profile::
* racket-profile-mode::
* racket-logger::
* racket-logger-mode::
* racket-debug-mode::
* racket-repl-clear::
* racket-repl-clear-leaving-last-prompt::

Test

* racket-test::
* racket-raco-test::

Eval

* racket-send-region::
* racket-send-definition::
* racket-send-last-sexp::

Collections

* racket-open-require-path::
* racket-find-collection::

Macro expand

* racket-stepper-mode::
* racket-expand-file::
* racket-expand-region::
* racket-expand-definition::
* racket-expand-last-sexp::

Other

* racket-mode-start-faster::
* racket-mode-start-slower::

Showing information

* racket-show-pseudo-tooltip::
* racket-show-echo-area::
* racket-show-header-line::
* racket-show-pos-tip::

Associating edit buffers with REPL buffers

* racket-repl-buffer-name-shared::
* racket-repl-buffer-name-unique::
* racket-repl-buffer-name-project::
* racket-project-root::

Browsing file URLs with anchors

* racket-browse-url-using-temporary-file::
Variables

* General variables::
* REPL variables::
* Other variables::
* Experimental debugger variables::
* Showing information: Showing informationx.

General variables

* racket-program::
* racket-command-timeout::
* racket-memory-limit::
* racket-error-context::
* racket-user-command-line-arguments::
* racket-path-from-emacs-to-racket-function::
* racket-path-from-racket-to-emacs-function::
* racket-browse-url-function::
* racket-xp-after-change-refresh-delay::
* racket-xp-highlight-unused-regexp::
* racket-documentation-search-location::

REPL variables

* racket-repl-buffer-name-function::
* racket-submodules-to-run::
* racket-repl-history-directory::
* racket-history-filter-regexp::
* racket-images-inline::
* racket-imagemagick-props::
* racket-images-keep-last::
* racket-images-system-viewer::
* racket-pretty-print::

Other variables

* racket-indent-curly-as-sequence::
* racket-indent-sequence-depth::
* racket-pretty-lambda::
* racket-smart-open-bracket-enable::
* racket-logger-config::
* racket-before-run-hook::
* racket-after-run-hook::

Experimental debugger variables

* racket-debuggable-files::

Showing information

* racket-show-functions::
Faces

* All::

All

* racket-keyword-argument-face::
* racket-selfeval-face::
* racket-here-string-face::
* racket-xp-def-face::
* racket-xp-use-face::
* racket-xp-unused-face::
* racket-xp-tail-target-face::
* racket-xp-tail-position-face::
* racket-logger-config-face::
* racket-logger-topic-face::
* racket-logger-fatal-face::
* racket-logger-error-face::
* racket-logger-warning-face::
* racket-logger-info-face::
* racket-logger-debug-face::


File: racket-mode.info,  Node: Introduction,  Next: Install,  Prev: Top,  Up: Top

1 Introduction
**************

The Racket Mode (https://www.racket-mode.com/) package consists of a
variety of Emacs major and minor modes, including:

   â€¢ â€˜racket-modeâ€™: A major mode for editing â€˜.rktâ€™ files.

   â€¢ *note racket-xp-mode::: An optional minor mode that enhances
     â€˜racket-modeâ€™ to explain and explore code.

   â€¢ â€˜racket-repl-modeâ€™: A major mode for running programs providing a
     REPL.

   â€¢ Various other modes to support specific features:
        â€¢ *note racket-logger-mode::
        â€¢ *note racket-profile-mode::
        â€¢ *note racket-debug-mode::

   Racket Mode uses a â€œback end serverâ€ written in Racket, which is
responsible for running files and implementing commands that cannot be
implemented in Emacs Lisp.(1)

   For code, issues, and pull requests, see the Git repo
(https://github.com/greghendershott/racket-mode).

   To fund this work, see GitHub Sponsors
(https://github.com/users/greghendershott/sponsorship) or PayPal
(https://www.paypal.me/greghendershott).

   ---------- Footnotes ----------

   (1) Racket Modeâ€™s Racket code is also delivered as part of the Emacs
package â€” _not_ as a Racket package.  Delivering both Emacs and Racket
code in one Emacs package simplifies installation and updates.  The main
drawback is that the Racket code is not automatically byte-compiled, as
would normally be done by â€˜raco pkg installâ€™.  To address this: *Note
racket-mode-start-faster::.


File: racket-mode.info,  Node: Install,  Next: Configure,  Prev: Introduction,  Up: Top

2 Install
*********

The recommended way to use Racket Mode is to install the package from
MELPA (https://melpa.org/#/racket-mode).
* Menu:

* Configure Emacs to use MELPA::
* Install Racket Mode::
* Minimal Racket::
* Uninstall::
* Update::


File: racket-mode.info,  Node: Configure Emacs to use MELPA,  Next: Install Racket Mode,  Up: Install

2.1 Configure Emacs to use MELPA
================================

To use MELPA:

   â€¢ Add the following to your ~/.emacs or ~/.emacs.d/init.el:

     (require 'package)
     (add-to-list 'package-archives
     	      '("melpa" . "https://melpa.org/packages/")
     	      t)

   â€¢ Restart Emacs.

   â€¢ Type â€˜M-xâ€™ â€˜package-refresh-contentsâ€™ â€˜RETâ€™ .


File: racket-mode.info,  Node: Install Racket Mode,  Next: Minimal Racket,  Prev: Configure Emacs to use MELPA,  Up: Install

2.2 Install Racket Mode
=======================

When Emacs is configured to use MELPA, simply type â€˜M-xâ€™
â€˜package-installâ€™ â€˜RETâ€™ â€˜racket-modeâ€™ â€˜RETâ€™ .


File: racket-mode.info,  Node: Minimal Racket,  Next: Uninstall,  Prev: Install Racket Mode,  Up: Install

2.3 Minimal Racket
==================

If you have installed the minimal Racket distribution (for example by
using the homebrew formula
(https://github.com/Homebrew/homebrew-core/blob/master/Formula/minimal-racket.rb))
Racket Mode needs some additional packages (like â€˜errortraceâ€™ and
â€˜macro-debuggerâ€™).  A simple way to get all these packages is to install
the â€˜drracketâ€™ Racket package.  In a command shell:

     raco pkg install drracket


File: racket-mode.info,  Node: Uninstall,  Next: Update,  Prev: Minimal Racket,  Up: Install

2.4 Uninstall
=============

To uninstall Racket Mode, simply type â€˜M-xâ€™ â€˜package-deleteâ€™ â€˜RETâ€™
â€˜racket-modeâ€™ â€˜RETâ€™ .

   You should probably also exit and restart Emacs.


File: racket-mode.info,  Node: Update,  Prev: Uninstall,  Up: Install

2.5 Update
==========

* Menu:

* Upgrading all packages::
* Updating just Racket Mode::


File: racket-mode.info,  Node: Upgrading all packages,  Next: Updating just Racket Mode,  Up: Update

2.5.1 Upgrading all packages
----------------------------

The â€œeasy pathâ€ provided by Emacs is to update _all_ packages to their
latest versions.  Although you might not want to do this â€” see next
section â€” here is how to do so:

  1. Use â€˜M-xâ€™ â€˜list-packagesâ€™.  It should display a message like â€œ42
     packages can be upgraded; type â€˜Uâ€™ to mark them for upgrading.â€.

  2. Press â€˜Uâ€™ as suggested to mark them all.

  3. Press â€˜xâ€™ to execute.

   After such a mass update, it might be wise to exist restart Emacs.


File: racket-mode.info,  Node: Updating just Racket Mode,  Prev: Upgrading all packages,  Up: Update

2.5.2 Updating just Racket Mode
-------------------------------

Updating all packages sometimes is more than you want.  For example,
maybe you will discover that some packages have changed in ways that
require you to take time to learn about, change customizations, and so
on.

   To update just Racket Mode:

  1. Uninstall Racket Mode: â€˜M-xâ€™ â€˜package-deleteâ€™ â€˜RETâ€™ â€˜racket-modeâ€™
     â€˜RETâ€™ .

  2. Optional but most reliable: Exit and restart Emacs.

  3. Install Racket Mode: â€˜M-xâ€™ â€˜package-installâ€™ â€˜RETâ€™ â€˜racket-modeâ€™
     â€˜RETâ€™ .  This will install the latest version.


File: racket-mode.info,  Node: Configure,  Next: Reference,  Prev: Install,  Up: Top

3 Configure
***********

Although Racket Mode can be customized with many *note Variables::,
there is only one that you might _need_ to set: *note racket-program::.
This is the name or pathname of the Racket executable.  It defaults to
â€˜Racket.exeâ€™ on Windows else â€˜racketâ€™.

   On Windows or Linux, this default will probably work for you.

   On macOS, downloading Racket doesnâ€™t add its â€˜binâ€™ directory to your
â€˜PATHâ€™.  Even after you add it, GUI Emacs doesnâ€™t automatically use your
path (unless you use the handy exec-path-from-shell
(https://melpa.org/#/exec-path-from-shell) package).  Therefore you
might want to set â€˜racket-programâ€™ to a complete pathname.

   You can â€˜setqâ€™ this directly in your Emacs init file (~/.emacs or
~/.emacs.d/init.el), or, use â€˜M-xâ€™ â€˜customizeâ€™, as you prefer.
* Menu:

* Key bindings::
* Font-lock (syntax highlighting)::
* Completion::
* Xref (definitions and references)::
* Indent::
* paredit::
* smartparens::
* Edit buffers and REPL buffers::
* eldoc::
* Start faster::
* Unicode input method::
* Ligatures::


File: racket-mode.info,  Node: Key bindings,  Next: Font-lock (syntax highlighting),  Up: Configure

3.1 Key bindings
================

To customize things like key bindings, you can use â€˜racket-mode-hookâ€™ in
your Emacs init file to modify â€˜racket-mode-mapâ€™.  For example, although
â€˜C-c C-câ€™ is bound by default to the â€˜racket-runâ€™ command, letâ€™s say you
wanted â€˜F5â€™ to be an additional binding:

     (add-hook 'racket-mode-hook
     	  (lambda ()
     	    (define-key racket-mode-map (kbd "<f5>") 'racket-run)))

   Likewise for â€˜racket-repl-mode-hookâ€™ and â€˜racket-repl-mode-mapâ€™.


File: racket-mode.info,  Node: Font-lock (syntax highlighting),  Next: Completion,  Prev: Key bindings,  Up: Configure

3.2 Font-lock (syntax highlighting)
===================================

Font-lock (as Emacs calls syntax highlighting) can be controlled using
the variable â€˜font-lock-maximum-decorationâ€™, which defaults to â€˜tâ€™
(maximum).  You can set it to a number, where â€˜0â€™ is the lowest level.
You can even supply an association list to specify different values for
different major modes.

   Historically you might choose a lower level for speed.  These days
you might do so because you prefer a simpler appearance.

   Racket Mode supports four, increasing levels of font-lock:

   â€¢ â€˜0â€™: Just strings, comments, and â€˜#langâ€™.
   â€¢ â€˜1â€™: â€˜#:keywordâ€™ and self-evaluating literals like numbers, quoted
     symbols (including symbols with spaces delimited by â€˜|â€™
     characters), and â€˜#rxâ€™ and â€˜#pxâ€™ regular expressions.
   â€¢ â€˜2â€™: Identifiers in â€˜defineâ€™-like and â€˜letâ€™-like forms.
   â€¢ â€˜3â€™: Identifiers provided by â€˜racketâ€™, â€˜typed/racketâ€™,
     â€˜racket/syntaxâ€™, and â€˜syntax/parseâ€™.  (This level effectively
     treats Racket as a language, instead of a language for making
     languages.).


File: racket-mode.info,  Node: Completion,  Next: Xref (definitions and references),  Prev: Font-lock (syntax highlighting),  Up: Configure

3.3 Completion
==============

In Emacs, a major mode may supply a â€œcompletion-at-point functionâ€.
This function is used by manual completion commands like
â€˜complete-symbolâ€™ (bound by default to â€˜C-M-iâ€™ ), as well as by
auto-completion packages like â€˜company-modeâ€™.

   â€¢ â€˜racket-modeâ€™ supplies â€˜racket-complete-at-pointâ€™, which simply
     supplies the same symbols that it knows how to font-lock.  This
     does _not_ require the Racket Mode back end to be running.  But of
     course the completion candidates do not correspond to your
     programâ€™s definitions or those it imports.  This is a static,
     â€œbetter than nothingâ€ fallback.

   â€¢ â€˜racket-xp-modeâ€™ â€” an optional minor mode that enhances
     â€˜racket-modeâ€™ â€” supplies â€˜racket-xp-complete-at-pointâ€™, which uses
     a static analysis to find local and imported binding names.
     Although this requires the Racket Mode back end to be running â€” and
     will automatically start it â€” it does _not_ require the edit buffer
     to be â€˜racket-runâ€™.

   â€¢ â€˜racket-repl-modeâ€™ supplies â€˜racket-repl-complete-at-pointâ€™, which
     uses the result of â€˜namespace-mapped-symbolsâ€™ on the program
     currently running in the REPL.

   These completion functions are set by default.  (However,
â€˜racket-xp-modeâ€™ is not enabled by default.  To do so: *note
racket-xp-mode::.)

   If you want â€˜TABâ€™ to do completion as well as indent, add the
following to your Emacs init file:

     (setq tab-always-indent 'complete)

   This changes the behavior of Emacsâ€™ standard
â€˜indent-for-tab-commandâ€™, to which â€˜TABâ€™ is bound by default in
â€˜racket-modeâ€™ and â€˜racket-repl-modeâ€™.


File: racket-mode.info,  Node: Xref (definitions and references),  Next: Indent,  Prev: Completion,  Up: Configure

3.4 Xref (definitions and references)
=====================================

Several modes support the Emacs commands

   â€¢ â€˜M-.â€™  â€˜xref-find-definitionsâ€™
   â€¢ â€˜M-?â€™  â€˜xref-find-referencesâ€™
   â€¢ â€˜M-,â€™ â€˜xref-pop-marker-stackâ€™

   To do so, each mode adds a local hook for â€˜xref-backend-functionsâ€™:

   â€¢ *note racket-mode::: â€˜#'racket-mode-xref-backend-functionâ€™
   â€¢ *note racket-xp-mode::: â€˜#'racket-xp-xref-backend-functionâ€™
   â€¢ *note racket-repl-mode::: â€˜#'racket-repl-xref-backend-functionâ€™

   If you prefer, you can remove the local hook â€” e.g.  for
â€˜racket-modeâ€™: â€˜(remove-hook 'xref-backend-functions
#'racket-mode-xref-function t)â€™.

   You can â€˜M-x customize-groupâ€™ and enter â€˜xrefâ€™ to adjust some other
settings.  For example, the customization variable
â€˜xref-prompt-for-identifierâ€™ controls which commands prompt you and
when.  You might prefer to set it to â€˜nilâ€™.

   If you use â€˜pareditâ€™, by default it binds â€˜M-?â€™ to
â€˜paredit-convolute-sexpâ€™.  You can change that binding in
â€˜paredit-mode-mapâ€™ allowing the global binding for â€˜M-?â€™ to be used, or,
pick some other key for â€˜xref-find-referencesâ€™ in the global map.

   Finally, what to expect:

   â€¢ Racket does not have a global or project-wide database of
     definitions and references.
   â€¢ Various modules can export identifiers with the same symbolic value
     â€“ for example a different â€œdefineâ€ is provided by â€˜racket/baseâ€™,
     â€˜typed/racket/baseâ€™, and other modules.
   â€¢ A module can import something, then rename, contract, and re-export
     it.

   As a result, to find a definition, it is necessary to know exactly
_which_ identifier is meant â€” either by expanding the module (as is done
by â€˜racket-xp-modeâ€™) or by actually running it (â€˜racket-repl-modeâ€™).
Once known, we can usually find the definition site, even through a
chain of renaming and/or contract-wrapping exports.  In addition, when
point is on a module within â€˜requireâ€™ form, we can usually find the
source file.  (In plain â€˜racket-modeâ€™ edit buffers not enhanced by
â€˜racket-xp-modeâ€™, the only thing that â€˜xref-find-definitionsâ€™ does is
visit relative requires, e.g.  â€˜foo.rktâ€™ in â€˜(require "foo.rkt")â€™.)

   As for finding references, the default xref implementation is used,
which greps for strings among a projectâ€™s files.  Although
â€˜racket-xp-modeâ€™ can sometimes do better, using â€˜drracket/check-syntaxâ€™
for definitions and references _within_ the current buffer, beyond those
it also falls back to the default implementation.

   In any case, using the Emacs xref API allows for consistent command
names, shortcut keys, and even a special buffer to navigate among
references and visit each source location.


File: racket-mode.info,  Node: Indent,  Next: paredit,  Prev: Xref (definitions and references),  Up: Configure

3.5 Indent
==========

Indentation can be customized in a way similar to lisp-mode and
scheme-mode: *note racket-indent-line::.


File: racket-mode.info,  Node: paredit,  Next: smartparens,  Prev: Indent,  Up: Configure

3.6 paredit
===========

If you use paredit (https://melpa.org/#/paredit), you might want to add
keybindings to â€˜paredit-mode-mapâ€™:

   â€¢ Bind the curly brace keys to â€˜paredit-open-curlyâ€™ and
     â€˜paredit-close-curlyâ€™.

   â€¢ Bind whatever keys you prefer for â€˜paredit-wrap-squareâ€™ and
     â€˜paredit-wrap-curlyâ€™.

   For example, with â€˜use-packageâ€™ (https://melpa.org/#/use-package):

     (use-package paredit
       :ensure t
       :config
       (dolist (m '(emacs-lisp-mode-hook
     	       racket-mode-hook
     	       racket-repl-mode-hook))
         (add-hook m #'paredit-mode))
       (bind-keys :map paredit-mode-map
     	     ("{"   . paredit-open-curly)
     	     ("}"   . paredit-close-curly))
       (unless terminal-frame
         (bind-keys :map paredit-mode-map
     	       ("M-[" . paredit-wrap-square)
     	       ("M-{" . paredit-wrap-curly))))


File: racket-mode.info,  Node: smartparens,  Next: Edit buffers and REPL buffers,  Prev: paredit,  Up: Configure

3.7 smartparens
===============

If instead of paredit you prefer smartparens
(https://melpa.org/#/smartparens), you can use the default configuration
it provides for Lisp modes generally and for Racket Mode specifically:

     (require 'smartparens-config)


File: racket-mode.info,  Node: Edit buffers and REPL buffers,  Next: eldoc,  Prev: smartparens,  Up: Configure

3.8 Edit buffers and REPL buffers
=================================

By default, all â€˜racket-modeâ€™ edit buffers share one â€˜racket-repl-modeâ€™
buffer, named â€˜*Racket REPL*â€™.  For example, if you run foo.rkt, the
REPL prompt changes to â€˜foo.rkt>â€™, and the REPL is inside the file
module namespace.  If you then run bar.rkt, the REPL prompt changes to
â€˜bar.rkt>â€™, and you are in that namespace.

   If you prefer, you can use more than one REPL buffer, by customizing
the variable *note racket-repl-buffer-name-function:::

   â€¢ Share a REPL buffer among files belonging to the same project; each
     REPL buffer is named â€˜*Racket REPL <project-name>*â€™.
   â€¢ A unique REPL buffer for each edit buffer, similar to Dr Racket;
     each REPL buffer is named â€˜*Racket REPL <file.rkt>*â€™.
   â€¢ You can also define your own, custom function.

   You can customize where the REPL buffer is displayed by adding an
item to the Emacs variable â€˜display-buffer-alistâ€™.  A good regular
expression to use for this would be â€˜\\`\\*Racket REPLâ€™.  For example,
if you wanted to make the REPL buffer appear in a new frame:

     (add-to-list 'display-buffer-alist
     	     '("\\`\\*Racket REPL"
     	       (display-buffer-reuse-window
     		display-buffer-pop-up-frame)
     	       (reusable-frames . 0)
     	       (inhibit-same-window . t)))


File: racket-mode.info,  Node: eldoc,  Next: Start faster,  Prev: Edit buffers and REPL buffers,  Up: Configure

3.9 eldoc
=========

By default Racket Mode sets â€˜eldoc-documentation-functionâ€™ to â€˜nilâ€™ â€” no
â€˜eldoc-modeâ€™ support.  You may set it to â€˜racket-eldoc-functionâ€™ in a
â€˜racket-mode-hookâ€™ and â€˜racket-repl-mode-hookâ€™ if you really want to use
â€˜eldoc-modeâ€™ with Racket.  But it is not a very satisfying experience
because Racket is not a very â€œeldoc-friendlyâ€ language.  Although Racket
Mode attempts to discover argument lists, contracts, or types this
doesnâ€™t work in many common cases:

   â€¢ Many Racket primitives are defined in â€˜#%kernelâ€™ or â€˜#%runtimeâ€™.
     Thereâ€™s no easy way to determine their argument lists.  Most do not
     â€˜provideâ€™ a contract.

   â€¢ Many of the interesting Racket forms are syntax (macros) not
     functions.  Thereâ€™s no easy way to determine their â€œargument
     listsâ€.

   â€¢ When a form has documentation, Racket Mode can show the \"bluebox\â€
     â€“ but often that does not fit in a single line as you would
     normally expect with eldoc.

   A more satisfying experience is to use *note racket-xp-describe:: or
*note racket-xp-documentation::.


File: racket-mode.info,  Node: Start faster,  Next: Unicode input method,  Prev: eldoc,  Up: Configure

3.10 Start faster
=================

You can use *note racket-mode-start-faster:: to make the Racket REPL
start faster.


File: racket-mode.info,  Node: Unicode input method,  Next: Ligatures,  Prev: Start faster,  Up: Configure

3.11 Unicode input method
=========================

An optional Emacs input method, â€˜racket-unicodeâ€™, lets you easily type
various Unicode symbols that might be useful when writing Racket code.

   To automatically enable the â€˜racket-unicodeâ€™ input method in
â€˜racket-modeâ€™ and â€˜racket-repl-modeâ€™ buffers, put the following code in
your Emacs init file:

     (add-hook 'racket-mode-hook      #'racket-unicode-input-method-enable)
     (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)

   *Note racket-unicode-input-method-enable::.

   *Note racket-insert-lambda::.


File: racket-mode.info,  Node: Ligatures,  Prev: Unicode input method,  Up: Configure

3.12 Ligatures
==============

Prior to Emacs 28.0.50, things like â€˜auto-composition-modeâ€™ or
â€˜ligature-modeâ€™ that use â€˜composition-function-tableâ€™ to display
ligatures can cause Emacs to freeze.  This can happen when an Emacs
â€˜overlayâ€™ displays a string containing such a ligature â€” this includes
the overlays created by â€˜racket-show-pseudo-tooltipâ€™, as used by
â€˜racket-xp-modeâ€™.  The only known work-around is to change the value of
â€˜racket-show-functionsâ€™ to something â€œboringâ€ such as
â€˜(racket-show-echo-area)â€™.


File: racket-mode.info,  Node: Reference,  Next: Commands,  Prev: Configure,  Up: Top

4 Reference
***********

The following sections are generated from the doc strings for each
command, variable, or face.  (As a result, some of the formatting might
not be quite as nice or correct as in the previous sections.)

   You can also view these by using the normal Emacs help mechanism:

   â€¢ â€˜C-h fâ€™ and enter the name of a command.
   â€¢ â€˜C-h vâ€™ and enter the name of a variable.


File: racket-mode.info,  Node: Commands,  Next: Variables,  Prev: Reference,  Up: Top

5 Commands
**********

* Menu:

* Edit::
* Explore::
* Run::
* Test::
* Eval::
* Collections::
* Macro expand::
* Other::
* Showing information::
* Associating edit buffers with REPL buffers::
* Browsing file URLs with anchors::


File: racket-mode.info,  Node: Edit,  Next: Explore,  Up: Commands

5.1 Edit
========

* Menu:

* racket-mode::
* racket-insert-lambda::
* racket-fold-all-tests::
* racket-unfold-all-tests::
* racket-tidy-requires::
* racket-trim-requires::
* racket-base-requires::
* racket-add-require-for-identifier::
* racket-indent-line::
* racket-smart-open-bracket-mode::
* racket-insert-closing::
* racket-cycle-paren-shapes::
* racket-backward-up-list::
* racket-unicode-input-method-enable::
* racket-align::
* racket-unalign::
* racket-complete-at-point::


File: racket-mode.info,  Node: racket-mode,  Next: racket-insert-lambda,  Up: Edit

5.1.1 racket-mode
-----------------

â€˜M-xâ€™ â€˜racket-modeâ€™

   Major mode for editing Racket source files.

Key                                                             Binding
â€˜}â€™                                                             *note racket-insert-closing::
â€˜]â€™                                                             *note racket-insert-closing::
â€˜)â€™                                                             *note racket-insert-closing::
â€˜TABâ€™                                                           â€˜indent-for-tab-commandâ€™
â€˜C-x C-eâ€™                                                       *note racket-send-last-sexp::
â€˜C-M-yâ€™                                                         *note racket-insert-lambda::
â€˜C-M-uâ€™                                                         *note racket-backward-up-list::
â€˜C-M-xâ€™                                                         *note racket-send-definition::
â€˜C-c C-uâ€™                                                       *note racket-unfold-all-tests::
â€˜C-c C-fâ€™                                                       *note racket-fold-all-tests::
â€˜C-c C-dâ€™                                                       *note racket-documentation-search::
â€˜C-c C-pâ€™                                                       *note racket-cycle-paren-shapes::
â€˜C-c C-x C-fâ€™                                                   *note racket-open-require-path::
â€˜C-c C-e râ€™                                                     *note racket-expand-region::
â€˜C-c C-e eâ€™                                                     *note racket-expand-last-sexp::
â€˜C-c C-e xâ€™                                                     *note racket-expand-definition::
â€˜C-c C-e fâ€™                                                     *note racket-expand-file::
â€˜C-c C-râ€™                                                       *note racket-send-region::
â€˜C-c C-oâ€™                                                       *note racket-profile::
â€˜C-c C-lâ€™                                                       *note racket-logger::
â€˜C-c C-tâ€™                                                       *note racket-test::
â€˜C-c C-zâ€™                                                       *note racket-repl::
â€˜C-c C-kâ€™                                                       *note racket-run-module-at-point::
â€˜C-c C-câ€™                                                       *note racket-run-module-at-point::

   In addition to any hooks its parent mode â€˜prog-modeâ€™ might have run,
this mode runs the hook â€˜racket-mode-hookâ€™, as the final step during
initialization.


File: racket-mode.info,  Node: racket-insert-lambda,  Next: racket-fold-all-tests,  Prev: racket-mode,  Up: Edit

5.1.2 racket-insert-lambda
--------------------------

â€˜C-M-yâ€™

   Insert Î».

   To insert Unicode symbols generally, see *note
racket-unicode-input-method-enable::.


File: racket-mode.info,  Node: racket-fold-all-tests,  Next: racket-unfold-all-tests,  Prev: racket-insert-lambda,  Up: Edit

5.1.3 racket-fold-all-tests
---------------------------

â€˜C-c C-fâ€™

   Fold (hide) all test submodules.


File: racket-mode.info,  Node: racket-unfold-all-tests,  Next: racket-tidy-requires,  Prev: racket-fold-all-tests,  Up: Edit

5.1.4 racket-unfold-all-tests
-----------------------------

â€˜C-c C-uâ€™

   Unfold (show) all test submodules.


File: racket-mode.info,  Node: racket-tidy-requires,  Next: racket-trim-requires,  Prev: racket-unfold-all-tests,  Up: Edit

5.1.5 racket-tidy-requires
--------------------------

â€˜M-xâ€™ â€˜racket-tidy-requiresâ€™

   Make a single â€œrequireâ€ form, modules sorted, one per line.

   The scope of this command is the innermost module around point,
including the outermost module for a file using a â€œ#langâ€ line.  All
require forms within that module are combined into a single form.
Within that form:

   â€¢ A single subform is used for each phase level, sorted in this
     order: for-syntax, for-template, for-label, for-meta, and plain
     (phase 0).

        â€¢ Within each level subform, the modules are sorted:

             â€¢ Collection path modules â€“ sorted alphabetically.

             â€¢ Subforms such as only-in.

             â€¢ Quoted relative requires â€“ sorted alphabetically.

   At most one required module is listed per line.

   See also: *note racket-trim-requires:: and *note
racket-base-requires::.


File: racket-mode.info,  Node: racket-trim-requires,  Next: racket-base-requires,  Prev: racket-tidy-requires,  Up: Edit

5.1.6 racket-trim-requires
--------------------------

â€˜M-xâ€™ â€˜racket-trim-requiresâ€™

   Like *note racket-tidy-requires:: but also deletes unnecessary
requires.

   Note: This only works when the source file can be fully expanded with
no errors.

   Note: This only works for requires at the top level of a source file
using #lang.  It does NOT work for require forms inside module forms.
Furthermore, it is not smart about module+ or module* forms â€“ it might
delete top level requires that are actually needed by such submodules.

   See also: *note racket-base-requires::.


File: racket-mode.info,  Node: racket-base-requires,  Next: racket-add-require-for-identifier,  Prev: racket-trim-requires,  Up: Edit

5.1.7 racket-base-requires
--------------------------

â€˜M-xâ€™ â€˜racket-base-requiresâ€™

   Change from â€œ#lang racketâ€ to â€œ#lang racket/baseâ€.

   Adds explicit requires for imports that are provided by â€œracketâ€ but
not by â€œracket/baseâ€.

   This is a recommended optimization for Racket applications.  Avoiding
loading all of â€œracketâ€ can reduce load time and memory footprint.

   Also, as does *note racket-trim-requires::, this removes unneeded
modules and tidies everything into a single, sorted require form.

   Note: This only works when the source file can be fully expanded with
no errors.

   Note: This only works for requires at the top level of a source file
using #lang.  It does NOT work for require forms inside module forms.
Furthermore, it is not smart about module+ or module* forms â€“ it might
delete top level requires that are actually needed by such submodules.

   Note: Currently this only helps change â€œ#lang racketâ€ to â€œ#lang
racket/baseâ€.  It does not help with other similar conversions, such as
changing â€œ#lang typed/racketâ€ to â€œ#lang typed/racket/baseâ€.


File: racket-mode.info,  Node: racket-add-require-for-identifier,  Next: racket-indent-line,  Prev: racket-base-requires,  Up: Edit

5.1.8 racket-add-require-for-identifier
---------------------------------------

â€˜M-xâ€™ â€˜racket-add-require-for-identifierâ€™

   Add a require for the identifier at point.

   When more than one module supplies an identifer with the same name,
they are listed for you to choose one.  The list is sorted
alphabetically, except modules starting with â€œracket/â€ and
â€œtyped/racket/â€ are sorted before others.  While at the prompt, as a
convenience you can press C-h to see the â€œSearch Manualsâ€ page for
locally installed packages â€“ effectively like doing â€œraco docâ€ at the
command line.

   A â€œrequireâ€ form is inserted into the buffer, followed by doing a
*note racket-tidy-requires::.

   Caveat: This works in terms of identifers that are documented.  The
mechanism is similar to that used for Racketâ€™s â€œSearch Manualsâ€ feature.
Today there exists no system-wide database of identifiers that are
exported but not documented.


File: racket-mode.info,  Node: racket-indent-line,  Next: racket-smart-open-bracket-mode,  Prev: racket-add-require-for-identifier,  Up: Edit

5.1.9 racket-indent-line
------------------------

â€˜M-xâ€™ â€˜racket-indent-lineâ€™

   Indent current line as Racket code.

   Normally you donâ€™t need to use this command directly, it is used
automatically when you press keys like RET or TAB. However you might
refer to it when configuring custom indentation, explained below.

   This behaves like â€˜lisp-indent-lineâ€™, except that whole-line comments
are treated the same regardless of whether they start with single or
double semicolons.

   â€¢ Automatically indents forms that start with â€œbeginâ€ in the usual
     way that â€œbeginâ€ is indented.

   â€¢ Automatically indents forms that start with â€œdefâ€ or â€œwith-â€ in the
     usual way that â€œdefineâ€ is indented.

   â€¢ Has rules for many specific standard Racket forms.

   To extend, use your Emacs init file to

     (put SYMBOL 'racket-indent-function INDENT)

   SYMBOL is the name of the Racket form like â€œâ€™test-caseâ€ and INDENT is
an integer or the symbol â€œâ€™defunâ€.  When INDENT is an integer, the
meaning is the same as for lisp-indent-function and
scheme-indent-function: Indent the first INDENT arguments specially and
indent any further arguments like a body.

   For example:

     (put 'test-case 'racket-indent-function 1)

   This will change the indent of â€˜test-caseâ€™ from this:

     (test-case foo
     	   blah
     	   blah)

   to this:

     (test-case foo
       blah
       blah)

   If â€˜racket-indent-functionâ€™ has no property for a symbol,
scheme-indent-function is also considered, although the â€œwith-â€ indents
defined by scheme-mode are ignored.  This is only to help people who may
have extensive scheme-indent-function settings, particularly in the form
of file or dir local variables.  Otherwise prefer putting properties on
â€˜racket-indent-functionâ€™.


File: racket-mode.info,  Node: racket-smart-open-bracket-mode,  Next: racket-insert-closing,  Prev: racket-indent-line,  Up: Edit

5.1.10 racket-smart-open-bracket-mode
-------------------------------------

â€˜M-xâ€™ â€˜racket-smart-open-bracket-modeâ€™

   Minor mode to let you always type â€˜[â€™â€™ to insert â€˜(â€™ or â€˜[â€™
automatically.

   Behaves like the â€œAutomatically adjust opening square bracketsâ€
feature in Dr.  Racket.

   By default, inserts a â€˜(â€™.  Inserts a â€˜[â€™ in the following cases:

   â€¢ â€˜letâ€™-like bindings â€“ forms with â€˜letâ€™ in the name as well as
     things like â€˜parameterizeâ€™, â€˜with-handlersâ€™, and â€˜with-syntaxâ€™.

   â€¢ â€˜caseâ€™, â€˜condâ€™, â€˜matchâ€™, â€˜syntax-caseâ€™, â€˜syntax-parseâ€™, and
     â€˜syntax-rulesâ€™ clauses.

   â€¢ â€˜forâ€™-like bindings and â€˜for/foldâ€™ accumulators.

   â€¢ â€˜classâ€™ declaration syntax, such as â€˜initâ€™ and â€˜inheritâ€™.

   When the previous s-expression in a sequence is a compound
expression, uses the same kind of delimiter.

   To force insert â€˜[â€™, use â€˜quoted-insertâ€™.

   Combined with *note racket-insert-closing:: this means that you can
press the unshifted â€˜[â€™ and â€˜]â€™ keys to get whatever delimiters follow
the Racket conventions for these forms.  When something like
â€˜electric-pair-modeâ€™ or â€˜paredit-modeâ€™ is active, you need not even
press â€˜]â€™.

   Tip: When also using â€˜paredit-modeâ€™, enable that first so that the
binding for the â€˜[â€™â€™ key in the map for *note
racket-smart-open-bracket-mode:: has higher priority.  See also the
variable â€˜minor-mode-map-alistâ€™.


File: racket-mode.info,  Node: racket-insert-closing,  Next: racket-cycle-paren-shapes,  Prev: racket-smart-open-bracket-mode,  Up: Edit

5.1.11 racket-insert-closing
----------------------------

â€˜]â€™ or â€˜)â€™

   Insert a matching closing delimiter.

   With â€˜C-uâ€™ insert the typed character as-is.

   This is handy if youâ€™re not yet using something like â€˜paredit-modeâ€™,
â€˜smartparens-modeâ€™, â€˜parinfer-modeâ€™, or simply â€˜electric-pair-modeâ€™
added in Emacs 24.5.


File: racket-mode.info,  Node: racket-cycle-paren-shapes,  Next: racket-backward-up-list,  Prev: racket-insert-closing,  Up: Edit

5.1.12 racket-cycle-paren-shapes
--------------------------------

â€˜C-c C-pâ€™

   Cycle the sexpr among () [] {}.


File: racket-mode.info,  Node: racket-backward-up-list,  Next: racket-unicode-input-method-enable,  Prev: racket-cycle-paren-shapes,  Up: Edit

5.1.13 racket-backward-up-list
------------------------------

â€˜C-M-uâ€™

   Like â€˜backward-up-listâ€™ but works when point is in a string or
comment.

   Typically you should not use this command in Emacs Lisp â€“ especially
not repeatedly.  Instead, initially use
â€˜racket--escape-string-or-commentâ€™ to move to the start of a string or
comment, if any, then use normal â€˜backward-up-listâ€™ repeatedly.


File: racket-mode.info,  Node: racket-unicode-input-method-enable,  Next: racket-align,  Prev: racket-backward-up-list,  Up: Edit

5.1.14 racket-unicode-input-method-enable
-----------------------------------------

â€˜M-xâ€™ â€˜racket-unicode-input-method-enableâ€™

   Set input method to racket-unicode.

   The racket-unicode input method lets you easily type various Unicode
symbols that might be useful when writing Racket code.

   To automatically enable the racket-unicode input method in
racket-mode and racket-repl-mode buffers, put the following code in your
Emacs init file:

     (add-hook 'racket-mode-hook #'racket-unicode-input-method-enable)
     (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)

   To temporarily enable this input method for a single buffer you can
use â€œM-x racket-unicode-input-method-enableâ€.

   Use the standard Emacs key C-\ to toggle the input method.

   When the racket-unicode input method is active, you can for example
type â€œAllâ€ and it is immediately replaced with â€œâˆ€â€.  A few other
examples:

omega       Ï‰
x_1         xâ‚
x^1         xÂ¹
A           ğ”¸
testâ€“>>E    testâ€“>>âˆƒ (racket/redex)
vdash       âŠ¢

   To see a table of all key sequences use â€œM-x describe-input-method
<RET> racket-unicodeâ€.

   If you want to add your own mappings to the â€œracket-unicodeâ€ input
method, you may add code like the following example in your Emacs init
file:

     ;; Either (require 'racket-mode) here, or, if you use
     ;; use-package, put the code below in the :config section.
     (with-temp-buffer
       (racket-unicode-input-method-enable)
       (set-input-method "racket-unicode")
       (let ((quail-current-package (assoc "racket-unicode"
     				      quail-package-alist)))
         (quail-define-rules ((append . t))
     			("^o" ["áµ’"]))))

   If you donâ€™t like the highlighting of partially matching tokens you
can turn it off by setting â€˜input-method-highlight-flagâ€™ to nil.


File: racket-mode.info,  Node: racket-align,  Next: racket-unalign,  Prev: racket-unicode-input-method-enable,  Up: Edit

5.1.15 racket-align
-------------------

â€˜M-xâ€™ â€˜racket-alignâ€™

   Align values in the same column.

   Useful for binding forms like â€œletâ€ and â€œparameterizeâ€, conditionals
like â€œcondâ€ and â€œmatchâ€, association lists, and any series of couples
like the arguments to â€œhashâ€.

   Before choosing this command, put point on the first of a series of
â€œcouplesâ€.  A couple is:

   â€¢ A list of two or more sexprs: "[sexpr val sexpr ...]".
   â€¢ Two sexprs: â€œsexpr valâ€.

   Each â€œvalâ€ moves to the same column and is â€˜prog-indent-sexpâ€™-ed (in
case it is a multi-line form).

   For example with point on the "[" before â€œaâ€:

     Before             After

     (let ([a 12]       (let ([a   12]
           [bar 23])          [bar 23])
       ....)              ....)

     '([a . 12]         '([a   . 12]
       [bar . 23])        [bar . 23])

     (cond [a? #t]      (cond [a?   #t]
           [b? (f x           [b?   (f x
     	     y)]                  y)]
           [else #f])         [else #f])

   Or with point on the quote before â€œaâ€:

     (list 'a 12        (list 'a   12
           'bar 23)           'bar 23)

   If more than one couple is on the same line, none are aligned,
because it is unclear where the value column should be.  For example the
following form will not change; *note racket-align:: will display an
error message:

     (let ([a 0][b 1]
           [c 2])       error; unchanged
       ....)

   When a coupleâ€™s sexprs start on different lines, that couple is
ignored.  Other, single-line couples in the series are aligned as usual.
For example:

     (let ([foo         (let ([foo
            0]                 0]
           [bar 1]            [bar 1]
           [x 2])             [x   2])
       ....)              ....)

   See also: *note racket-unalign::.


File: racket-mode.info,  Node: racket-unalign,  Next: racket-complete-at-point,  Prev: racket-align,  Up: Edit

5.1.16 racket-unalign
---------------------

â€˜M-xâ€™ â€˜racket-unalignâ€™

   The opposite of *note racket-align::.

   Effectively does M-x â€˜just-one-spaceâ€™ and â€˜prog-indent-sexpâ€™ for each
coupleâ€™s value.


File: racket-mode.info,  Node: racket-complete-at-point,  Prev: racket-unalign,  Up: Edit

5.1.17 racket-complete-at-point
-------------------------------

A value for the variable â€˜completion-at-point-functionsâ€™.

   Completion candidates are drawn from the same symbols used for
font-lock.  This is a static list.  If you want dynamic, smarter
completion candidates, enable the minor mode *note racket-xp-mode::.


File: racket-mode.info,  Node: Explore,  Next: Run,  Prev: Edit,  Up: Commands

5.2 Explore
===========

* Menu:

* racket-xp-mode::
* racket-xp-describe::
* racket-xp-documentation::
* racket-xp-next-definition::
* racket-xp-previous-definition::
* racket-xp-next-use::
* racket-xp-previous-use::
* racket-xp-next-error::
* racket-xp-previous-error::
* racket-xp-tail-up::
* racket-xp-tail-down::
* racket-xp-tail-next-sibling::
* racket-xp-tail-previous-sibling::
* racket-documentation-search::


File: racket-mode.info,  Node: racket-xp-mode,  Next: racket-xp-describe,  Up: Explore

5.2.1 racket-xp-mode
--------------------

â€˜M-xâ€™ â€˜racket-xp-modeâ€™

   A minor mode that analyzes expanded code to explain and explore.

   This minor mode is an optional enhancement to *note racket-mode::
edit buffers.  Like any minor mode, you can turn it on or off for a
specific buffer.  If you always want to use it, put the following code
in your Emacs init file:

     (require 'racket-xp)
     (add-hook 'racket-mode-hook #'racket-xp-mode)

   Note: This mode wonâ€™t do anything unless/until the Racket Mode back
end is running.  It will try to start the back end automatically.  You
do _not_ need to *note racket-run:: the buffer you are editing.

   This mode uses the drracket/check-syntax package to analyze
fully-expanded programs, without needing to evaluate a.k.a.  â€œrunâ€ them.
The resulting analysis provides information for:

   â€¢ Visually annotating bindings â€“ local or imported definitions and
     references to them.

   â€¢ Visually annotating expressions in a tail position, as well as the
     enclosing expression with respect to which they are in a tail
     position.

   â€¢ Completion candidates.

   â€¢ Defintionsâ€™ source and documentation.

   When point is on a definition or use, related items are highlighted
using *note racket-xp-def-face:: and *note racket-xp-use-face:: â€“
instead of drawing arrows as in Dr Racket.  Information is displayed
using the function(s) in the hook variable *note
racket-show-functions::; it is also available when hovering the mouse
cursor.

   Note: If you find these point-motion features too distracting and/or
slow, in your â€˜racket-xp-mode-hookâ€™ you may disable them:

     (require 'racket-xp)
     (add-hook 'racket-xp-mode-hook
     	  (lambda ()
     	    (remove-hook 'pre-redisplay-functions
     			 #'racket-xp-pre-redisplay
     			 t)))

   The remaining features discussed below will still work.

   You may also use commands to navigate among a definition and its
uses, or to rename a local definitions and all its uses:

   â€¢ *note racket-xp-next-definition::
   â€¢ *note racket-xp-previous-definition::
   â€¢ *note racket-xp-next-use::
   â€¢ *note racket-xp-previous-use::

   In the following little example, not only does drracket/check-syntax
distinguish the various â€œxâ€ bindings, it understands the two different
imports of â€œdefineâ€:

     #lang racket/base
     (define x 1)
     x
     (let ([x x])
       (+ x 1))
     (module m typed/racket/base
       (define x 2)
       x)

   When point is on the opening parenthesis of an expression in tail
position, it is highlighted using the face *note
racket-xp-tail-position-face::.

   When point is on the opening parenthesis of an enclosing expression
with respect to which one or more expressions are in tail position, it
is highlighted using the face *note racket-xp-tail-target-face::.

   Furthermore, when point is on the opening parenthesis of either kind
of expression, all of the immediately related expressions are also
highlighted.  Various commands move among them:

   â€¢ *note racket-xp-tail-up::
   â€¢ *note racket-xp-tail-down::
   â€¢ *note racket-xp-tail-next-sibling::
   â€¢ *note racket-xp-tail-previous-sibling::

   The function â€˜racket-xp-complete-at-pointâ€™ is added to the variable
â€˜completion-at-point-functionsâ€™.  Note that in this case, it is not
smart about submodules; identifiers are assumed to be definitions from
the fileâ€™s module or its imports.  In addition to supplying completion
candidates, it supports the â€œ:company-locationâ€ property to inspect the
definition of a candidate and the â€œ:company-doc-bufferâ€ property to view
its documentation.

   When you edit the buffer, existing annotations are retained; their
positions are updated to reflect the edit.  Annotations for new or
deleted text are not requested until after *note
racket-xp-after-change-refresh-delay:: seconds.  The request is made
asynchronously so that Emacs will not block â€“ for moderately complex
source files, it can take some seconds simply to fully expand them, as
well as a little more time for the drracket/check-syntax analysis.  When
the results are ready, all annotations for the buffer are completely
refreshed.

   You may also set *note racket-xp-after-change-refresh-delay:: to nil
and use the â€˜racket-xp-annotateâ€™ command manually.

   The mode line changes to reflect the current status of annotations,
and whether or not you had a syntax error.

   If you have one or more syntax errors, *note racket-xp-next-error::
and *note racket-xp-previous-error:: navigate among them.  Although most
languages will stop after the first syntax error, some like Typed Racket
will try to collect and report multiple errors.

   You may use â€˜xref-find-definitionsâ€™ â€˜M-.â€™ , â€˜xref-pop-marker-stackâ€™
â€˜M-,â€™ , and â€˜xref-find-referencesâ€™: *note racket-xp-mode:: adds a
backend to the variable â€˜xref-backend-functionsâ€™.  This backend uses
information from the drracket/check-syntax static analysis.  Its ability
to find references is limited to the current file; when it finds none it
will try the default xref backend implementation which is grep-based.

   Tip: This mode follows the convention that a minor mode may only use
a prefix key consisting of â€œC-câ€ followed by a punctuation key.  As a
result, â€˜racket-xp-control-c-hash-keymapâ€™ is bound to â€œC-c #â€ by
default.  Although you might find this awkward to type, remember that as
an Emacs user, you are free to bind this map to a more convenient
prefix, and/or bind any individual commands directly to whatever keys
you prefer.

Key                                                     Binding
â€˜M-.â€™                                                   â€˜xref-find-definitionsâ€™
â€˜C-c C-dâ€™                                               *note racket-xp-documentation::
â€˜C-c C-.â€™                                               *note racket-xp-describe::
â€˜C-c # Pâ€™                                               *note racket-xp-previous-error::
â€˜C-c # Nâ€™                                               *note racket-xp-next-error::
â€˜C-c # gâ€™                                               â€˜racket-xp-annotateâ€™
â€˜C-c # <â€™                                               *note racket-xp-tail-previous-sibling::
â€˜C-c # >â€™                                               *note racket-xp-tail-next-sibling::
â€˜C-c # vâ€™                                               *note racket-xp-tail-down::
â€˜C-c # ^â€™                                               *note racket-xp-tail-up::
â€˜C-c # râ€™                                               â€˜racket-xp-renameâ€™
â€˜C-c # ?â€™                                               â€˜xref-find-referencesâ€™
â€˜C-c # .â€™                                               â€˜xref-find-definitionsâ€™
â€˜C-c # pâ€™                                               *note racket-xp-previous-use::
â€˜C-c # nâ€™                                               *note racket-xp-next-use::
â€˜C-c # kâ€™                                               *note racket-xp-previous-definition::
â€˜C-c # jâ€™                                               *note racket-xp-next-definition::


File: racket-mode.info,  Node: racket-xp-describe,  Next: racket-xp-documentation,  Prev: racket-xp-mode,  Up: Explore

5.2.2 racket-xp-describe
------------------------

â€˜C-c C-.â€™

   Describe the identifier at point in a â€˜*Racket Describe*â€™ buffer.

   With â€˜C-uâ€™ you are prompted enter the identifier, but in this case it
only considers definitions or imports at the fileâ€™s module level â€“ not
local bindings nor definitions in submodules.

   The intent is to give a quick reminder or introduction to something,
regardless of whether it has installed documentation â€“ and to do so
within Emacs, without switching to a web browser.

   This buffer is also displayed when you use â€˜company-modeâ€™ and press
F1 or C-h in its pop up completion list.

   â€¢ If the identifier has installed Racket documentation, then a
     simplified version of the HTML is presented in the buffer,
     including the â€œblue boxâ€, documentation prose, and examples.

   â€¢ Otherwise, if the identifier is a function, then its signature is
     displayed, for example "(name arg-1-name arg-2-name)".

   You can quit the buffer by pressing q.  Also, at the bottom of the
buffer are Emacs buttons â€“ which you may navigate among using TAB, and
activate using RET â€“ for â€˜xref-find-definitionsâ€™ and *note
racket-xp-documentation::.


File: racket-mode.info,  Node: racket-xp-documentation,  Next: racket-xp-next-definition,  Prev: racket-xp-describe,  Up: Explore

5.2.3 racket-xp-documentation
-----------------------------

â€˜C-c C-dâ€™

   View documentation in an external web browser.

   The command varies based on how many â€˜C-uâ€™ command prefixes you
supply.

  1. None.

     Uses the symbol at point.  Tries to find documentation for an
     identifer defined in the expansion of the current buffer.

     If no such identifer exists, opens the Search Manuals page.  In
     this case, the variable *note
     racket-documentation-search-location:: determines whether the
     search is done locally as with â€˜raco docâ€˜, or visits a URL.

  2. â€˜C-uâ€™

     Prompts you to enter a symbol, defaulting to the symbol at point if
     any.

     Otherwise behaves like 1.

  3. â€˜C-uâ€™ â€˜C-uâ€™

     Prompts you to enter anything, defaulting to the symbol at point if
     any.

     Proceeds directly to the Search Manuals page.  Use this if you
     would like to see documentation for all identifiers named â€œdefineâ€,
     for example.


File: racket-mode.info,  Node: racket-xp-next-definition,  Next: racket-xp-previous-definition,  Prev: racket-xp-documentation,  Up: Explore

5.2.4 racket-xp-next-definition
-------------------------------

â€˜C-c # jâ€™

   Move point to the next definition.


File: racket-mode.info,  Node: racket-xp-previous-definition,  Next: racket-xp-next-use,  Prev: racket-xp-next-definition,  Up: Explore

5.2.5 racket-xp-previous-definition
-----------------------------------

â€˜C-c # kâ€™

   Move point to the previous definition.


File: racket-mode.info,  Node: racket-xp-next-use,  Next: racket-xp-previous-use,  Prev: racket-xp-previous-definition,  Up: Explore

5.2.6 racket-xp-next-use
------------------------

â€˜C-c # nâ€™

   When point is on a use, go to the next, sibling use.


File: racket-mode.info,  Node: racket-xp-previous-use,  Next: racket-xp-next-error,  Prev: racket-xp-next-use,  Up: Explore

5.2.7 racket-xp-previous-use
----------------------------

â€˜C-c # pâ€™

   When point is on a use, go to the previous, sibling use.


File: racket-mode.info,  Node: racket-xp-next-error,  Next: racket-xp-previous-error,  Prev: racket-xp-previous-use,  Up: Explore

5.2.8 racket-xp-next-error
--------------------------

â€˜C-c # Nâ€™

   Go to the next error.


File: racket-mode.info,  Node: racket-xp-previous-error,  Next: racket-xp-tail-up,  Prev: racket-xp-next-error,  Up: Explore

5.2.9 racket-xp-previous-error
------------------------------

â€˜C-c # Pâ€™

   Go to the previous error.


File: racket-mode.info,  Node: racket-xp-tail-up,  Next: racket-xp-tail-down,  Prev: racket-xp-previous-error,  Up: Explore

5.2.10 racket-xp-tail-up
------------------------

â€˜C-c # ^â€™

   Go â€œupâ€ to the expression enclosing an expression in tail position.

   When point is on the opening parenthesis of an expression in tail
position, go its â€œtargetâ€ â€“ that is, go to the enclosing expression with
the same continuation as the tail expression.


File: racket-mode.info,  Node: racket-xp-tail-down,  Next: racket-xp-tail-next-sibling,  Prev: racket-xp-tail-up,  Up: Explore

5.2.11 racket-xp-tail-down
--------------------------

â€˜C-c # vâ€™

   Go â€œdownâ€ to the first tail position enclosed by the current
expression.


File: racket-mode.info,  Node: racket-xp-tail-next-sibling,  Next: racket-xp-tail-previous-sibling,  Prev: racket-xp-tail-down,  Up: Explore

5.2.12 racket-xp-tail-next-sibling
----------------------------------

â€˜C-c # >â€™

   Go to the next tail position sharing the same enclosing expression.


File: racket-mode.info,  Node: racket-xp-tail-previous-sibling,  Next: racket-documentation-search,  Prev: racket-xp-tail-next-sibling,  Up: Explore

5.2.13 racket-xp-tail-previous-sibling
--------------------------------------

â€˜C-c # <â€™

   Go to the previous tail position sharing the same enclosing
expression.


File: racket-mode.info,  Node: racket-documentation-search,  Prev: racket-xp-tail-previous-sibling,  Up: Explore

5.2.14 racket-documentation-search
----------------------------------

â€˜C-c C-dâ€™

   Search documentation.

   This command is useful in several situations:

   â€¢ You are not using *note racket-xp-mode:: for a *note racket-mode::
     edit buffer, so *note racket-xp-documentation:: is not available.

   â€¢ There is no *note racket-repl-mode:: buffer with a live namespace,
     so *note racket-repl-documentation:: is not available or helpful.

   â€¢ You want to search for definitions provided by all modules â€“ for
     example, the â€œdefineâ€ syntax provided by racket/base, by
     typed/racket/base, and by other modules, as well definitions or
     topics that merely include â€œdefineâ€.

   This command does not try to go directly to the help topic for a
definition provided by any specific module.  Instead it goes to the
Racket â€œSearch Manualsâ€ page.


File: racket-mode.info,  Node: Run,  Next: Test,  Prev: Explore,  Up: Commands

5.3 Run
=======

* Menu:

* racket-repl-mode::
* racket-run::
* racket-run-and-switch-to-repl::
* racket-run-module-at-point::
* racket-repl::
* racket-repl-describe::
* racket-repl-documentation::
* racket-racket::
* racket-profile::
* racket-profile-mode::
* racket-logger::
* racket-logger-mode::
* racket-debug-mode::
* racket-repl-clear::
* racket-repl-clear-leaving-last-prompt::


File: racket-mode.info,  Node: racket-repl-mode,  Next: racket-run,  Up: Run

5.3.1 racket-repl-mode
----------------------

â€˜M-xâ€™ â€˜racket-repl-modeâ€™

   Major mode for Racket REPL.

   You may use â€˜xref-find-definitionsâ€™ â€˜M-.â€™ and â€˜xref-pop-marker-stackâ€™
â€˜M-,â€™ : *note racket-repl-mode:: adds a backend to the variable
â€˜xref-backend-functionsâ€™.  This backend uses information about
identifier bindings and modules from the REPLâ€™s namespace.

Key                                                         Binding
â€˜}â€™                                                         *note racket-insert-closing::
â€˜]â€™                                                         *note racket-insert-closing::
â€˜)â€™                                                         *note racket-insert-closing::
â€˜C-c C-\â€™                                                   â€˜racket-repl-exitâ€™
â€˜C-c C-câ€™                                                   â€˜racket-repl-breakâ€™
â€˜C-c C-lâ€™                                                   *note racket-logger::
â€˜C-c C-zâ€™                                                   â€˜racket-repl-switch-to-editâ€™
â€˜C-c C-.â€™                                                   *note racket-repl-describe::
â€˜C-c C-dâ€™                                                   *note racket-repl-documentation::
â€˜C-c C-e râ€™                                                 *note racket-expand-region::
â€˜C-c C-e eâ€™                                                 *note racket-expand-last-sexp::
â€˜C-c C-e xâ€™                                                 *note racket-expand-definition::
â€˜C-c C-e fâ€™                                                 *note racket-expand-file::
â€˜C-wâ€™                                                       â€˜comint-kill-regionâ€™
â€˜C-aâ€™                                                       â€˜comint-bolâ€™
â€˜C-M-yâ€™                                                     *note racket-insert-lambda::
â€˜C-M-qâ€™                                                     â€˜prog-indent-sexpâ€™
â€˜C-M-uâ€™                                                     *note racket-backward-up-list::
â€˜TABâ€™                                                       â€˜indent-for-tab-commandâ€™
â€˜C-jâ€™                                                       â€˜newline-and-indentâ€™
â€˜RETâ€™                                                       â€˜racket-repl-submitâ€™

   In addition to any hooks its parent mode â€˜comint-modeâ€™ might have
run, this mode runs the hook â€˜racket-repl-mode-hookâ€™, as the final step
during initialization.


File: racket-mode.info,  Node: racket-run,  Next: racket-run-and-switch-to-repl,  Prev: racket-repl-mode,  Up: Run

5.3.2 racket-run
----------------

â€˜M-xâ€™ â€˜racket-runâ€™

   Save the buffer in REPL and run your program.

   As well as evaluating the outermost, file module, automatically runs
the submodules specified by the customization variable *note
racket-submodules-to-run::.

   See also *note racket-run-module-at-point::, which runs just the
specific module at point.

   With â€˜C-uâ€™ uses errortrace for improved stack traces.  Otherwise
follows the *note racket-error-context:: setting.

   With â€˜C-uâ€™ â€˜C-uâ€™ instruments code for step debugging.  See *note
racket-debug-mode:: and the variable *note racket-debuggable-files::.

   Each run occurs within a Racket custodian.  Any prior runâ€™s custodian
is shut down, releasing resources like threads and ports.  Each runâ€™s
evaluation environment is reset to the contents of the source file.  In
other words, like Dr Racket, this provides the benefit that your source
file is the â€œsingle source of truthâ€.  At the same time, the run gives
you a REPL inside the namespace of the module, giving you the ability to
explore it interactively.  Any explorations are temporary, unless you
also make them to your source file, they will be lost on the next run.

   See also *note racket-run-and-switch-to-repl::, which is even more
like Dr Racketâ€™s Run command because it selects the REPL window after
running.

   In the *note racket-repl-mode:: buffer, output that describes a file
and position is automatically â€œlinkifiedâ€.  Examples of such text
include:

   â€¢ Racket error messages.
   â€¢ rackunit test failure location messages.
   â€¢ print representation of path objects.

   To visit these locations, move point there and press RET or mouse
click.  Or, use the standard â€˜next-errorâ€™ and â€˜previous-errorâ€™ commands.


File: racket-mode.info,  Node: racket-run-and-switch-to-repl,  Next: racket-run-module-at-point,  Prev: racket-run,  Up: Run

5.3.3 racket-run-and-switch-to-repl
-----------------------------------

â€˜<f5>â€™

   This is *note racket-run:: followed by selecting the REPL buffer
window.

   This is similar to how Dr Racket behaves.

   To make it even more similar, you may add *note racket-repl-clear::
to the variable *note racket-before-run-hook::.


File: racket-mode.info,  Node: racket-run-module-at-point,  Next: racket-repl,  Prev: racket-run-and-switch-to-repl,  Up: Run

5.3.4 racket-run-module-at-point
--------------------------------

â€˜C-c C-kâ€™ or â€˜C-c C-câ€™

   Save the buffer and run the module at point.

   Like *note racket-run:: but runs the innermost module around point,
which is determined textually by looking for â€œmoduleâ€, â€œmodule*â€, or
â€œmodule+â€ forms nested to any depth, else simply the outermost, file
module.


File: racket-mode.info,  Node: racket-repl,  Next: racket-repl-describe,  Prev: racket-run-module-at-point,  Up: Run

5.3.5 racket-repl
-----------------

â€˜C-c C-zâ€™

   Show a Racket REPL buffer in some window.

   *IMPORTANT*

   The main, intended use of Racket Modeâ€™s REPL is that you â€˜find-fileâ€™
some specific .rkt file, then *note racket-run:: it.  The REPL will then
match that file.

   If the REPL isnâ€™t running, and you want to start it for no file in
particular?  Then you could use this command.  But the resulting REPL
will have a minimal â€œ#lang racket/baseâ€ namespace.  You could enter
"(require racket)" if you want the equivalent of â€œ#lang racketâ€.  You
could also "(require racket/enter)" if you want things like â€œenter!â€.
But in some sense youâ€™d be â€œusing it wrongâ€.  If you really donâ€™t want
to use Racket Modeâ€™s REPL as intended, then you might as well use a
plain Emacs shell buffer to run command-line Racket.


File: racket-mode.info,  Node: racket-repl-describe,  Next: racket-repl-documentation,  Prev: racket-repl,  Up: Run

5.3.6 racket-repl-describe
--------------------------

â€˜C-c C-.â€™

   Describe the identifier at point in a â€˜*Racket Describe*â€™ buffer.

   The intent is to give a quick reminder or introduction to something,
regardless of whether it has installed documentation â€“ and to do so
within Emacs, without switching to a web browser.

   This buffer is also displayed when you use â€˜company-modeâ€™ and press
F1 or C-h in its pop up completion list.

   â€¢ If the identifier has installed Racket documentation, then a
     simplified version of the HTML is presented in the buffer,
     including the â€œblue boxâ€, documentation prose, and examples.

   â€¢ Otherwise, if the identifier is a function, then its signature is
     displayed, for example â€˜(name arg-1-name arg-2-name)â€™.  If it has a
     contract or a Typed Racket type, that is also displayed.

   You can quit the buffer by pressing q.  Also, at the bottom of the
buffer are Emacs buttons â€“ which you may navigate among using TAB, and
activate using RET â€“ for â€˜racket-repl-visit-definitionâ€™ and *note
racket-repl-documentation::.


File: racket-mode.info,  Node: racket-repl-documentation,  Next: racket-racket,  Prev: racket-repl-describe,  Up: Run

5.3.7 racket-repl-documentation
-------------------------------

â€˜C-c C-dâ€™

   View documentation in an external web browser.

   The command varies based on how many â€˜C-uâ€™ command prefixes you
supply.

  1. None.

     Uses the symbol at point.  Tries to find documentation for an
     identifer defined in the current namespace.

     If no such identifer exists, opens the Search Manuals page.  In
     this case, the variable *note
     racket-documentation-search-location:: determines whether the
     search is done locally as with â€˜raco docâ€˜, or visits a URL.

  2. â€˜C-uâ€™

     Prompts you to enter a symbol, defaulting to the symbol at point if
     any.

     Otherwise behaves like 1.

  3. â€˜C-uâ€™ â€˜C-uâ€™

     Prompts you to enter anything, defaulting to the symbol at point if
     any.

     Proceeds directly to the Search Manuals page.  Use this if you
     would like to see documentation for all identifiers named â€œdefineâ€,
     for example.


File: racket-mode.info,  Node: racket-racket,  Next: racket-profile,  Prev: racket-repl-documentation,  Up: Run

5.3.8 racket-racket
-------------------

â€˜<C-M-f5>â€™

   Do â€œracket <file>â€ in a shell buffer.


File: racket-mode.info,  Node: racket-profile,  Next: racket-profile-mode,  Prev: racket-racket,  Up: Run

5.3.9 racket-profile
--------------------

â€˜C-c C-oâ€™

   Like *note racket-run-module-at-point:: but with profiling.

   Results are presented in a *note racket-profile-mode:: buffer, which
also lets you quickly view the source code.

   You may evaluate expressions in the REPL. They are also profiled.
Use â€˜racket-profile-refreshâ€™ to see the updated results.  In other words
a possible workflow is: *note racket-profile:: a .rkt file, call one its
functions in the REPL, and refresh the profile results.

   Caveat: Only source files are instrumented.  You may need to delete
compiled/*.zo files.


File: racket-mode.info,  Node: racket-profile-mode,  Next: racket-logger,  Prev: racket-profile,  Up: Run

5.3.10 racket-profile-mode
--------------------------

â€˜M-xâ€™ â€˜racket-profile-modeâ€™

   Major mode for results of *note racket-profile::.

Key                                         Binding
â€˜,â€™                                         â€˜racket-profile-sortâ€™
â€˜fâ€™                                         â€˜racket-profile-show-non-projectâ€™
â€˜zâ€™                                         â€˜racket-profile-show-zeroâ€™
â€˜pâ€™                                         â€˜racket-profile-prevâ€™
â€˜nâ€™                                         â€˜racket-profile-nextâ€™
â€˜gâ€™                                         â€˜racket-profile-refreshâ€™
â€˜qâ€™                                         â€˜quit-windowâ€™

   In addition to any hooks its parent mode â€˜special-modeâ€™ might have
run, this mode runs the hook â€˜racket-profile-mode-hookâ€™, as the final
step during initialization.


File: racket-mode.info,  Node: racket-logger,  Next: racket-logger-mode,  Prev: racket-profile-mode,  Up: Run

5.3.11 racket-logger
--------------------

â€˜C-c C-lâ€™

   Create the *note racket-logger-mode:: buffer.


File: racket-mode.info,  Node: racket-logger-mode,  Next: racket-debug-mode,  Prev: racket-logger,  Up: Run

5.3.12 racket-logger-mode
-------------------------

â€˜M-xâ€™ â€˜racket-logger-modeâ€™

   Major mode for Racket logger output.

   The customization variable *note racket-logger-config:: determines
the levels for topics.  During a session you may change topic levels
using â€˜racket-logger-topic-levelâ€™.

   For more information see:
<https://docs.racket-lang.org/reference/logging.html>

Key                                         Binding
â€˜gâ€™                                         â€˜racket-logger-clearâ€™
â€˜pâ€™                                         â€˜racket-logger-previous-itemâ€™
â€˜nâ€™                                         â€˜racket-logger-next-itemâ€™
â€˜wâ€™                                         â€˜toggle-truncate-linesâ€™
â€˜lâ€™                                         â€˜racket-logger-topic-levelâ€™

   In addition to any hooks its parent mode â€˜special-modeâ€™ might have
run, this mode runs the hook â€˜racket-logger-mode-hookâ€™, as the final
step during initialization.


File: racket-mode.info,  Node: racket-debug-mode,  Next: racket-repl-clear,  Prev: racket-logger-mode,  Up: Run

5.3.13 racket-debug-mode
------------------------

â€˜M-xâ€™ â€˜racket-debug-modeâ€™

   Minor mode for debug breaks.

   This feature is **EXPERIMENTAL**!!! It is likely to have significant
limitations and bugs.  You are welcome to open an issue to provide
feedback.  Please understand that this feature might never be improved â€“
it might even be removed someday if it turns out to have too little
value and/or too much cost.

   How to debug:

  1. â€œInstrumentâ€ code for step debugging.  You can instrument entire
     files, and also individual functions.

     a.  Entire Files

     Use two â€˜C-uâ€™ command prefixes for either *note racket-run:: or
     *note racket-run-module-at-point::.

     The file will be instrumented for step debugging before it is run.
     Also instrumented are files determined by the variable *note
     racket-debuggable-files::.

     The run will break at the first breakable position.

     Tip: After you run to completion and return to a normal REPL
     prompt, the code remains instrumented.  You may enter expressions
     that evaluate instrumented code and it will break so you can step
     debug again.

     b.  Function Definitions

     Move point inside a function definition form and use â€˜C-uâ€™ â€˜C-M-xâ€™
     to â€œinstrumentâ€ the function for step debugging.  Then in the REPL,
     enter an expression that causes the instrumented function to be
     run, directly or indirectly.

     You can instrument any number of functions.

     You can even instrument while stopped at a break.  For example, to
     instrument a function you are about to call, so you can â€œstep intoâ€
     it:

        â€¢ â€˜M-xâ€™ â€˜racket-xp-visit-definitionâ€™ to visit the definition.
        â€¢ â€˜C-uâ€™ â€˜C-M-xâ€™ to instrument the definition.
        â€¢ â€˜M-xâ€™ â€˜racket-unvisitâ€™ to return.
        â€¢ Continue stepping.
     Limitation: Instrumenting a function required from another module
     wonâ€™t redefine that function.  Instead, it attempts to define an
     instrumented function of the same name, in the module the REPL is
     inside.  The define will fail if it needs definitions visible only
     in that other module.  In that case youâ€™ll probably need to use
     entire-file instrumentation as described above.

  2. When a break occurs, the *note racket-repl-mode:: prompt changes.
     In this debug REPL, local variables are available for you to use
     and even to â€˜set!â€™.

     Also, in the *note racket-mode:: buffer where the break is located,
     *note racket-debug-mode:: is enabled.  This minor mode makes the
     buffer read-only, provides visual feedback â€“ about the break
     position, local variable values, and result values â€“ and provides
     shortcut keys:

Key                                             Binding
â€˜?â€™                                             â€˜racket-debug-helpâ€™
â€˜hâ€™                                             â€˜racket-debug-run-to-hereâ€™
â€˜pâ€™                                             â€˜racket-debug-prev-breakableâ€™
â€˜nâ€™                                             â€˜racket-debug-next-breakableâ€™
â€˜câ€™                                             â€˜racket-debug-continueâ€™
â€˜uâ€™                                             â€˜racket-debug-step-outâ€™
â€˜oâ€™                                             â€˜racket-debug-step-overâ€™
â€˜SPCâ€™                                           â€˜racket-debug-stepâ€™


File: racket-mode.info,  Node: racket-repl-clear,  Next: racket-repl-clear-leaving-last-prompt,  Prev: racket-debug-mode,  Up: Run

5.3.14 racket-repl-clear
------------------------

Delete all text in the REPL.

   A suitable value for the hook *note racket-before-run-hook:: if you
want the REPL buffer to be cleared before each run, much like with Dr
Racket.  To do so you can use â€˜customizeâ€™, or, add to your Emacs init
file something like:

   (add-hook â€˜racket-before-run-hook #â€™racket-repl-clear)

   See also the command *note racket-repl-clear-leaving-last-prompt::.


File: racket-mode.info,  Node: racket-repl-clear-leaving-last-prompt,  Prev: racket-repl-clear,  Up: Run

5.3.15 racket-repl-clear-leaving-last-prompt
--------------------------------------------

â€˜M-xâ€™ â€˜racket-repl-clear-leaving-last-promptâ€™

   Delete all text in the REPL, except for the last prompt.


File: racket-mode.info,  Node: Test,  Next: Eval,  Prev: Run,  Up: Commands

5.4 Test
========

* Menu:

* racket-test::
* racket-raco-test::


File: racket-mode.info,  Node: racket-test,  Next: racket-raco-test,  Up: Test

5.4.1 racket-test
-----------------

â€˜<C-f5>â€™ or â€˜C-c C-tâ€™

   Run the â€œtestâ€ submodule.

   Put your tests in a â€œtestâ€ submodule.  For example:

     (module+ test
       (require rackunit)
       (check-true #t))

   Any rackunit test failure messages show the location.  You may use
â€˜next-errorâ€™ to jump to the location of each failing test.

   With â€˜C-uâ€™ also runs the tests with coverage instrumentation and
highlights uncovered code using â€˜font-lock-warning-faceâ€™.

   See also:
   â€¢ *note racket-fold-all-tests::
   â€¢ *note racket-unfold-all-tests::


File: racket-mode.info,  Node: racket-raco-test,  Prev: racket-test,  Up: Test

5.4.2 racket-raco-test
----------------------

â€˜M-xâ€™ â€˜racket-raco-testâ€™

   Do â€œraco test -x <file>â€ in a shell buffer to run the â€œtestâ€
submodule.


File: racket-mode.info,  Node: Eval,  Next: Collections,  Prev: Test,  Up: Commands

5.5 Eval
========

* Menu:

* racket-send-region::
* racket-send-definition::
* racket-send-last-sexp::


File: racket-mode.info,  Node: racket-send-region,  Next: racket-send-definition,  Up: Eval

5.5.1 racket-send-region
------------------------

â€˜C-c C-râ€™

   Send the current region (if any) to the Racket REPL.


File: racket-mode.info,  Node: racket-send-definition,  Next: racket-send-last-sexp,  Prev: racket-send-region,  Up: Eval

5.5.2 racket-send-definition
----------------------------

â€˜C-M-xâ€™

   Send the current definition to the Racket REPL.


File: racket-mode.info,  Node: racket-send-last-sexp,  Prev: racket-send-definition,  Up: Eval

5.5.3 racket-send-last-sexp
---------------------------

â€˜C-x C-eâ€™

   Send the previous sexp to the Racket REPL.

   When the previous sexp is a sexp comment the sexp itself is sent,
without the #; prefix.


File: racket-mode.info,  Node: Collections,  Next: Macro expand,  Prev: Eval,  Up: Commands

5.6 Collections
===============

* Menu:

* racket-open-require-path::
* racket-find-collection::


File: racket-mode.info,  Node: racket-open-require-path,  Next: racket-find-collection,  Up: Collections

5.6.1 racket-open-require-path
------------------------------

â€˜C-c C-x C-fâ€™

   Like Dr Racketâ€™s Open Require Path.

   Type (or delete) characters that are part of a module path name.
â€œFuzzyâ€ matches appear.  For example try typing â€œt/t/râ€.

   Choices are displayed in a vertical list.  The current choice is at
the top, marked with â€œ->â€.

   â€¢ C-n and C-p move among the choices.
   â€¢ RET on a directory adds its contents to the choices.
   â€¢ RET on a file exits doing â€˜find-fileâ€™.
   â€¢ C-g aborts.


File: racket-mode.info,  Node: racket-find-collection,  Prev: racket-open-require-path,  Up: Collections

5.6.2 racket-find-collection
----------------------------

â€˜M-xâ€™ â€˜racket-find-collectionâ€™

   Given a collection name, try to find its directory and files.

   Takes a collection name from point.

   With â€˜C-uâ€™ prompts you.

   If only one directory is found, â€˜ido-find-file-in-dirâ€™ lets you pick
a file there.

   If more than one directory is found, â€˜ido-completing-readâ€™ lets you
pick one, then â€˜ido-find-file-in-dirâ€™ lets you pick a file there.

   Note: This requires the â€˜raco-find-collectionâ€™ package to be
installed.  To install it, in â€˜shellâ€™ enter:

   raco pkg install raco-find-collection

   Tip: This works best with â€˜ido-enable-flex-matchingâ€™ set to t.  Also
handy is the â€˜flx-idoâ€™ package from MELPA.

   See also: *note racket-open-require-path::.


File: racket-mode.info,  Node: Macro expand,  Next: Other,  Prev: Collections,  Up: Commands

5.7 Macro expand
================

* Menu:

* racket-stepper-mode::
* racket-expand-file::
* racket-expand-region::
* racket-expand-definition::
* racket-expand-last-sexp::


File: racket-mode.info,  Node: racket-stepper-mode,  Next: racket-expand-file,  Up: Macro expand

5.7.1 racket-stepper-mode
-------------------------

â€˜M-xâ€™ â€˜racket-stepper-modeâ€™

   Major mode for Racket stepper output.

   Used by the commands *note racket-expand-file::, *note
racket-expand-definition::, *note racket-expand-region::, and *note
racket-expand-last-sexp::.

Key                                             Binding
â€˜kâ€™                                             â€˜racket-stepper-previous-itemâ€™
â€˜pâ€™                                             â€˜racket-stepper-previous-itemâ€™
â€˜jâ€™                                             â€˜racket-stepper-next-itemâ€™
â€˜nâ€™                                             â€˜racket-stepper-next-itemâ€™
â€˜RETâ€™                                           â€˜racket-stepper-stepâ€™

   In addition to any hooks its parent mode â€˜special-modeâ€™ might have
run, this mode runs the hook â€˜racket-stepper-mode-hookâ€™, as the final
step during initialization.


File: racket-mode.info,  Node: racket-expand-file,  Next: racket-expand-region,  Prev: racket-stepper-mode,  Up: Macro expand

5.7.2 racket-expand-file
------------------------

â€˜C-c C-e fâ€™

   Expand the *note racket-mode:: bufferâ€™s file in *note
racket-stepper-mode::.

   Uses the â€˜macro-debuggerâ€™ package to do the expansion.

   You do need to *note racket-run:: the file first; the namespace
active in the REPL is not used.

   If the file is non-trivial and/or is not compiled to a .zo bytecode
file, then it might take many seconds before the original form is
displayed and you can start stepping.

   With â€˜C-uâ€™ also expands syntax from racket/base â€“ which can result in
very many expansion steps.


File: racket-mode.info,  Node: racket-expand-region,  Next: racket-expand-definition,  Prev: racket-expand-file,  Up: Macro expand

5.7.3 racket-expand-region
--------------------------

â€˜C-c C-e râ€™

   Expand the active region using *note racket-stepper-mode::.

   Uses Racketâ€™s â€˜expand-onceâ€™ in the namespace from the most recent
*note racket-run::.


File: racket-mode.info,  Node: racket-expand-definition,  Next: racket-expand-last-sexp,  Prev: racket-expand-region,  Up: Macro expand

5.7.4 racket-expand-definition
------------------------------

â€˜C-c C-e xâ€™

   Expand the definition around point using *note racket-stepper-mode::.

   Uses Racketâ€™s â€˜expand-onceâ€™ in the namespace from the most recent
*note racket-run::.


File: racket-mode.info,  Node: racket-expand-last-sexp,  Prev: racket-expand-definition,  Up: Macro expand

5.7.5 racket-expand-last-sexp
-----------------------------

â€˜C-c C-e eâ€™

   Expand the sexp before point using *note racket-stepper-mode::.

   Uses Racketâ€™s â€˜expand-onceâ€™ in the namespace from the most recent
*note racket-run::.


File: racket-mode.info,  Node: Other,  Next: Showing information,  Prev: Macro expand,  Up: Commands

5.8 Other
=========

* Menu:

* racket-mode-start-faster::
* racket-mode-start-slower::


File: racket-mode.info,  Node: racket-mode-start-faster,  Next: racket-mode-start-slower,  Up: Other

5.8.1 racket-mode-start-faster
------------------------------

â€˜M-xâ€™ â€˜racket-mode-start-fasterâ€™

   Compile Racket Modeâ€™s .rkt files for faster startup.

   Racket Mode is implemented as an Emacs Lisp â€œfront endâ€ that talks to
a Racket process â€œback endâ€.  Because Racket Mode is delivered as an
Emacs package instead of a Racket package, installing it does not do the
â€˜raco setupâ€™ that is normally done for Racket packages.

   This command will do a â€˜raco makeâ€™ of Racket Modeâ€™s .rkt files,
creating bytecode files in â€˜compiled/â€™ subdirectories.  As a result,
when a command must start the Racket process, it will start somewhat
faster.

   On many computers, the resulting speed up is negligible, and might
not be worth the complication.

   If you run this command, ever, you will need to run it again after:

   â€¢ Installing an updated version of Racket Mode.  Otherwise, you might
     lose some of the speed-up.

   â€¢ Installing a new version of Racket and/or changing the value of the
     variable *note racket-program::.  Otherwise, you might get an error
     message due to the bytecode being different versions.

   To revert to compiling on startup, use *note
racket-mode-start-slower::.


File: racket-mode.info,  Node: racket-mode-start-slower,  Prev: racket-mode-start-faster,  Up: Other

5.8.2 racket-mode-start-slower
------------------------------

â€˜M-xâ€™ â€˜racket-mode-start-slowerâ€™

   Delete the â€œcompiledâ€ directories made by *note
racket-mode-start-faster::.


File: racket-mode.info,  Node: Showing information,  Next: Associating edit buffers with REPL buffers,  Prev: Other,  Up: Commands

5.9 Showing information
=======================

* Menu:

* racket-show-pseudo-tooltip::
* racket-show-echo-area::
* racket-show-header-line::
* racket-show-pos-tip::


File: racket-mode.info,  Node: racket-show-pseudo-tooltip,  Next: racket-show-echo-area,  Up: Showing information

5.9.1 racket-show-pseudo-tooltip
--------------------------------

Show using an overlay that resembles a tooltip.

   This is nicer than *note racket-show-pos-tip:: because it:

   â€¢ Doesnâ€™t flicker while navigating.
   â€¢ Doesnâ€™t disappear after a timeout.
   â€¢ Performs well when â€˜x-gtk-use-system-tooltipsâ€™ is nil.

   On the other hand, this does not look as nice when displaying text
that spans multiple lines.  In that case, we simply left-justify
everything and do not draw any border.


File: racket-mode.info,  Node: racket-show-echo-area,  Next: racket-show-header-line,  Prev: racket-show-pseudo-tooltip,  Up: Showing information

5.9.2 racket-show-echo-area
---------------------------

Show things in the echo area.

   A value for the variable *note racket-show-functions::.


File: racket-mode.info,  Node: racket-show-header-line,  Next: racket-show-pos-tip,  Prev: racket-show-echo-area,  Up: Showing information

5.9.3 racket-show-header-line
-----------------------------

Show things using a buffer header line.

   A value for the variable *note racket-show-functions::.

   When there is nothing to show, keep a blank header-line.  That way,
the buffer below doesnâ€™t â€œjump up and downâ€ by a line as messages appear
and disappear.  Only when V is nil do we remove the header line.


File: racket-mode.info,  Node: racket-show-pos-tip,  Prev: racket-show-header-line,  Up: Showing information

5.9.4 racket-show-pos-tip
-------------------------

Show things using â€˜pos-tip-showâ€™ if available.

   A value for the variable *note racket-show-functions::.


File: racket-mode.info,  Node: Associating edit buffers with REPL buffers,  Next: Browsing file URLs with anchors,  Prev: Showing information,  Up: Commands

5.10 Associating edit buffers with REPL buffers
===============================================

* Menu:

* racket-repl-buffer-name-shared::
* racket-repl-buffer-name-unique::
* racket-repl-buffer-name-project::
* racket-project-root::


File: racket-mode.info,  Node: racket-repl-buffer-name-shared,  Next: racket-repl-buffer-name-unique,  Up: Associating edit buffers with REPL buffers

5.10.1 racket-repl-buffer-name-shared
-------------------------------------

â€˜M-xâ€™ â€˜racket-repl-buffer-name-sharedâ€™

   All *note racket-mode:: edit buffers share one *note
racket-repl-mode:: buffer.

   A value for the variable *note racket-repl-buffer-name-function::.


File: racket-mode.info,  Node: racket-repl-buffer-name-unique,  Next: racket-repl-buffer-name-project,  Prev: racket-repl-buffer-name-shared,  Up: Associating edit buffers with REPL buffers

5.10.2 racket-repl-buffer-name-unique
-------------------------------------

â€˜M-xâ€™ â€˜racket-repl-buffer-name-uniqueâ€™

   Each *note racket-mode:: edit buffer gets its own *note
racket-repl-mode:: buffer.

   A value for the variable *note racket-repl-buffer-name-function::.


File: racket-mode.info,  Node: racket-repl-buffer-name-project,  Next: racket-project-root,  Prev: racket-repl-buffer-name-unique,  Up: Associating edit buffers with REPL buffers

5.10.3 racket-repl-buffer-name-project
--------------------------------------

â€˜M-xâ€™ â€˜racket-repl-buffer-name-projectâ€™

   All *note racket-mode:: buffers in a project share a *note
racket-repl-mode:: buffer.

   A value for the variable *note racket-repl-buffer-name-function::.

   The â€œprojectâ€ is determined by *note racket-project-root::.


File: racket-mode.info,  Node: racket-project-root,  Prev: racket-repl-buffer-name-project,  Up: Associating edit buffers with REPL buffers

5.10.4 racket-project-root
--------------------------

Given an absolute pathname for FILE, return its project root directory.

   The â€œprojectâ€ is determined by trying, in order:

   â€¢ â€˜projectile-project-rootâ€™
   â€¢ â€˜vc-root-dirâ€™
   â€¢ â€˜project-currentâ€™
   â€¢ â€˜file-name-directoryâ€™


File: racket-mode.info,  Node: Browsing file URLs with anchors,  Prev: Associating edit buffers with REPL buffers,  Up: Commands

5.11 Browsing file URLs with anchors
====================================

* Menu:

* racket-browse-url-using-temporary-file::


File: racket-mode.info,  Node: racket-browse-url-using-temporary-file,  Up: Browsing file URLs with anchors

5.11.1 racket-browse-url-using-temporary-file
---------------------------------------------

Browse a URL via a temporary HTML file using a meta redirect.

   A suitable value for the variable *note racket-browse-url-function::.

   Racket documentation URLs depend on anchors â€“ the portion of the URL
after the # character â€“ to jump to a location within a page.
Unfortunately on some operating systems and/or versions of Emacs, the
default handling for browsing file URLs ignores anchors.  This function
attempts to avoid the problem by using a temporary HTML file with a meta
redirect as a â€œtrampolineâ€.

   Although the intent is to provide a default that â€œjust worksâ€, you do
not need to use this.  You can customize the variable *note
racket-browse-url-function:: instead to be â€˜browse-urlâ€™, or
â€˜browse-url-browser-functionâ€™ in case have have customized that, or
indeed whatever you want.


File: racket-mode.info,  Node: Variables,  Next: Faces,  Prev: Commands,  Up: Top

6 Variables
***********

* Menu:

* General variables::
* REPL variables::
* Other variables::
* Experimental debugger variables::
* Showing information: Showing informationx.


File: racket-mode.info,  Node: General variables,  Next: REPL variables,  Up: Variables

6.1 General variables
=====================

* Menu:

* racket-program::
* racket-command-timeout::
* racket-memory-limit::
* racket-error-context::
* racket-user-command-line-arguments::
* racket-path-from-emacs-to-racket-function::
* racket-path-from-racket-to-emacs-function::
* racket-browse-url-function::
* racket-xp-after-change-refresh-delay::
* racket-xp-highlight-unused-regexp::
* racket-documentation-search-location::


File: racket-mode.info,  Node: racket-program,  Next: racket-command-timeout,  Up: General variables

6.1.1 racket-program
--------------------

Pathname of the racket executable.


File: racket-mode.info,  Node: racket-command-timeout,  Next: racket-memory-limit,  Prev: racket-program,  Up: General variables

6.1.2 racket-command-timeout
----------------------------

How many seconds to wait for command server responses.

   Note: This is mostly obsolete, fortunately, because it applies only
to commands that must block the Emacs UI until they get a response.
Instead most Racket Mode commands these days receive their response
asychronously.


File: racket-mode.info,  Node: racket-memory-limit,  Next: racket-error-context,  Prev: racket-command-timeout,  Up: General variables

6.1.3 racket-memory-limit
-------------------------

Terminate the Racket process if memory use exceeds this value in MB.

   Changes to this value take effect upon the next *note racket-run::.
A value of 0 means no limit.

   Caveat: This uses Racketâ€™s â€˜custodian-limit-memoryâ€™, which does not
enforce the limit exactly.  Instead, the program will be terminated upon
the first garbage collection where memory exceeds the limit (maybe by a
significant amount).


File: racket-mode.info,  Node: racket-error-context,  Next: racket-user-command-line-arguments,  Prev: racket-memory-limit,  Up: General variables

6.1.4 racket-error-context
--------------------------

The amount of context for error messages.

   Each increasing level supplies better context (â€œstack traceâ€) for
error messages, but causing your program to run more slowly.

   â€¢ low corresponds to compile-enforce-module-constants #t and
     compile-context-preservation-enabled #f.

   â€¢ medium corresponds to compile-enforce-module-constants #f and
     compile-context-preservation-enabled #t, which disables some
     optimizations like inlining.

   â€¢ high corresponds to medium plus the use of errortrace, which
     extensively instruments your code and therefore might cause it to
     run significantly slower.

   Tip: Regardless of this setting, you can enable high errortrace for a
specific *note racket-run:: or *note racket-run-module-at-point:: by
using â€˜C-uâ€™ .  This lets you normally run with a lower, faster setting,
and re-run when desired to get a more-helpful error message.


File: racket-mode.info,  Node: racket-user-command-line-arguments,  Next: racket-path-from-emacs-to-racket-function,  Prev: racket-error-context,  Up: General variables

6.1.5 racket-user-command-line-arguments
----------------------------------------

List of command-line arguments to supply to your Racket program.

   Accessible in your Racket program in the usual way â€” the parameter
â€˜current-command-line-argumentsâ€™ and friends.

   This is an Emacs buffer-local variable â€” convenient to set as a file
local variable.  For example at the end of your .rkt file:

     ;; Local Variables:
     ;; racket-user-command-line-arguments: ("-f" "bar")
     ;; End:

   Set this way, the value must be an *unquoted* list of strings.  For
example:

     ("-f" "bar")

   The following values will _not_ work:

     '("-f" "bar")
     (list "-f" "bar")


File: racket-mode.info,  Node: racket-path-from-emacs-to-racket-function,  Next: racket-path-from-racket-to-emacs-function,  Prev: racket-user-command-line-arguments,  Up: General variables

6.1.6 racket-path-from-emacs-to-racket-function
-----------------------------------------------

A function to transform Emacs Lisp pathnames given to the Racket back
end.

   If you run Emacs on Windows Subsystem for Linux, and want to run
Racket programs using Windows Racket.exe rather than Linux racket, you
can set this to â€˜racket-wsl-to-windowsâ€™.  In that case you probably also
want to customize the â€œreverseâ€: *note
racket-path-from-racket-to-emacs-function::.


File: racket-mode.info,  Node: racket-path-from-racket-to-emacs-function,  Next: racket-browse-url-function,  Prev: racket-path-from-emacs-to-racket-function,  Up: General variables

6.1.7 racket-path-from-racket-to-emacs-function
-----------------------------------------------

A function to transform Racket back end pathnames given to Emacs Lisp.

   The default on Windows replaces back with forward slashes.  The
default elsewhere is â€˜identityâ€™.

   If you run Emacs on Windows Subsystem for Linux, and want to run
Racket programs using Windows Racket.exe rather than Linux racket, you
can set this to â€˜racket-windows-to-wslâ€™.  In that case you probably also
want to customize the â€œreverseâ€: *note
racket-path-from-emacs-to-racket-function::.


File: racket-mode.info,  Node: racket-browse-url-function,  Next: racket-xp-after-change-refresh-delay,  Prev: racket-path-from-racket-to-emacs-function,  Up: General variables

6.1.8 racket-browse-url-function
--------------------------------

Function to call to browse a URL.


File: racket-mode.info,  Node: racket-xp-after-change-refresh-delay,  Next: racket-xp-highlight-unused-regexp,  Prev: racket-browse-url-function,  Up: General variables

6.1.9 racket-xp-after-change-refresh-delay
------------------------------------------

Seconds to wait before refreshing *note racket-xp-mode:: annotations.

   Set to nil to disable automatic refresh and manually use
â€˜racket-xp-annotateâ€™.


File: racket-mode.info,  Node: racket-xp-highlight-unused-regexp,  Next: racket-documentation-search-location,  Prev: racket-xp-after-change-refresh-delay,  Up: General variables

6.1.10 racket-xp-highlight-unused-regexp
----------------------------------------

Only give *note racket-xp-unused-face:: to unused bindings that match
this regexp.

   The default is to highlight identifiers that do not start with an
underline, which is a common convention.


File: racket-mode.info,  Node: racket-documentation-search-location,  Prev: racket-xp-highlight-unused-regexp,  Up: General variables

6.1.11 racket-documentation-search-location
-------------------------------------------

The location of the Racket â€œSearch Manualsâ€ web page.  Where *note
racket-documentation-search::, *note racket-xp-documentation:: and *note
racket-repl-documentation:: should look for the search page.

   â€¢ If the value of this variable is â€˜local, open the search page from
     the local documentation, as with â€œraco docâ€.

   â€¢ Otherwise, the value is a string recognizable by â€˜formatâ€™, with
     â€œ%sâ€ at the point at which to insert the userâ€™s search text.  the
     help desk.  Apart from â€œ%sâ€, the string should be a properly
     encoded URL.


File: racket-mode.info,  Node: REPL variables,  Next: Other variables,  Prev: General variables,  Up: Variables

6.2 REPL variables
==================

* Menu:

* racket-repl-buffer-name-function::
* racket-submodules-to-run::
* racket-repl-history-directory::
* racket-history-filter-regexp::
* racket-images-inline::
* racket-imagemagick-props::
* racket-images-keep-last::
* racket-images-system-viewer::
* racket-pretty-print::


File: racket-mode.info,  Node: racket-repl-buffer-name-function,  Next: racket-submodules-to-run,  Up: REPL variables

6.2.1 racket-repl-buffer-name-function
--------------------------------------

How to associate *note racket-mode:: edit buffers with *note
racket-repl-mode:: buffers.

   The default is nil, which is equivalent to supplying *note
racket-repl-buffer-name-shared::: One REPL buffer is shared.

   Other predefined choices include *note
racket-repl-buffer-name-unique:: and *note
racket-repl-buffer-name-project::.

   This is used when a *note racket-mode:: buffer is created.  Changing
this to a new value only affects *note racket-mode:: buffers created
later.

   Any such function takes no arguments, should look at
â€˜buffer-file-nameâ€™ if necessary, and either â€˜setq-defaultâ€™ or
â€˜setq-localâ€™ the variable â€˜racket-repl-buffer-nameâ€™ to a desired *note
racket-repl-mode:: buffer name.  As a result, *note racket-run::
commands will use a buffer of that name, creating it if necessary.


File: racket-mode.info,  Node: racket-submodules-to-run,  Next: racket-repl-history-directory,  Prev: racket-repl-buffer-name-function,  Up: REPL variables

6.2.2 racket-submodules-to-run
------------------------------

Extra submodules to run.

   This is a list of submodules.  Each submodule is described as a list,
to support submodules nested to any depth.

   This is used by commands that emulate the DrRacket Run command:

   â€¢ *note racket-run::
   â€¢ *note racket-run-and-switch-to-repl:: â€˜<f5>â€™

   It is NOT used by commands that run one specific module, such as:

   â€¢ *note racket-run-module-at-point:: â€˜C-c C-kâ€™ or â€˜C-c C-câ€™
   â€¢ *note racket-test:: â€˜<C-f5>â€™ or â€˜C-c C-tâ€™
   â€¢ *note racket-profile::


File: racket-mode.info,  Node: racket-repl-history-directory,  Next: racket-history-filter-regexp,  Prev: racket-submodules-to-run,  Up: REPL variables

6.2.3 racket-repl-history-directory
-----------------------------------

Directory for *note racket-repl-mode:: history files.


File: racket-mode.info,  Node: racket-history-filter-regexp,  Next: racket-images-inline,  Prev: racket-repl-history-directory,  Up: REPL variables

6.2.4 racket-history-filter-regexp
----------------------------------

Input matching this regexp are NOT saved on the history list.  Default
value is a regexp to ignore input that is all whitespace.


File: racket-mode.info,  Node: racket-images-inline,  Next: racket-imagemagick-props,  Prev: racket-history-filter-regexp,  Up: REPL variables

6.2.5 racket-images-inline
--------------------------

Whether to display inline images in the REPL.


File: racket-mode.info,  Node: racket-imagemagick-props,  Next: racket-images-keep-last,  Prev: racket-images-inline,  Up: REPL variables

6.2.6 racket-imagemagick-props
------------------------------

Use ImageMagick with these properties for REPL images.

   When this property list is not empty â€“ and the variable *note
racket-images-inline:: is true, and Emacs is built with with ImageMagick
support â€“ then â€˜create-imageâ€™ is called with â€œimagemagickâ€ as the type
and with this property list.

   For example, to scale images whose width is larger than 500 pixels,
supply (:max-width 500).


File: racket-mode.info,  Node: racket-images-keep-last,  Next: racket-images-system-viewer,  Prev: racket-imagemagick-props,  Up: REPL variables

6.2.7 racket-images-keep-last
-----------------------------

How many images to keep in the image cache.


File: racket-mode.info,  Node: racket-images-system-viewer,  Next: racket-pretty-print,  Prev: racket-images-keep-last,  Up: REPL variables

6.2.8 racket-images-system-viewer
---------------------------------

The image viewer program to use for â€˜racket-view-imageâ€™.


File: racket-mode.info,  Node: racket-pretty-print,  Prev: racket-images-system-viewer,  Up: REPL variables

6.2.9 racket-pretty-print
-------------------------

Use pretty-print instead of print in REPL?


File: racket-mode.info,  Node: Other variables,  Next: Experimental debugger variables,  Prev: REPL variables,  Up: Variables

6.3 Other variables
===================

* Menu:

* racket-indent-curly-as-sequence::
* racket-indent-sequence-depth::
* racket-pretty-lambda::
* racket-smart-open-bracket-enable::
* racket-logger-config::
* racket-before-run-hook::
* racket-after-run-hook::


File: racket-mode.info,  Node: racket-indent-curly-as-sequence,  Next: racket-indent-sequence-depth,  Up: Other variables

6.3.1 racket-indent-curly-as-sequence
-------------------------------------

Indent â€˜{}â€™ with items aligned with the head item?

   This is indirectly disabled if *note racket-indent-sequence-depth::
is 0.  This is safe to set as a file-local variable.


File: racket-mode.info,  Node: racket-indent-sequence-depth,  Next: racket-pretty-lambda,  Prev: racket-indent-curly-as-sequence,  Up: Other variables

6.3.2 racket-indent-sequence-depth
----------------------------------

To what depth should *note racket-indent-line:: search.

   This affects the indentation of forms like â€™() â€˜() #() â€“ and {} if
*note racket-indent-curly-as-sequence:: is t â€” but not #â€™() #â€˜() ,()
,@().  A zero value disables, giving the normal indent behavior of
DrRacket or Emacs â€˜lisp-modeâ€™ derived modes like â€˜scheme-modeâ€™.  Setting
this to a high value can make indentation noticeably slower.  This is
safe to set as a file-local variable.


File: racket-mode.info,  Node: racket-pretty-lambda,  Next: racket-smart-open-bracket-enable,  Prev: racket-indent-sequence-depth,  Up: Other variables

6.3.3 racket-pretty-lambda
--------------------------

Display lambda keywords using Î».  This is DEPRECATED.

   Instead use â€˜prettify-symbols-modeâ€™ in newer verisons of Emacs, or,
use *note racket-insert-lambda:: to insert actual Î» characters.


File: racket-mode.info,  Node: racket-smart-open-bracket-enable,  Next: racket-logger-config,  Prev: racket-pretty-lambda,  Up: Other variables

6.3.4 racket-smart-open-bracket-enable
--------------------------------------

This variable is obsolete and has no effect.

   Instead of using this variable, you may bind the â€˜[â€™ key to the
â€˜racket-smart-open-bracketâ€™ command in the â€˜racket-mode-mapâ€™ and/or
â€˜racket-repl-mode-mapâ€™ keymaps.


File: racket-mode.info,  Node: racket-logger-config,  Next: racket-before-run-hook,  Prev: racket-smart-open-bracket-enable,  Up: Other variables

6.3.5 racket-logger-config
--------------------------

Configuration of *note racket-logger-mode:: topics and levels.

   The topic â€˜* respresents the default level used for topics not
assigned a level.  Otherwise, the topic symbols are the same as used by
Racketâ€™s â€˜define-loggerâ€™.

   The levels are those used by Racketâ€™s logging system: â€˜debug, â€˜info,
â€˜warning, â€˜error, â€˜fatal.

   For more information see:
<https://docs.racket-lang.org/reference/logging.html>

   The default value sets some known â€œnoisyâ€ topics to be one level
quieter.  That way you can set the â€˜* topic to a level like â€˜debug and
not get overhwelmed by these noisy topics.


File: racket-mode.info,  Node: racket-before-run-hook,  Next: racket-after-run-hook,  Prev: racket-logger-config,  Up: Other variables

6.3.6 racket-before-run-hook
----------------------------

Normal hook done before various Racket Mode run commands.

   When hook functions are called, â€˜current-bufferâ€™ is that of the *note
racket-mode:: buffer when the run command was issued.  If a hook
function instead needs the *note racket-repl-mode:: buffer, it should
get that from the variable â€˜racket-repl-buffer-nameâ€™.


File: racket-mode.info,  Node: racket-after-run-hook,  Prev: racket-before-run-hook,  Up: Other variables

6.3.7 racket-after-run-hook
---------------------------

Normal hook done after various Racket Mode run commands.

   Here â€œafterâ€ means that the run has completed and the REPL is waiting
at another prompt.

   When hook functions are called, â€˜current-bufferâ€™ is that of the *note
racket-mode:: buffer when the run command was issued.  If a hook
function instead needs the *note racket-repl-mode:: buffer, it should
get that from the variable â€˜racket-repl-buffer-nameâ€™.


File: racket-mode.info,  Node: Experimental debugger variables,  Next: Showing informationx,  Prev: Other variables,  Up: Variables

6.4 Experimental debugger variables
===================================

* Menu:

* racket-debuggable-files::


File: racket-mode.info,  Node: racket-debuggable-files,  Up: Experimental debugger variables

6.4.1 racket-debuggable-files
-----------------------------

Used to tell *note racket-run:: what files may be instrumented for
debugging.  Must be a list of strings that are pathnames, such as from
â€˜racket--buffer-file-nameâ€™, -or-, a function that returns such a list
given the pathname of the file being run.  If any path strings are
relative, they are made absolute using â€˜expand-file-nameâ€™ with the
directory of the file being run.  The symbol â€˜run-file may be supplied
in the list; it will be replaced with the pathname of the file being
run.  Safe to set as a file-local variable.


File: racket-mode.info,  Node: Showing informationx,  Prev: Experimental debugger variables,  Up: Variables

6.5 Showing information
=======================

* Menu:

* racket-show-functions::


File: racket-mode.info,  Node: racket-show-functions,  Up: Showing informationx

6.5.1 racket-show-functions
---------------------------

A special hook variable to customize â€˜racket-showâ€™.

   Example functions include:

   â€¢ *note racket-show-pseudo-tooltip::
   â€¢ *note racket-show-echo-area::
   â€¢ *note racket-show-pos-tip::
   â€¢ *note racket-show-header-line::

   Each function should accept two arguments: VAL and POS.

   VAL is:

   â€¢ Non-blank string: Display the string somehow.

   â€¢ Blank string: Hide any previously displayed string.

   â€¢ nil: Hide any persistent UI that might have been created to show
     strings, such as by *note racket-show-header-line::.

   POS is the buffer position for which to show the message.  It may be
nil only when VAL is nil or a blank string.  When the buffer content is
a span, POS should be the end of the span.  That way, for example, a
function that shows a tooltip can position it not to hide the
interesting span in the buffer.


File: racket-mode.info,  Node: Faces,  Prev: Variables,  Up: Top

7 Faces
*******

* Menu:

* All::


File: racket-mode.info,  Node: All,  Up: Faces

7.1 All
=======

* Menu:

* racket-keyword-argument-face::
* racket-selfeval-face::
* racket-here-string-face::
* racket-xp-def-face::
* racket-xp-use-face::
* racket-xp-unused-face::
* racket-xp-tail-target-face::
* racket-xp-tail-position-face::
* racket-logger-config-face::
* racket-logger-topic-face::
* racket-logger-fatal-face::
* racket-logger-error-face::
* racket-logger-warning-face::
* racket-logger-info-face::
* racket-logger-debug-face::


File: racket-mode.info,  Node: racket-keyword-argument-face,  Next: racket-selfeval-face,  Up: All

7.1.1 racket-keyword-argument-face
----------------------------------

Face for â€˜#:keywordâ€™ arguments.


File: racket-mode.info,  Node: racket-selfeval-face,  Next: racket-here-string-face,  Prev: racket-keyword-argument-face,  Up: All

7.1.2 racket-selfeval-face
--------------------------

Face for self-evaluating expressions like numbers, symbols, strings.


File: racket-mode.info,  Node: racket-here-string-face,  Next: racket-xp-def-face,  Prev: racket-selfeval-face,  Up: All

7.1.3 racket-here-string-face
-----------------------------

Face for here strings.


File: racket-mode.info,  Node: racket-xp-def-face,  Next: racket-xp-use-face,  Prev: racket-here-string-face,  Up: All

7.1.4 racket-xp-def-face
------------------------

Face *note racket-xp-mode:: uses to highlight definitions.


File: racket-mode.info,  Node: racket-xp-use-face,  Next: racket-xp-unused-face,  Prev: racket-xp-def-face,  Up: All

7.1.5 racket-xp-use-face
------------------------

Face *note racket-xp-mode:: uses to highlight uses.


File: racket-mode.info,  Node: racket-xp-unused-face,  Next: racket-xp-tail-target-face,  Prev: racket-xp-use-face,  Up: All

7.1.6 racket-xp-unused-face
---------------------------

Face *note racket-xp-mode:: uses to highlight unused requires or
definitions.


File: racket-mode.info,  Node: racket-xp-tail-target-face,  Next: racket-xp-tail-position-face,  Prev: racket-xp-unused-face,  Up: All

7.1.7 racket-xp-tail-target-face
--------------------------------

Face *note racket-xp-mode:: uses to highlight targets of a tail
position.


File: racket-mode.info,  Node: racket-xp-tail-position-face,  Next: racket-logger-config-face,  Prev: racket-xp-tail-target-face,  Up: All

7.1.8 racket-xp-tail-position-face
----------------------------------

Face *note racket-xp-mode:: uses to highlight expressions in a tail
position.


File: racket-mode.info,  Node: racket-logger-config-face,  Next: racket-logger-topic-face,  Prev: racket-xp-tail-position-face,  Up: All

7.1.9 racket-logger-config-face
-------------------------------

Face for *note racket-logger-mode:: configuration.


File: racket-mode.info,  Node: racket-logger-topic-face,  Next: racket-logger-fatal-face,  Prev: racket-logger-config-face,  Up: All

7.1.10 racket-logger-topic-face
-------------------------------

Face for *note racket-logger-mode:: topics.


File: racket-mode.info,  Node: racket-logger-fatal-face,  Next: racket-logger-error-face,  Prev: racket-logger-topic-face,  Up: All

7.1.11 racket-logger-fatal-face
-------------------------------

Face for *note racket-logger-mode:: fatal level.


File: racket-mode.info,  Node: racket-logger-error-face,  Next: racket-logger-warning-face,  Prev: racket-logger-fatal-face,  Up: All

7.1.12 racket-logger-error-face
-------------------------------

Face for *note racket-logger-mode:: error level.


File: racket-mode.info,  Node: racket-logger-warning-face,  Next: racket-logger-info-face,  Prev: racket-logger-error-face,  Up: All

7.1.13 racket-logger-warning-face
---------------------------------

Face for *note racket-logger-mode:: warning level.


File: racket-mode.info,  Node: racket-logger-info-face,  Next: racket-logger-debug-face,  Prev: racket-logger-warning-face,  Up: All

7.1.14 racket-logger-info-face
------------------------------

Face for *note racket-logger-mode:: info level.


File: racket-mode.info,  Node: racket-logger-debug-face,  Prev: racket-logger-info-face,  Up: All

7.1.15 racket-logger-debug-face
-------------------------------

Face for *note racket-logger-mode:: debug level.



Tag Table:
Node: Top220
Node: Introduction4730
Ref: Introduction-Footnote-15889
Node: Install6284
Node: Configure Emacs to use MELPA6618
Node: Install Racket Mode7091
Node: Minimal Racket7392
Node: Uninstall7956
Node: Update8244
Node: Upgrading all packages8407
Node: Updating just Racket Mode9061
Node: Configure9782
Node: Key bindings10960
Node: Font-lock (syntax highlighting)11577
Node: Completion12861
Node: Xref (definitions and references)14728
Node: Indent17671
Node: paredit17915
Node: smartparens18908
Node: Edit buffers and REPL buffers19283
Node: eldoc20769
Node: Start faster22028
Node: Unicode input method22255
Node: Ligatures22971
Node: Reference23615
Node: Commands24107
Node: Edit24426
Node: racket-mode24979
Node: racket-insert-lambda27759
Node: racket-fold-all-tests28047
Node: racket-unfold-all-tests28284
Node: racket-tidy-requires28527
Node: racket-trim-requires29571
Node: racket-base-requires30281
Node: racket-add-require-for-identifier31546
Node: racket-indent-line32639
Node: racket-smart-open-bracket-mode34627
Node: racket-insert-closing36274
Node: racket-cycle-paren-shapes36767
Node: racket-backward-up-list37018
Node: racket-unicode-input-method-enable37578
Node: racket-align39578
Node: racket-unalign41546
Node: racket-complete-at-point41879
Node: Explore42301
Node: racket-xp-mode42802
Node: racket-xp-describe50113
Node: racket-xp-documentation51457
Node: racket-xp-next-definition52587
Node: racket-xp-previous-definition52850
Node: racket-xp-next-use53120
Node: racket-xp-previous-use53379
Node: racket-xp-next-error53641
Node: racket-xp-previous-error53870
Node: racket-xp-tail-up54106
Node: racket-xp-tail-down54570
Node: racket-xp-tail-next-sibling54851
Node: racket-xp-tail-previous-sibling55153
Node: racket-documentation-search55475
Node: Run56472
Node: racket-repl-mode56941
Node: racket-run59583
Node: racket-run-and-switch-to-repl61501
Node: racket-run-module-at-point61957
Node: racket-repl62464
Node: racket-repl-describe63432
Node: racket-repl-documentation64666
Node: racket-racket65774
Node: racket-profile65992
Node: racket-profile-mode66709
Node: racket-logger67724
Node: racket-logger-mode67945
Node: racket-debug-mode69068
Node: racket-repl-clear72665
Node: racket-repl-clear-leaving-last-prompt73252
Node: Test73567
Node: racket-test73712
Node: racket-raco-test74385
Node: Eval74632
Node: racket-send-region74824
Node: racket-send-definition75042
Node: racket-send-last-sexp75291
Node: Collections75601
Node: racket-open-require-path75795
Node: racket-find-collection76437
Node: Macro expand77351
Node: racket-stepper-mode77621
Node: racket-expand-file78659
Node: racket-expand-region79385
Node: racket-expand-definition79751
Node: racket-expand-last-sexp80140
Node: Other80492
Node: racket-mode-start-faster80685
Node: racket-mode-start-slower82028
Node: Showing information82321
Node: racket-show-pseudo-tooltip82623
Node: racket-show-echo-area83248
Node: racket-show-header-line83545
Node: racket-show-pos-tip84065
Node: Associating edit buffers with REPL buffers84342
Node: racket-repl-buffer-name-shared84739
Node: racket-repl-buffer-name-unique85172
Node: racket-repl-buffer-name-project85648
Node: racket-project-root86187
Node: Browsing file URLs with anchors86640
Node: racket-browse-url-using-temporary-file86900
Node: Variables87926
Node: General variables88188
Node: racket-program88711
Node: racket-command-timeout88894
Node: racket-memory-limit89364
Node: racket-error-context89970
Node: racket-user-command-line-arguments91087
Node: racket-path-from-emacs-to-racket-function91946
Node: racket-path-from-racket-to-emacs-function92617
Node: racket-browse-url-function93381
Node: racket-xp-after-change-refresh-delay93663
Node: racket-xp-highlight-unused-regexp94080
Node: racket-documentation-search-location94540
Node: REPL variables95344
Node: racket-repl-buffer-name-function95779
Node: racket-submodules-to-run96801
Node: racket-repl-history-directory97548
Node: racket-history-filter-regexp97831
Node: racket-images-inline98183
Node: racket-imagemagick-props98431
Node: racket-images-keep-last99039
Node: racket-images-system-viewer99293
Node: racket-pretty-print99567
Node: Other variables99775
Node: racket-indent-curly-as-sequence100164
Node: racket-indent-sequence-depth100547
Node: racket-pretty-lambda101237
Node: racket-smart-open-bracket-enable101644
Node: racket-logger-config102100
Node: racket-before-run-hook102927
Node: racket-after-run-hook103454
Node: Experimental debugger variables104046
Node: racket-debuggable-files104292
Node: Showing informationx104986
Node: racket-show-functions105182
Node: Faces106189
Node: All106292
Node: racket-keyword-argument-face106796
Node: racket-selfeval-face107006
Node: racket-here-string-face107265
Node: racket-xp-def-face107474
Node: racket-xp-use-face107707
Node: racket-xp-unused-face107931
Node: racket-xp-tail-target-face108195
Node: racket-xp-tail-position-face108475
Node: racket-logger-config-face108767
Node: racket-logger-topic-face109024
Node: racket-logger-fatal-face109270
Node: racket-logger-error-face109520
Node: racket-logger-warning-face109772
Node: racket-logger-info-face110029
Node: racket-logger-debug-face110277

End Tag Table


Local Variables:
coding: utf-8
End:
