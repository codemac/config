#+title: codemac emacs

#+begin_quote 
Emacs outshines all other editing software in approximately the same
way that the noonday sun does the stars. It is not just bigger and
brighter; it simply makes everything else vanish.

-- Neal Stephenson, "In the Beginning was the Command Line"
#+end_quote

* Introduction
  :PROPERTIES:
  :ID:       3214fd7e-44bf-4519-86ec-1f347de21d32
  :END:
The goal of this init.org file is to document my emacs configuration
in a readable manner for those who would like to borrow from it. We'll
see how this goes!
* Org initialization
  :PROPERTIES:
  :ID:       10b789e5-616b-4d30-a27a-1c4bdd57c08c
  :END:
Unfortuantely, emacs can't read directly from org mode files just yet,
so you have to check [[file:init.el][init.el]] for more information! DRY!
* User Interface
  :PROPERTIES:
  :ID:       174da1e1-650e-41f1-a5de-48a0e77b8538
  :END:
** Emacs look
   :PROPERTIES:
   :ID:       0eb756bc-30b7-4bef-8d0c-a5d67d43b619
   :END:
#+begin_src emacs-lisp
  (if (boundp 'menu-bar-mode)
      (menu-bar-mode -1))
  (if (boundp 'tool-bar-mode)
      (tool-bar-mode -1))
  (if (boundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
#+end_src
I love the empty-lines notification. However, it does seem to fail on
the very last line? I haven't solved this yet.
#+begin_src emacs-lisp
  (set-default 'indicate-empty-lines t)
#+end_src
Display all the warnings! I've had this forever, I'm not so sure how
important it actually is.
#+begin_src emacs-lisp
  (setq warning-suppress-types nil)
#+end_src
Also, I hate the audible bell, lots.
#+begin_src emacs-lisp
  (setq visible-bell 1)
#+end_src
This adds line numbers and column numbers in the emacs
modeline. Fucking essential.
#+begin_src emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+end_src
Let's get weird.
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
#+end_src
And of course, transparency!
#+begin_src emacs-lisp
  ;; Set transparency of emacs
  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque"
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))
  
  (defun netflix ()
    (interactive)
    (set-background-color "black")
    (transparency 45))
  
  
  (defun opaque ()
    (interactive)
    (load-theme 'zenburn t)
    (set-cursor-color "yellow")
    (setq cursor-type 'box)
    (transparency 100))
#+end_src
*** Modeline management
    :PROPERTIES:
    :ID:       cbf11e79-808e-4e25-8071-0ccdd748052a
    :END:
#+begin_src emacs-lisp  
  ;; Turn on the clock!
  (setq display-time-day-and-date t)
  (setq display-time-24hr-format t)
  (setq display-time-use-mail-icon t)
  (setq display-time-default-load-average nil)
  
  (display-time-mode t)
  
#+end_src
** System sepecific settings
   :PROPERTIES:
   :ID:       9af79705-bbb1-4b52-bfe7-0e05831d87b0
   :END:
Had to do some funky stuff to get around how shitty Mac OS X default
VPN settings are. Also, set different font sizes for the different
screen DPI's.
#+begin_src emacs-lisp
  (cond
    ((or (string-prefix-p "phoenix-mta" system-name)
         (string-prefix-p "vpn2ntap-" system-name)
         (string-prefix-p "moc.ppaten" (apply 'string (reverse (string-to-list system-name)))))
     (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-12:hinting=true:autohint=true")))
    ((equal system-name "penolpe")
     (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-9:hinting=true:autohint=true")))
    (t
     (set-frame-font "DejaVu Sans Mono-11:hinting=true:autohint=true")))
  
#+end_src
* Environment
  :PROPERTIES:
  :ID:       75fc0c8b-e66b-4f0f-ad21-72adef4fd23e
  :END:
** Yes I can scroll left
   :PROPERTIES:
   :ID:       4ac2d83a-08d8-437d-8937-e8775ae454b9
   :END:
#+begin_src emacs-lisp
  (put 'scroll-left 'disabled nil)
#+end_src
** Dvorak
   :PROPERTIES:
   :ID:       662be27f-102a-42dd-8a9e-c9b7269fc129
   :END:
The dvorak keyboard layout is really advantageous to those of us who
write emails all day (read: me). However, it does create some problem
with things like =C-x= in Emacs. In dvorak, =x= is =b= on the
keyboard, meaning you're reaching quite far with your hand.

I'm going to try out switching =C-t= and =C-x= as per suggested by [[http://ergoemacs.org/emacs/emacs_dvorak_C-x.html][Xah
Lee's page]] on the dvorak =C-x= problem.

#+begin_src emacs-lisp
  (keyboard-translate ?\C-x ?\C-t)
  (keyboard-translate ?\C-t ?\C-x)
#+end_src

Also, let's get angry about using C-x until I'm used to it actually being C-t.

#+begin_src emacs-lisp
  (global-set-key
   (kbd "C-t") 
   (lambda ()
     (interactive)
     (run-with-timer 
      0.3 nil 
      (lambda ()
        ;; Assuming these are the default values
        (setq visible-bell nil)
        (setq ring-bell-function 'ignore)))
     (setq visible-bell t)
     (setq ring-bell-function nil)
     (error "Don't press that button.")))
#+end_src

** Shell paths
   :PROPERTIES:
   :ID:       0e40240f-a2c3-4c03-b55d-d66e5cc0ce44
   :END:
Setting paths correctly depending on whether or not I'm on a
Mac. Mostly these days, I'm on a Mac :/
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (prefer-coding-system 'utf-8)
    (setq file-precious-flag t)
    (let* ((home-dir (getenv "HOME"))
           (mac-paths `("/Applications/Emacs.app/Contents/MacOS/bin"
                        ,(concat home-dir "/bin")
                        ,(concat home-dir "/.cabal/bin")
                        "/opt/local/bin"
                        "/usr/local/texlive/2010/bin/x86_64-darwin"
                        "/usr/local/bin"
                        "/usr/local/sbin"
                        "/usr/bin"
                        "/usr/sbin"
                        "/bin"
                        "/sbin")))
      (setenv "PATH" (concat (mapconcat 'identity mac-paths ":")
                             ":"
                             (getenv "PATH")))
      (setq exec-path (append exec-path mac-paths))))
#+end_src

** Emacs load paths
   :PROPERTIES:
   :ID:       746a0b8d-ef35-4cff-81d7-e8d2c3d49d8c
   :END:
Get my site-lisp set up. Got rid of ye old pkg-init!
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/site-lisp")
#+end_src
Also, load sub directories underneath site-lisp. This lets me copy
random tar balls of elisp without having to worry how it's all
formatted.

Special thanks to benny, who started me down this epic emacs journey
who provided this original functionality for me.
#+begin_src emacs-lisp
  (defun dirs-inside-directory (parent)
    (let (foo)
      (dolist (file (directory-files parent t))
        (when (and (not (member (file-name-nondirectory file)
                                '("." "..")))
                   (file-directory-p file))
          (setq foo (cons file foo))))
      foo))

  ;; Automagically load all folders in site-lisp as well! Thank you benny!
  (mapc (lambda (x) (add-to-list 'load-path x))
        (dirs-inside-directory "~/.emacs.d/site-lisp/"))
  (mapc (lambda (x) (add-to-list 'load-path x))
        (dirs-inside-directory "~/.emacs.d/site-lisp/xelb"))
#+end_src

*** Guix Support
    :PROPERTIES:
    :ID:       3b701aeb-81ae-4f4a-ab79-1f4633c9ebf5
    :END:
This adds the load path of the guix profile of the current user. I'm
currently using guix to manage packages for my local users.

This probably works better in GuixSD - but the systemd / dmd crap and
the icecat / firefox crap keeps me using arch as my base system.
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.guix-profile/share/emacs/site-lisp")
#+end_src
** Emacs backup files
   :PROPERTIES:
   :ID:       5f120dba-6abc-4e26-b11f-ea4769945a2c
   :END:
I like putting these all in one place. It helps to not have them
scattered accross my entire filesystem, and then they aren't pushed
out onto NFS mounted directories.

There are drawbacks. If you edit the same file over an NFS mount from
different emacs instances over time, they wont have eachother's
autosaves. I have never run into this being a problem, however.

A lot of this was borrowed from
http://snarfed.org/space/gnu%20emacs%20backup%20files, however it
appears this as changed significantly..
#+begin_src emacs-lisp
  (defvar autosave-dir
   (concat "/tmp/emacs_autosaves/" (user-login-name) "/"))
  
  (make-directory autosave-dir t)
  
  (defun auto-save-file-name-p (filename)
    (string-match "^#.*#$" (file-name-nondirectory filename)))
  
  (defun make-auto-save-file-name ()
    (concat autosave-dir
     (if buffer-file-name
        (concat "#" (file-name-nondirectory buffer-file-name) "#")
      (expand-file-name
       (concat "#%" (buffer-name) "#")))))
  
  ;; Put backup files (ie foo~) in one place too. (The backup-directory-alist
  ;; list contains regexp=>directory mappings; filenames matching a regexp are
  ;; backed up in the corresponding directory. Emacs will mkdir it if necessary.)
  (defvar backup-dir (concat "/tmp/emacs_backups/" (user-login-name) "/"))
  (setq backup-directory-alist (list (cons "." backup-dir)))
#+end_src
** Yes or no, let's do y/p
   :PROPERTIES:
   :ID:       8a6a8bc1-7cd0-4016-9381-a04bca6592cf
   :END:
Oh my freaking god, just take my damn answer.
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src
** Async Shell Command
   :PROPERTIES:
   :ID:       8e9761de-a184-4c69-9143-610d16291567
   :END:
This makes sure that we pick a new buffer and just run with it,
instead of checking if another process is running.

#+begin_src emacs-lisp
  (setq async-shell-command-buffer 'rename-buffer)
#+end_src
** Convenient global keys
   :PROPERTIES:
   :ID:       b3d4ed04-e17a-45f4-a21e-e51071f1f505
   :END:
God I love backword-kill-word. Also some bookmarks
#+begin_src emacs-lisp
  (global-set-key "\C-w" 'backward-kill-word)
  (global-set-key "\C-x\C-k" 'kill-region)

  ;; not really using this..
  ;(global-set-key [f5] 'bookmark-bmenu-list)
  ;(global-set-key [f6] 'bookmark-set)
  ;(global-set-key [f7] 'bookmark-jump)

  (defun cm/backward-kill (killwordf &optional arg)
      "Replacement for the backward-kill-word command
  If the region is active, then invoke kill-region.  Otherwise, use
  the following custom backward-kill-word procedure.
  If the previous word is on the same line, then kill the previous
  word.  Otherwise, if the previous word is on a prior line, then kill
  to the beginning of the line.  If point is already at the beginning
  of the line, then kill to the end of the previous line.

  With argument ARG and region inactive, do this that many times."
    (interactive "p")
    (if (use-region-p)
        (kill-region (mark) (point))
      (let (count)
        (dotimes (count arg)
          (if (bolp)
              (delete-backward-char 1)
            (kill-region (max (save-excursion
                                (funcall killwordf arg)
                                (point))
                              (line-beginning-position))
                         (point)))))))

  ;; handle subword / superword modes as well!
  (defun cm/backward-kill-subword (&optional arg)
    (interactive "p")
    (cm/backward-kill 'subword-backward-kill arg))

  ; I don't think this is necessary, but we'll see
  ;(defun cm/backward-kill-superword (&optional arg)
  ;  (interactive "p")
  ;  (cm/backward-kill 'superword-backward-kill arg))

  (defun cm/backward-kill-word (&optional arg)
    (interactive "p")
    (cm/backward-kill 'backward-kill-word arg))

  (define-key (current-global-map)
    [remap backward-kill-word] 'cm/backward-kill-word)

  ;; get subword's map
  (require 'subword)
  (define-key subword-mode-map
    [remap backward-kill-word] 'cm/backward-kill-subword)
#+end_src
** Narrow regions
   :PROPERTIES:
   :ID:       69621834-2ad9-460e-b2f2-e698bee359a8
   :END:
#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+end_src
** kill with linum
   :PROPERTIES:
   :ID:       debaee9f-a2d7-4545-b366-bc583870c1da
   :END:
Really useful for source code copying.. This is from [[http://stackoverflow.com/questions/12165205/how-to-copy-paste-a-region-from-emacs-buffer-with-line-file-reference][stack overflow]].

#+begin_src emacs-lisp
  (defun kill-with-linenum (beg end)
    (interactive "r")
    (save-excursion
      (goto-char end)
      (skip-chars-backward "\n \t")
      (setq end (point))
      (let* ((chunk (buffer-substring beg end))
             (chunk (concat
                     (format "╭──────── #%-d ─ %s ──\n│ "
                             (line-number-at-pos beg)
                             (or (buffer-file-name) (buffer-name)))
                     (replace-regexp-in-string "\n" "\n│ " chunk)
                     (format "\n╰──────── #%-d ─" 
                             (line-number-at-pos end)))))
        (kill-new chunk)))
    (deactivate-mark))
#+end_src
** goto-line should work on first M-g
   :PROPERTIES:
   :ID:       66fbcae2-109f-4a0d-9d68-7474fb30c92a
   :END:
taken from http://blog.akinori.org/2013/05/27/m-g-vs-goto-line/

#+begin_src emacs-lisp
  (defun cm/goto-line-number ()
    (interactive)
    (goto-line (string-to-number
                (read-from-minibuffer
                 "Goto line: "
                 (char-to-string last-command-event)))))
  (require 'cl)
  (loop for n from 1 to 9 do
        (global-set-key (format "\M-g%d" n) 'cm/goto-line-number))
  (global-set-key "\M-g?" 'describe-prefix-bindings)
#+end_src

** Use dired instead of the directory view.
   :PROPERTIES:
   :ID:       6ed4dffb-c6ce-46b1-90b8-76c735285063
   :END:
I never expect it, and when I get it it means I meant dired
anyways. This means that how I hold down the control button doesn't
matter.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-d") 'dired)
#+end_src
** Use rc escaping
   :PROPERTIES:
   :ID:       e039c4cd-5660-419a-80ca-c9fbb80be5d6
   :END:
I've now set my login shell as rc, which means that now all kinds of
arbitrary things break.

Luckily, the =shell-quote-argument= function is really easy to write,
because it really just is string replacement on the single quote. And
unquoting isn't even a thing because rc doesn't fucking suck at life,
it just passes on arguments. It's wonderful!
#+begin_src emacs-lisp
  (setq cm/using-rc t)

  (defun cm/advise-shell-quote-argument (fun &rest args)
    (if cm/using-rc
        (concat "'" (replace-regexp-in-string "'" "''" (if (listp args) (car args) args) t t) "'")
      (apply fun args)))

  (advice-add #'shell-quote-argument :around #'cm/advise-shell-quote-argument)

#+end_src
*** Support for rgrep as well
    :PROPERTIES:
    :ID:       27803a70-fbb5-491f-a962-e183b14af385
    :END:
This changes the =grep-find-template= so that quoting is used around
the brackets that rc parses.
#+begin_src emacs-lisp
;;; TODO
#+end_src
* ELPA
  :PROPERTIES:
  :ID:       75916850-2b29-435f-8f66-2d17704fe83d
  :END:
I organize my packages use with the amazing https://github.com/jwiegley/use-package
#+begin_src emacs-lisp
  (eval-when-compile
    (require 'use-package))
  (require 'diminish)
  (require 'bind-key)
#+end_src
* Color theme
  :PROPERTIES:
  :ID:       884f8d9a-73d2-422d-9344-4b752eb1e352
  :END:
Yup, zenburn.

If zenburn isn't available, we should use wombat. So how do we detect
that?

#+begin_src emacs-lisp
  (if (custom-theme-name-valid-p 'zenburn)
      (load-theme 'zenburn t)
    (load-theme 'wombat t))
;(load-theme 'wombat t)
#+end_src

For now we just check that the name is valid.
* Builtin
  :PROPERTIES:
  :ID:       7fc227dc-419d-435a-bbe3-3ca707d2c234
  :END:
** Disabled Functions
   :PROPERTIES:
   :ID:       eef4557b-bf86-4d40-bd7a-a7860f7d2777
   :END:
#+begin_src emacs-lisp
  (put 'downcase-region 'disabled nil)
#+end_src
** Open files with root
   :PROPERTIES:
   :ID:       0e0b7076-92fc-45a0-a89d-e1051988c44d
   :END:
#+begin_src emacs-lisp
  (defun cm/rename-tramp-buffer ()
    (when (file-remote-p (buffer-file-name))
      (rename-buffer
       (format "%s:%s"
               (file-remote-p (buffer-file-name) 'method)
               (buffer-name)))))

  (add-hook 'find-file-hook
            'cm/rename-tramp-buffer)

  (defadvice find-file (around th-find-file activate)
    "Open FILENAME using tramp's sudo method if it's read-only."
    (let ((thefile (ad-get-arg 0)))
      (if (or (string-prefix-p "/etc" thefile)
              (string-prefix-p "/boot" thefile))
          (if (and (not (file-writable-p thefile))
                   (y-or-n-p (concat "File "
                                     thefile
                                     " is read-only.  Open it as root? ")))
              (cm/find-file-sudo thefile))))
    ad-do-it)

  (defun cm/find-file-sudo (file)
    "Opens FILE with root privileges."
    (interactive "F")
    (set-buffer (find-file (concat "/sudo::" file))))
#+end_src
** Occur, isearch, and all
   :PROPERTIES:
   :ID:       7e4874a8-093c-4ac3-9441-5f8dd8103b39
   :END:
I like to launch occur from an isearch query. It's great when your
muscle memory searches for a word, THEN you realize you want to see it
all in one buffer. Rock the =C-c C-e= in occur mode and you can edit
everything! heck yes!

This was mostly taken from [[http://www.emacswiki.org/emacs/OccurFromIsearch][the emacs wiki]].
#+begin_src emacs-lisp
  (defun isearch-occur ()
    "Invoke `occur' from within isearch."
    (interactive)
    (let ((case-fold-search isearch-case-fold-search))
      (occur (if isearch-regexp isearch-string (regexp-quote isearch-string)))))
  
  (define-key isearch-mode-map (kbd "C-o") 'isearch-occur)
#+end_src
** Ediff
   :PROPERTIES:
   :ID:       90322ca4-3bef-4beb-92fb-036d3792660e
   :END:
Split the Ediff window depending on the orientation/size of the emacs
frame. I've found this very convenient.
#+begin_src emacs-lisp
  (setq ediff-split-window-function (lambda (&optional arg)
                                      (if (> (frame-width) 150)
                                          (split-window-horizontally arg)
                                        (split-window-vertically arg))))
#+end_src
** Useful window functions
   :PROPERTIES:
   :ID:       6fdd1fc3-0b07-4d30-b351-289529bfa72c
   :END:
from :
http://www.emacswiki.org/emacs/Rick_Bielawski
#+begin_src emacs-lisp
  ;; Idea and starter code from Benjamin Rutt (rutt.4+news@osu.edu) on comp.emacs
  (defun window-horizontal-to-vertical ()
    "Switches from a horizontal split to a vertical split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-horizontally)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))

  ;; complement of above created by rgb 11/2004
  (defun window-vertical-to-horizontal ()
    "Switches from a vertical split to a horizontal split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-vertically)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))
#+end_src
** Private stuff
   :PROPERTIES:
   :ID:       e0b91792-b154-44f6-837c-25e8bf526f72
   :END:
Just an easy way to put passwords, and other sensitive data outside of
this emacs config! Ideally I'll document all variables missing, this
may or may not be always true though.
#+begin_src emacs-lisp
  ;; irc
  (defvar cm/freenode-password "nope" "The nickserv password for freenode.")
  (defvar cm/oftc-password "nope" "The nickserv password for oftc.")
  (defvar cm/what-password "nope" "The nickserv password for what.")
  (defvar cm/rizon-password "nope" "The nickserv password for rizon.")
  (defvar cm/bitlbee-password "nope" "The password for bitlbee!")
  (defvar cm/rcirc-channel-alist '(("freenode" "#archlinux" "#emacs")
                                 ("oftc" "#ikiwiki"))
    "The channel list..")
  (defvar cm/identica-username "nope" "The password for bitlbee!")
  (defvar cm/identica-password "nope" "The password for bitlbee!")
  (defvar cm/erc-keywords "nope" "The password for bitlbee!")
  (defvar cm/rcirc-server-alist '() "The password for bitlbee!")
  (defvar cm/ironport-p4port "" "p4port")
  (defvar cm/mu4e-refile-folder (lambda (x) '()) "refile!")
  (defvar cm/erc-track-exclude "" "track exclude")


  (let ((private-file "~/.emacs-priv.el"))
    (when (file-exists-p private-file)
      (load-file private-file)))
#+end_src
** Printing
   :PROPERTIES:
   :ID:       bad1e0c5-424a-40d2-839b-c2efb24e66af
   :END:
#+begin_src emacs-lisp
  ;(require 'lpr)
  (setq lpr-command "gtklp")
#+end_src
** Sticky buffer
   :PROPERTIES:
   :ID:       6c124562-896f-460c-bc65-a8dbea21f347
   :END:
Inspired by [[http://www.reddit.com/r/emacs/comments/gjqki/is_there_any_way_to_tell_emacs_to_not/c1o26uk][a reddit comment]].
#+begin_src emacs-lisp
  (defadvice pop-to-buffer (before cancel-other-window first)
    (ad-set-arg 1 nil))
  
  (ad-activate 'pop-to-buffer)
  
  ;; Toggle window dedication
  (defun toggle-window-dedicated ()
    "Toggle whether the current active window is dedicated or not"
    (interactive)
    (message
     (if (let (window (get-buffer-window (current-buffer)))
           (set-window-dedicated-p window 
                                   (not (window-dedicated-p window))))
         "Window '%s' is dedicated"
       "Window '%s' is normal")
     (current-buffer)))
  
  ;; Press [pause] key in each window you want to "freeze"
  (global-set-key [f11] 'toggle-window-dedicated)
#+end_src
** Narrow to indirect buffer
   :PROPERTIES:
   :ID:       4636f0d8-0f7c-4e5b-b146-6b9c13a1422c
   :END:
There was a [[http://demonastery.org/2013/04/emacs-narrow-to-region-indirect/][blog post]] on [[http://www.reddit.com/r/emacs/comments/1clte0/narrowtoregionindirect_for_emacs/][reddit]] about this, and It's too good to not
use. I haven't decided what the key binding should really be yet. Al
#+begin_src emacs-lisp
  (defun cm/narrow-to-region-indirect (start end)
    "Restrict editing in this buffer to the current region, indirectly."
    (interactive "r")
    (when (fboundp 'evil-exit-visual-state) ; There's probably a nicer way to do this
      (evil-exit-visual-state))
    (let ((buf (clone-indirect-buffer nil nil)))
      (with-current-buffer buf
        (narrow-to-region start end))
      (switch-to-buffer buf)))

  (global-set-key (kbd "C-x n i") 'cm/narrow-to-region-indirect)
#+end_src
** Revert
   :PROPERTIES:
   :ID:       7d79056d-8843-4cc0-a6c2-3628609e8c19
   :END:
To revert a buffer easily, put the char back where I had it.
#+begin_src emacs-lisp
  (defun cm/revert-buffer ()
    "save the current position to tmp, revert buffer, go back to tmp"
    (interactive)
    (let ((tmp (point)))
      (revert-buffer t)
      (goto-char tmp)))
  
  (global-set-key [f8] 'cm/revert-buffer)
#+end_src
** Windmove
   :PROPERTIES:
   :ID:       a4484933-7915-4419-bef5-2aed3e288ab8
   :END:
Easy navigation around lots of splits. C-x o isn't that geographical.
#+begin_src emacs-lisp
  (global-set-key [M-left] 'windmove-left)
  (global-set-key [M-right] 'windmove-right)
  (global-set-key [M-up] 'windmove-up)
  (global-set-key [M-down] 'windmove-down)
#+end_src
** Dired
   :PROPERTIES:
   :ID:       5ad3253d-9cd5-4b61-b2fb-e6c788e63751
   :END:
This is what is sent to ls. I'm usually on a *nix-like userspace, so
ls usually exists. On windows emacs uses some ls elisp, I'm not sure
if these settings work for that.
#+begin_src emacs-lisp
  (setq dired-listing-switches "-ahlF")
#+end_src
On Mac OS X, ls -F prints an @ symbol when printing symlinks. This
setting lets dired know that this is the case.
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq dired-ls-F-marks-symlinks t))
#+end_src
*** Disabled: set dired to reuse buffers
    :PROPERTIES:
    :ID:       d5fddb2a-1cfc-423b-960a-eeb2d14894d0
    :END:
Every time you hit enter, instead of opening a new buffer, it'll reuse
the buffer. I've found I don't like using this, but it was very useful
when I first started using emacs, less so later.

Have =^= and =Enter= open the next directory in the same buffer.  I
don't think there is a situation where I don't want this to happen, so
we'll roll with this.
#+begin_src emacs-lisp
  ;; reenable!
  (put 'dired-find-alternate-file 'disabled nil)
  ;; (add-hook 'dired-mode-hook
  ;;  (lambda ()
  ;;   (define-key dired-mode-map (kbd "<return>")
  ;;     'dired-find-alternate-file) ; was dired-advertised-find-file
  ;;   (define-key dired-mode-map (kbd "a")
  ;;     'dired-advertised-find-file) ; was dired-find-alternate-file
  ;;   ; was dired-up-directory
  ;;   (define-key dired-mode-map (kbd "^")
  ;;     (lambda () (interactive) (find-alternate-file "..")))))
#+end_src
** Info
   :PROPERTIES:
   :ID:       cee7c2a5-33d5-43cb-abf3-de5174e78f95
   :END:
Mac fix for info installation location!
#+begin_src emacs-lisp
  (require 'info)
  (when (eq system-type 'darwin)
    (setq Info-directory-list
          (cons
           (expand-file-name "/opt/local/share/info/")
           Info-directory-list)))
#+end_src
** Pcomplete
   :PROPERTIES:
   :ID:       0e0b04db-4a10-473d-9a12-a19190b1878e
   :END:
#+begin_src emacs-lisp
  (require 'pcmpl-git)
#+end_src
** Shell (using rakitzis' rc)
   :PROPERTIES:
   :ID:       bf047787-944d-4eff-a8c1-dfef5f1ac63a
   :END:
*** Shell Session Management
    :PROPERTIES:
    :ID:       6d275e25-9de3-4c12-8765-fd96be7d209c
    :END:
I need to tie this into projectile, but for now have a way to create a
"main" buffer and then name other ones with =shell-new=.
#+begin_src emacs-lisp
  ;; give shell advice to load dir-locals

  (defun cm/advise-shell (&rest r)
    (hack-dir-local-variables-non-file-buffer))

  (advice-add #'shell :before #'cm/advise-shell)

  (defun cm/shell-new (name)
    "Create a shell buffer named NAME."
    (interactive "sShell Name: ")
    (let* ((bn (concat "*shell:" name "*"))
           (eb (get-buffer bn)))
      (if eb
          (switch-to-buffer eb)
        (shell bn))))

  (defun cm/current-shells ()
    (require 'subr-x)
    (delq nil
          (mapcar
           (lambda (x)
             (if (string-prefix-p "*shell:" (buffer-name x))
                 `(,(string-remove-prefix "*shell:" (string-remove-suffix "*" (buffer-name x))) ,x)))
           (buffer-list))))

  (defun cm/shell-find-or-new ()
    "Find or create a shell with the given name"
    (interactive)
    (let ((selected-shell (completing-read
                           "Shell Name: "
                           (cm/current-shells))))
      (cm/shell-new selected-shell)))

  (defun cm/shell-main ()
    (interactive)
    (cm/shell-new "main"))

  (defun cm/shell-projectile ()
    (interactive)
    (projectile-with-default-dir (projectile-project-root)
      (cm/shell-new (projectile-project-name))))

  (global-set-key (kbd "<f2>") 'cm/shell-find-or-new)
  (global-set-key (kbd "<f7>") 'cm/shell-main)
  (global-set-key (kbd "C-c p $") 'cm/shell-projectile)
#+end_src

*** Use a login shell 
    :PROPERTIES:
    :ID:       1f6334ef-51f3-417d-acc6-c578c2a9223b
    :END:
#+begin_src emacs-lisp
  (set-default 'explicit-shell-file-name "/home/codemac/.guix-profile/bin/rc")
;  (setq explicit-rc-args '("-l"))
#+end_src
*** Track the directory of the shell process
    :PROPERTIES:
    :ID:       7ffc7964-0afc-4ca1-8b1d-7f1b0da0b35d
    :END:
#+begin_src emacs-lisp
  (defun shell-procfs-dirtrack (str)
    (prog1 str
      (if (stringp str)
          (let ((directory (file-symlink-p
                        (format "/proc/%s/cwd"
                                (process-id
                                 (get-buffer-process
                                  (current-buffer)))))))
            (if directory
                (when (file-directory-p directory)
                  (cd directory)))))))

  (define-minor-mode shell-procfs-dirtrack-mode
    "Track shell directory by inspecting procfs."
    nil nil nil
    (cond (shell-procfs-dirtrack-mode
           (when (bound-and-true-p shell-dirtrack-mode)
             (shell-dirtrack-mode 0))
           (when (bound-and-true-p dirtrack-mode)
             (dirtrack-mode 0))
           (add-hook 'comint-preoutput-filter-functions
                     'shell-procfs-dirtrack nil t))
          (t
           (remove-hook 'comint-preoutput-filter-functions
                        'shell-procfs-dirtrack t))))
#+end_src

#+begin_src emacs-lisp
  (require 'tramp)

  (setq comint-scroll-to-bottom-on-input t    ; always insert at the bottom
        comint-scroll-to-bottom-on-output nil ; always add output at the bottom
        comint-scroll-show-maximum-output t   ; scroll to show max possible output
        comint-input-ignoredups t             ; no duplicates in command history
        comint-completion-addsuffix t         ; insert space/slash after file completion
        comint-buffer-maximum-size 40000      ; max length of the buffer in lines
        comint-prompt-read-only t             ; if this is t, it breaks shell-command (we'll see about that)
        comint-get-old-input (lambda () "")   ; what to run when i press enter on a
                                              ; line above the current prompt
        comint-input-ring-size 5000           ; max shell history size
        protect-buffer-bury-p nil)

  (setenv "PAGER" "cat")
  (setenv "MANPAGER" "cat")

  ;; truncate buffers continuously
  (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)

  ; interpret and use ansi color codes in shell output windows
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-filter)

  (defun set-scroll-conservatively ()
    "Add to shell-mode-hook to prevent jump-scrolling on newlines in shell buffers."
    (set (make-local-variable 'scroll-conservatively) 10))
  (add-hook 'shell-mode-hook 'set-scroll-conservatively t)
  (add-hook 'shell-mode-hook 'shell-procfs-dirtrack-mode t)

#+end_src
** Eshell
   :PROPERTIES:
   :ID:       494935b4-92ef-4ed1-899e-bbc3ec474ba2
   :END:
#+begin_src emacs-lisp
  (autoload 'eshell "eshell" "")

  (defun cm/eshell-prompt ()
    (concat user-login-name "@" system-name ":"
            ((lambda (p-lst)
               (if (> (length p-lst) 4)
                   (concat
                    (mapconcat (lambda (elm) (if (string< "" elm)
                                                 (substring elm 0 1)
                                               ""))
                               (butlast p-lst (- (length p-lst) 3))
                               "/")
                    "/"
                    (mapconcat (lambda (elm) elm)
                               (last p-lst (- (length p-lst) 3))
                               "/"))
                 (mapconcat (lambda (elm) elm)
                            p-lst
                            "/")))
             (split-string (abbreviate-file-name (eshell/pwd)) "/"))
            " % "))

  (defun eshell-new (name)
    "Create a shell buffer named NAME."
    (interactive "sEshell Name: ")
    (let* ((bn (concat "*eshell:" name "*"))
           (eb (get-buffer bn)))
      (if eb
          (switch-to-buffer eb)
        (eshell)
        (rename-buffer bn))))

  (defun eshell-main ()
    (interactive)
    (eshell-new "main"))
  ; thanks byron, now using rc
  ;(global-set-key (kbd "<f7>") 'eshell-main)

  (defalias 'enew 'eshell-new)

  (put 'eshell 'disabled "Use eshell-new instead!\n")
  (autoload 'ansi-color "ansi-color" t nil)

  ;(defun cm/eshell-handle-ansi-color ()
  ;  (ansi-color-apply-on-region eshell-last-output-start
  ;                              eshell-last-output-end))

  (setq eshell-directory-name "~/.emacs.d/eshell")
  (setq eshell-prompt-function 'cm/eshell-prompt)
  (setq eshell-prompt-regexp "^[^%#$\n]+ [%#$] ")
  (setenv "EDITOR" "emacsclient")
  (setenv "P4USER" "jmickey")
  (setenv "P4PORT" cm/ironport-p4port)
  (setenv "P4CONFIG" "P4ENV")

  ;(defun eshell/mm (&rest args)
  ;  "A better version of my mm alias"
  ;  (interactive)
  ;  (eshell-parse-command "ssh marsarch \"cd $PWD\; " (eshell-flatten-list (append "\"" args))))
  (defun unbind-symbol (symbol)
    "Totally unbind SYMBOL.

  This includes unbinding its function binding, its variable binding and its
  property list."
    (interactive "SSymbol: ")
    (fmakunbound symbol)
    (makunbound symbol)
    (setf (symbol-plist symbol) nil))

  (defun eshell/asc (cmd &rest args)
    "Eshell async shell command, to get rid of double quotes"
    (interactive)

    (let* ((asc-buffer-name (concat "*asc:" cmd "*"))
           (buffer (get-buffer-create (generate-new-buffer-name asc-buffer-name)))
           (directory default-directory))
      ;; If will kill a process, query first.
      (setq proc (get-buffer-process buffer))
      (if proc
          (if (yes-or-no-p "A command is running.  Kill it? ")
              (kill-process proc)
            (error "Shell command in progress")))
      (with-current-buffer buffer
        (setq buffer-read-only nil)
        ;; Setting buffer-read-only to nil doesn't suffice
        ;; if some text has a non-nil read-only property,
        ;; which comint sometimes adds for prompts.
        (let ((inhibit-read-only t))
          (erase-buffer))
        (display-buffer buffer)
        (setq default-directory directory)
        (setq proc (start-file-process-shell-command 
                    asc-buffer-name 
                    buffer cmd 
                    (eshell-flatten-and-stringify args)))
        (setq mode-line-process '(":%s"))
        (require 'shell) (shell-mode)
        (set-process-sentinel proc 'shell-command-sentinel)
        ;; Use the comint filter for proper handling of carriage motion
        ;; (see `comint-inhibit-carriage-motion'),.
        (set-process-filter proc 'comint-output-filter))))


  ;; Stolen from http://www.emacswiki.org/cgi-bin/wiki.pl/EshellEnhancedLS
  (eval-after-load "em-ls"
    '(progn
       (defun ted-eshell-ls-find-file-at-point (point)
         "RET on Eshell's `ls' output to open files."
         (interactive "d")
         (find-file (buffer-substring-no-properties
                     (previous-single-property-change point 'help-echo)
                     (next-single-property-change point 'help-echo))))

       (defun pat-eshell-ls-find-file-at-mouse-click (event)
         "Middle click on Eshell's `ls' output to open files.
   From Patrick Anderson via the wiki."
         (interactive "e")
         (ted-eshell-ls-find-file-at-point (posn-point (event-end event))))
       
       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "RET")      'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<return>") 'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<mouse-2>") 'pat-eshell-ls-find-file-at-mouse-click)
         (defvar ted-eshell-ls-keymap map))

       (defadvice eshell-ls-decorated-name (after ted-electrify-ls activate)
         "Eshell's `ls' now lets you click or RET on file names to open them."
         (add-text-properties 0 (length ad-return-value)
                              (list 'help-echo "RET, mouse-2: visit this file"
                                    'mouse-face 'highlight
                                    'keymap ted-eshell-ls-keymap)
                              ad-return-value)
         ad-return-value)))

  (add-hook 'eshell-preoutput-filter-functions 'ansi-color-apply)

#+end_src
** BBDB - Big Brother DataBase
   :PROPERTIES:
   :ID:       47557249-431f-4cca-a9a8-4c78f7d8741f
   :END:
Well integrated into Gnus, eventually just had to start using it!
Borrowed this pretty heavily from somewhere, will document once I know
what all these features really mean.
#+begin_src emacs-lisp
  (require 'bbdb)
  ;; uber failure
  (require 'message)
  (bbdb-initialize 'mail 'message)
  
  (setq 
   bbdb-offer-save 1                        ;; 1 means save-without-asking
   bbdb-use-pop-up t                        ;; allow popups for addresses
   bbdb-electric-p t                        ;; be disposable with SPC
   bbdb-popup-target-lines  1               ;; very small
   bbdb-dwim-net-address-allow-redundancy t ;; always use full name
   bbdb-quiet-about-name-mismatches 2       ;; show name-mismatches 2 secs
   bbdb-always-add-address t                ;; add new addresses to existing...
   ;; ...contacts automatically
   bbdb-canonicalize-redundant-nets-p t     ;; x@foo.bar.cx => x@bar.cx
   bbdb-completion-type nil                 ;; complete on anything
   bbdb-complete-name-allow-cycling t       ;; cycle through matches
   ;; this only works partially
   bbbd-message-caching-enabled t           ;; be fast
   bbdb-use-alternate-names t               ;; use AKA
   bbdb-elided-display t                    ;; single-line addresses
   ;; auto-create addresses from mail
   bbdb/mail-auto-create-p 'bbdb-ignore-some-messages-hook   
   bbdb-ignore-some-messages-alist ;; don't ask about fake addresses
   ;; NOTE: there can be only one entry per header (such as To, From)
   ;; http://flex.ee.uec.ac.jp/texi/bbdb/bbdb_11.html
   '(( "From" . "no.?reply\\|DAEMON\\|daemon\\|facebookmail\\|twitter")))
#+end_src
** MML + org
   :PROPERTIES:
   :ID:       3dda2f51-5402-48ab-9607-b713149fd10d
   :END:
#+begin_src emacs-lisp
  
  (defun cm/org-mime-html-hook ()
    (org-mime-change-element-style
     "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
                   "#E6E1DC" "#232323"))
    (org-mime-change-element-style
     "blockquote" "border-left: 2px solid gray; padding-left: 4px;"))
  
  
  (add-hook 'org-mime-html-hook 'cm/org-mime-html-hook)
  
  (add-hook 'message-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-o" 'org-mime-htmlize)))
  
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-o" 'org-mime-org-buffer-htmlize)))
#+end_src
** Gnus
   :PROPERTIES:
   :ID:       3835aa31-4277-4684-8543-8b98179ff2e6
   :END:
** xdg-open!
   :PROPERTIES:
   :ID:       82df16a5-026b-415d-9aae-c63b16630174
   :END:
#+begin_src emacs-lisp
  (defun cm/advise-browse-url-can-use-xdg-open (fun &rest args)
    (let ((res (apply fun args)))
      (if (not res)
          (and (getenv "DISPLAY")
               (executable-find "xdg-open")
               (executable-find "nohup"))
        res)))

  (advice-add #'browse-url-can-use-xdg-open :around #'cm/advise-browse-url-can-use-xdg-open)
#+end_src
** Uniquify
   :PROPERTIES:
   :ID:       42385a4e-6d56-4be3-b351-c6a4dacdef32
   :END:
So useful, I think everyone should have this turned on.
#+begin_src emacs-lisp
  (require 'uniquify)
  
  (setq uniquify-buffer-name-style 'post-forward)
  (setq uniquify-after-kill-buffer-p t)
  
  ;; unrelated, but a nice spot for it
  (defun uniquify-all-lines-region (start end)
    "Find duplicate lines in region START to END keeping first occurrence."
    (interactive "*r")
    (save-excursion
      (let ((end (copy-marker end)))
        (while
            (progn
              (goto-char start)
              (re-search-forward "^\\(.*\\)\n\\(\\(.*\n\\)*\\)\\1\n" end t))
          (replace-match "\\1\n\\2")))))
  
  (defun uniquify-all-lines-buffer ()
    "Delete duplicate lines in buffer and keep first occurrence."
    (interactive "*")
    (uniquify-all-lines-region (point-min) (point-max)))
#+end_src
* External
  :PROPERTIES:
  :ID:       d6a73715-3861-4816-9c49-0b3a2e493fa2
  :END:
** Emacs Features
   :PROPERTIES:
   :ID:       2fbe45d4-05c6-4eec-98c4-4569aaacf9f5
   :END:
*** simple httpd
    :PROPERTIES:
    :ID:       4f1c60ce-0986-45bd-b5dc-4dc596675e68
    :END:
This is a mode that provides a full http server in elisp. It does
default to serving =~/public_html=, so I turn that off here.

#+begin_src emacs-lisp
  (use-package
   simple-httpd
   :commands (httpd-start httpd-serve-directory)
   :config
   (setq httpd-root "")
   (setq httpd-serve-files nil))
#+end_src
*** Helm
    :PROPERTIES:
    :ID:       9e11b4e9-8161-41e8-8e1f-0dabd83a8145
    :END:
Helm is the new Anything. Helm will help steer you in the right
direction!

Configure helm to be used for =M-x=... well let's just use it for
everything. Helm is GNU for emacs. Helm is borg. We are the helm. You
will be assimilated.

Mostly lifted from https://tuhdo.github.io/helm-intro.html (note that
this page is *STUPID* slow in eww)

#+begin_src emacs-lisp
  (use-package helm
    :diminish helm-mode
    :bind (("M-x" . helm-M-x)
           ("M-y" . helm-show-kill-ring)
           ("C-x b" . helm-mini)
           ("C-x C-f" . helm-find-files)
           ("C-h SPC" . helm-all-mark-rings))
    :init
    (require 'helm-config)
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (helm-mode 1)
    :config
    (setq helm-split-window-in-side-p t
          helm-ff-file-name-history-use-recentf t
          helm-ff-search-library-in-sexp t
          helm-move-to-line-cycle-in-source t
          helm-scroll-amount 8
          helm-ff-file-name-history-use-recentf t
          helm-man-or-woman-function 'woman)
    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))
    (delete helm-source-locate helm-for-files-preferred-list)
    
    (when cm/using-rc
        (setq helm-top-command "COLUNMS=%s top -b -n 1"))

    ;; bindings I haven't figured out with :bind
    (global-unset-key (kbd "C-x c"))
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z")  'helm-select-action)
    (global-set-key (kbd "C-c h o") 'helm-occur)
    (global-set-key (kbd "C-c h x") 'helm-register))

  ;; I dislike helm grep immensely (super slow!) and I don't use ack / ag
  ;; / etc. This disables C-c p s <g,a,s> and just does C-c p s like it
  ;; used to.

  (use-package helm-projectile
    :config
    (setq projectile-completion-system 'helm)
    (helm-projectile-on)
    (define-key projectile-command-map (kbd "s")  'projectile-grep))


#+end_src
**** Mac os x hacks
     :PROPERTIES:
     :ID:       ca5c4755-da49-491b-ae37-6255407b5598
     :END:
Get spotlight into list of the files that helm can inspect, and get
top output that doesn't suck
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (add-to-list 'helm-for-files-preferred-list 'helm-c-source-mac-spotlight)
    (setq helm-c-top-command "COLUMNS=%s top -l 1"))
#+end_src
**** Global Tags
     :PROPERTIES:
     :ID:       17f2f463-4bb3-4901-86e6-2acb32572dbf
     :END:
Yay gtags support for helm!
#+begin_src emacs-lisp
  (use-package helm-gtags
    :config
    (add-hook 'c-mode-hook (lambda () (helm-gtags-mode)))
    
    ;; customize
    (setq helm-c-gtags-path-style 'absolute)
    (setq helm-c-gtags-ignore-case t)
    (setq helm-c-gtags-read-only nil)
    
    ;; key bindings
    (add-hook 'helm-gtags-mode-hook
              '(lambda ()
                 (local-set-key (kbd "C-c g t") 'helm-gtags-find-tag)
                 (local-set-key (kbd "C-c g r") 'helm-gtags-find-rtag)
                 (local-set-key (kbd "C-c g s") 'helm-gtags-find-symbol)
                 (local-set-key (kbd "C-c g f") 'helm-gtags-find-files)
                 (local-set-key (kbd "C-t") 'helm-gtags-pop-stack))))
#+end_src
*** Minimap
    :PROPERTIES:
    :ID:       f41de103-ff8a-4327-9974-9648cec029fe
    :END:
Got jealous, had to have it in emacs. Not so useful after all...
#+begin_src emacs-lisp
  (use-package minimap
    :commands minimap-create)
#+end_src
*** Word count
    :PROPERTIES:
    :ID:       bf701e19-c3b1-4df8-8ea2-3bc377fc9d98
    :END:
NaNoWriMo!
#+begin_src emacs-lisp
  (autoload 'word-count-mode "word-count"
            "Minor mode to count words." t nil)
  (global-set-key "\M-+" 'word-count-mode)
#+end_src
*** IBuffer
    :PROPERTIES:
    :ID:       0ebd6cb6-2216-4b38-9e05-569d1fa85fde
    :END:
Incredibly useful way to browse your buffers.
#+begin_src emacs-lisp
  (require 'ibuffer)
  
  ;; replace emac's default buffer list with the excellent ibuffer
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  
  (define-ibuffer-sorter filename-or-dired
    "Sort the buffers by their pathname."
    (:description "filenames plus dired")
    (string-lessp 
     (with-current-buffer (car a)
       (or buffer-file-name
           (if (eq major-mode 'dired-mode)
               (expand-file-name dired-directory))
           ;; so that all non pathnames are at the end
           "~"))
     (with-current-buffer (car b)
       (or buffer-file-name
           (if (eq major-mode 'dired-mode)
               (expand-file-name dired-directory))
           ;; so that all non pathnames are at the end
           "~"))))
  
  ;; Add pathnam sorting, useful after 's m'
  (define-key ibuffer-mode-map (kbd "s p") 'ibuffer-do-sort-by-filename-or-dired)
#+end_src
*** Desktop
    :PROPERTIES:
    :ID:       a920b9cb-92ec-4652-a937-bb296f32bad6
    :END:
Saves everything! Very useful for the epic emacs restarters (me)
#+begin_src emacs-lisp
  (require 'desktop)
  
  (desktop-save-mode 1)
  
  ;; auto-save emacs instance
  (defun cm/desktop-save ()
    (interactive)
    (if (eq (desktop-owner) (emacs-pid))
        (desktop-save desktop-dirname)))
  
  (add-hook 'auto-save-hook 'cm/desktop-save)
#+end_src
*** Browse Kill Ring
    :PROPERTIES:
    :ID:       6287094b-d31c-42d9-b125-870943a9e90d
    :END:
Navigate visually through the entire kill ring.
#+begin_src emacs-lisp
  (autoload 'browse-kill-ring "browse-kill-ring" "")
  
  (global-set-key (kbd "C-c n") 'browse-kill-ring)
#+end_src

*** Expand region
    :PROPERTIES:
    :ID:       4cc35189-c58c-42ef-8e80-aae7f2ac00e6
    :END:
If you have a region selected, typing =C-== will expand the selection
out semantically.
#+begin_src emacs-lisp
  (autoload 'expand-region "expand-region" "")
  (global-set-key (kbd "C-=") 'er/expand-region)
#+end_src
*** Ace Jump
    :PROPERTIES:
    :ID:       c32057a8-724c-479d-8f20-d3c7b7e2ea7e
    :END:
#+begin_src emacs-lisp
  (use-package
   ace-jump-mode
   :bind ("C-." . ace-jump-mode))
#+end_src
*** Hilight line
    :PROPERTIES:
    :ID:       f7ae60f6-a98c-4bd2-9453-45a5a4f96fa2
    :END:
#+begin_src emacs-lisp
  ;; Default hl
  (global-hl-line-mode t)
  (make-variable-buffer-local 'global-hl-line-mode)

#+end_src
*** Projectile
    :PROPERTIES:
    :ID:       b8c6fcd8-02a8-4e74-9a7d-f55ced1f2e2a
    :END:
#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config
    (projectile-global-mode)
    (setq projectile-use-git-grep t))
#+end_src
** Major Modes
   :PROPERTIES:
   :ID:       04fe1433-561d-453a-a3c7-3ec248df0175
   :END:
   
*** Ledger
    :PROPERTIES:
    :ID:       22c83662-0e53-427a-99e8-70e640a87229
    :END:
I use ledger to track my finances. I have it align amounts and use ISO
dates, but other than that pretty normal config
#+begin_src emacs-lisp
  (use-package
   ledger-mode
   :mode ("\\.ledger$"
          "\\.journal$")
   :init
   (setq ledger-post-auto-adjust-amounts t)
   (setq ledger-use-iso-dates t))
#+end_src
*** Markdown
    :PROPERTIES:
    :ID:       577a0ae4-15dc-4f23-8010-4a2c884afe73
    :END:
#+begin_src emacs-lisp
  (use-package
   markdown-mode
   :mode "\\.\\(md\\|markdown\\|mdwn\\)$")
#+end_src
*** Evil
    :PROPERTIES:
    :ID:       b85dc1f9-cbe3-40ff-b9a4-17b84e98cb18
    :END:
**** Activate Evil!
     :PROPERTIES:
     :ID:       0323ddc8-4107-4bef-868b-8636fbf95fcb
     :END:
     I have become one of them :/
#+begin_src emacs-lisp
  ;(require 'evil)
  ;
  ;(evil-mode 1)
#+end_src
**** Evil Ace Jump
     :PROPERTIES:
     :ID:       8b7dc631-4a6c-497f-ae58-6879fac697b2
     :END:
Let's me use ace jump e'erywhere
#+begin_src emacs-lisp
  ;(define-key evil-motion-state-map (kbd "SPC") #'evil-ace-jump-word-mode)
  ;(define-key evil-motion-state-map (kbd "C-SPC") #'evil-ace-jump-char-mode)
  ; 
  ;(define-key evil-operator-state-map (kbd "SPC") #'evil-ace-jump-word-mode) ; similar to f
  ;(define-key evil-operator-state-map (kbd "C-SPC") #'evil-ace-jump-char-mode) ; similar to t
  ;(define-key evil-operator-state-map (kbd "M-SPC") #'evil-ace-jump-char-to-mode)
  ; 
  ;;; different jumps for different visual modes
  ;(defadvice evil-visual-line (before spc-for-line-jump activate)
  ;(define-key evil-motion-state-map (kbd "SPC") #'evil-ace-jump-word-mode))
  ; 
  ;(defadvice evil-visual-char (before spc-for-char-jump activate)
  ;(define-key evil-motion-state-map (kbd "SPC") #'evil-ace-jump-word-mode))
  ; 
  ;(defadvice evil-visual-block (before spc-for-char-jump activate)
  ;(define-key evil-motion-state-map (kbd "SPC") #'evil-ace-jump-word-mode))

  ;(evil-set-initial-state 'shell-mode 'emacs)
  ;(evil-set-initial-state 'org-mode 'emacs)
#+end_src
For some reason that does not include evil-local-mode.
#+begin_src emacs-lisp
  (unless (boundp 'evil-local-mode)
    (autoload 'evil-local-mode "evil" "Toggle evil in single buffer" t))
#+end_src
*** Valgrind
    :PROPERTIES:
    :ID:       1a583879-2d47-4e92-88d8-b47ecaf28dd1
    :END:
#+begin_src emacs-lisp
  ; Based on compile.el included with Emacs
  ; and ideas from http://tromey.com/blog/?p=342
  ; compile.el is GPL, so this is too.
  
  (require 'compile "compile")
  
  (defgroup valgrind nil
    "Run valgrind as inferior of Emacs, parse error messages."
    :group 'tools
    :group 'processes)
  
  
  (defcustom valgrind-command "valgrind --leak-check=full "
    "*Last shell command used to run valgrind; default for next valgrind run.
  
  Sometimes it is useful for files to supply local values for this variable.
  You might also use mode hooks to specify it in certain modes, like this:
  
      (add-hook 'c-mode-hook
         (lambda ()
           (unless (or (file-exists-p \"makefile\")
                       (file-exists-p \"Makefile\"))
             (set (make-local-variable 'valgrind-command)
                  (concat \"make -k \"
                          (file-name-sans-extension buffer-file-name))))))"
    :type 'string
    :group 'valgrind)
  
  ;; History of compile commands.
  (defvar valgrind-history nil)
  
  
  (defun valgrind (command)
    "Run valgrind.
  Runs COMMAND, a shell command, in a separate process asynchronously
  with output going to the buffer `*valgrind*'.
  
  You can then use the command \\[next-error] to find the next error message
  and move to the source code that caused it."
    (interactive
     (if (or compilation-read-command current-prefix-arg)
         (list (read-from-minibuffer "Valgrind command: "
                                   (eval valgrind-command) nil nil
                                   '(valgrind-history . 1)))
       (list (eval valgrind-command))))
    (unless (equal command (eval valgrind-command))
      (setq valgrind-command command))
    (compilation-start command t))
#+end_src
*** PlantUML
    :PROPERTIES:
    :ID:       5c8d9180-9215-438c-8d91-c4348e01c7f4
    :END:
Get the jarfile in the correct place...
#+begin_src emacs-lisp
  (setq plantuml-jar-path (expand-file-name "/opt/plantuml/plantuml.jar"))
  (setenv "GRAPHVIZ_DOT" "/usr/bin/dot")
#+end_src
*** Scheme
    :PROPERTIES:
    :ID:       33d797c6-9e42-4cc8-a04d-8af3d0e2d3ba
    :END:
[[http://emacswiki.org/emacs/ParEdit][Paredit]] is an amazing minor mode for editing lisp, but it is a bit
complex. I turn it on for scheme, but not elisp as usually when I'm
hacking on elisp I want the lowest barrier to entry.

#+begin_src emacs-lisp
  (add-hook 'scheme-mode-hook
            '(lambda ()
               (paredit-mode 1)))
#+end_src
*** Paredit
    :PROPERTIES:
    :ID:       f2621984-6644-4efc-8154-0c2ab06b5bb8
    :END:
#+begin_src emacs-lisp
  (use-package paredit)
#+end_src
*** Common Lisp
    :PROPERTIES:
    :ID:       5803e34a-7304-429a-ba92-f69e14623941
    :END:
Uhh, go CL?
#+begin_src emacs-lisp
  (require 'cl)
#+end_src
*** Markdown
    :PROPERTIES:
    :ID:       8e52bfd7-4fd2-4076-8a03-faddfa0941b3
    :END:
#+begin_src emacs-lisp
  (autoload 'markdown-mode "markdown-mode.el"
    "Major mode for editing Markdown files" t)
  (add-hook 'markdown-mode-hook '(lambda ()
                                   (flyspell-mode 1)
                                   (auto-fill-mode 1)))
  
  ;; autoload
  (add-to-list 'auto-mode-alist '("\\.mdwn$" . markdown-mode))
#+end_src
*** Haskell
    :PROPERTIES:
    :ID:       c7b6733c-7939-4988-a533-1be0b7d68c06
    :END:
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
  (add-hook 'haskell-mode-hook '(lambda () (linum-mode 1)))
  (setq haskell-hoogle-program "hoogle")
#+end_src
*** Go
    :PROPERTIES:
    :ID:       b10a04b5-9b60-4a6f-97d8-ad7ad6394dbb
    :END:
**** Fuck GOPATH and everything in it
     :PROPERTIES:
     :ID:       c441d182-f0d9-4f8b-a938-1c6ebf45e20a
     :END:
So emacs doesn't handle project specific *environment
variables*. Which sucks horribly, and I don't blame any of the project
tools for not addressing it, as there are no great answers.

The fact that the golang project has made it a prerequisite that so
many are set, and that there are rarely cli overrides for them is
really a fault of their own.

**** Fix go-mode's gofmt
     :PROPERTIES:
     :ID:       8eafd986-81f9-4b2d-9db5-46c886fdf06a
     :END:

You'll see the commented section in this function. When the current
go-mode.el calls =delete-windows-on outbuf= it closes pretty much any
other window you have open. This gets old. Fast.

#+begin_src emacs-lisp
  (use-package go-mode
    :mode "\\.go$"
    :config
    (defun gofmt ()
      "Pipe the current buffer through the external tool `gofmt`.
  Replace the current buffer on success; display errors on failure."
    
      (interactive)
      (let ((srcbuf (current-buffer)))
        (with-temp-buffer
          (let ((outbuf (current-buffer))
                (errbuf (get-buffer-create "*Gofmt Errors*"))
                (coding-system-for-read 'utf-8)    ;; use utf-8 with subprocesses
                (coding-system-for-write 'utf-8))
            (with-current-buffer errbuf (erase-buffer))
            (with-current-buffer srcbuf
              (save-restriction
             (let (deactivate-mark)
               (widen)
               (if (= 0 (shell-command-on-region (point-min) (point-max) "gofmt"
                                                 outbuf nil errbuf))
                   ;; gofmt succeeded: replace the current buffer with outbuf,
                   ;; restore the mark and point, and discard errbuf.
                   (let ((old-mark (mark t)) (old-point (point)))
                     (erase-buffer)
                     (insert-buffer-substring outbuf)
                     (goto-char (min old-point (point-max)))
                     (if old-mark (push-mark (min old-mark (point-max)) t))
                     (kill-buffer errbuf))
               
                 ;; gofmt failed: display the errors
                 (display-buffer errbuf)))))
          
            ;; Collapse any window opened on outbuf if shell-command-on-region
            ;; displayed it.
            ;; NO! Don't do that< cm!
            ;;(delete-windows-on outbuf)
            ))))

    (defun cm/go-mode-hook ()
      (interactive)
      (require 'go-oracle)
      (setq go-oracle-command "/home/codemac/bin/oracle")
      (go-oracle-mode)
      (subword-mode 1)
      (diminish 'go-oracle-mode)
      (linum-mode 1)
      (setq imenu-generic-expression
            '(("type" "^type *\\([^ \t\n\r\f]*\\)" 1)
              ("func" "^func *\\(.*\\) {" 1)))
      (imenu-add-to-menubar "Index")
      (add-hook 'before-save-hook #'gofmt-before-save))

    (add-hook 'go-mode-hook 'cm/go-mode-hook))
#+end_src

*** Ruby
    :PROPERTIES:
    :ID:       0d05cf49-73f2-40f2-b607-45795c1a9650
    :END:
Lisp has kind of taken over from Ruby. Whether that's Scheme or Common
Lisp seems to be the current mental debate.
#+begin_src emacs-lisp
  (autoload 'ruby-mode "ruby-mode"
    "Mode for editing ruby source files")

  (add-hook 'ruby-mode-hook 'turn-on-font-lock)
  
  (add-to-list 'interpreter-mode-alist '("ruby" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
#+end_src
*** C
    :PROPERTIES:
    :ID:       4d420720-231b-491a-848f-d384b6cdc2cd
    :END:
My C settings.
#+begin_src emacs-lisp
  (require 'compile)
  
  (defun* get-closest-pathname (&optional (file "*akefile") (dir default-directory))
    "Determine the pathname of the first instance of FILE starting
     from the current directory towards root. This may not do the
     correct thing in presence of links. If it does not find FILE,
     then it shall return the name of FILE in the current
     directory, suitable for creation"
    (let ((root (expand-file-name "/")))
      (loop 
       for d = dir then (expand-file-name ".." d)
       if (file-expand-wildcards (expand-file-name file d))
       return (car (file-expand-wildcards (expand-file-name file d)))
       if (equal d root)
       return nil)))
  
  (defun cm/make-c++-header ()
    (interactive)
    (c++-mode)
    (add-file-local-variable-prop-line 'mode 'c++))
  
  (c-add-style "mars" '("linux"))
  
  (defun my-c-hook ()
    (interactive)
    (c-set-style "mars")
    (require 'auto-complete)
    (setq tab-width 8)
    (setq indent-tabs-mode t)
    (setq tab-stop-list
          '(8 16 24 32 40 48 56 64 72 80 88 96 104 112 120))
    (setq fill-column 80)
    (setq-default c-basic-offset 8)
    (setq show-trailing-whitespace t)
    (setq c-tab-always-indent t)
    (linum-mode 1)
    (setq comment-multi-line t)
    (local-set-key (kbd "C-c o") 'ff-find-other-file)
    ;; (gtags-mode 1) ; no more! going to helm!
    (helm-gtags-mode)
    (set (make-local-variable 'compilation-directory-matcher)
         '("\\(?:\\(?:Entering\\|Leavin\\(g\\)\\) directory
    `\\(.+\\)'$\\)\\|\\(?:[^]^[]*\\][[:space:]]*\\(\\(?:[[:alnum:]]*/\\)+\\)\\)\\|\\(?:^\\(\\[\\)\\)"
           (2 . 1) (3 . 9) (4 . 4)))
    (set (make-local-variable 'compile-command) "~/bin/emacs-mars-compile")
    (add-to-list 'ac-sources '(ac-source-gtags
                               ac-source-semantic
                               ac-source-words-in-buffer))
    (auto-complete-mode -1))
  
  
  (add-hook 'c++-mode-hook 'my-c-hook)
  (add-hook 'cc-mode-hook 'my-c-hook)
  (add-hook 'c-mode-hook 'my-c-hook)
#+end_src
*** GNU Plot
    :PROPERTIES:
    :ID:       c8bff85d-6ad0-4580-a461-49eb7910b574
    :END:
Get some fancy graphs going. I mostly use R, but this is nice when /other/ people use gnuplot.
#+begin_src emacs-lisp
  (autoload 'gnuplot-mode "gnuplot" "gnuplot major mode" t)
  (autoload 'gnuplot-make-buffer "gnuplot" "open a buffer in gnuplot mode" t)
  (add-to-list 'auto-mode-alist '("\\.gp$" . gnuplot-mode))
#+end_src
*** Magit
    :PROPERTIES:
    :ID:       84c9b972-5967-4c5e-b096-b00511a56dc2
    :END:
Because I switched to Magit! Works well, and is fairly canonical at
this point. I don't understand vc-mode that well yet, so I really just
use magit-status and magit-log.

magit-log is missing the commiter annotation, I need to fix that.
#+begin_src emacs-lisp
  (use-package magit
    :diminish magit-auto-revert-mode)
#+end_src
**** Custom Commit Message Formatting
     :PROPERTIES:
     :ID:       ea200f52-b363-4450-82c9-4f970a4c4254
     :END:
Sort files by spelling. I figure the internal ordering of each
paragraph should be fine. I'm still working on a cm/gnu-fill-paragraph
that works on these commit message regions.

This regex finds the first line that begins with an asterix.
#+begin_src emacs-lisp
  (defvar cm/gnu-line-start "^\* .*$")
#+end_src
=sort-subr= expects two functions to help it find the boundaries of
records. =nextrec= finds the beginning of the next record, unless
there are no more records and then it should be pointing at the end of
the buffer (=eobp=).
#+begin_src emacs-lisp
  (defun cm/gnu-line-next ()
    (if (not (eobp))
        (forward-line 1))
    (while (and (not (eobp)) (not (looking-at cm/gnu-line-start)))
      (forward-line 1))
    (end-of-line)
    (if (not (eobp))
        (beginning-of-line)))
#+end_src
=endrec= finds the end of the *current* record. In the commit message
case this means finding the next line that starts with an asterix,
then going back to the previous line's end. This handles commit
messages that have multiple functions/lines describing a file's
changes.
#+begin_src emacs-lisp
  (defun cm/gnu-line-end ()
    (if (not (eobp))
        (forward-line 1))
    (while (and (not (eobp)) (not (looking-at cm/gnu-line-start)))
      (forward-line 1))
    (if (not (eobp)) (forward-line -1))
    (end-of-line))
#+end_src
Finally, we get to the part where we actually call sort-subr. Pretty
standard implementation, and mostly lifted from =sort-paragraphs= in
=sort.el.gz=.
#+begin_src emacs-lisp    
  (defun cm/sort-gnu-lines (reverse beg end)
    (interactive "P\nr")
    (save-excursion
      (save-restriction
        (narrow-to-region beg end)
        (goto-char (point-min))
        (sort-subr reverse 'cm/gnu-line-next 'cm/gnu-line-end))))
#+end_src
***** TODO Fix up the idea of "creating" gnu lines
      :PROPERTIES:
      :ID:       b803e11d-489a-40e5-a495-faee9a5cf4a0
      :END:
#+begin_src emacs-lisp
  ; this works well with my git-commit after save hook and rebasing
  ;(defun cm/create-gnu-lines (reverse beg end)
  ;  (interactive "P\nr")
  ;  (save-excursion
  ;    (save-restriction
  ;      (narrow-to-region beg end)
  ;      (goto-char (point-min))
  ;      (
  (fset 'cm/create-gnu-lines
     "* \C-a\C-n\C-k\C-k\C-k\C-k")
#+end_src
I don't have a good keybinding for this yet, but I will figure
something out :P
*** Esperanto
    :PROPERTIES:
    :ID:       5ff50b28-b29e-41f1-858c-3481b8a7c07d
    :END:
This is heavily borrowed from the spanish mode, works wonders.
#+begin_src emacs-lisp
  (load-library "esperanto")
#+end_src
*** Mode Compile
    :PROPERTIES:
    :ID:       7008c9ba-111a-46fb-afb7-d8b2750a6616
    :END:
Friendlier compilation support, tries to guess what the compilation
command should be. I haven't found this to be incredibly helpful
unless you are using the default build systems (make, pdflatex, etc).
#+begin_src emacs-lisp
  (autoload 'mode-compile "mode-compile"
     "Command to compile current buffer file based on the major mode" t)
  ;(global-set-key "\C-cc" 'mode-compile)
  (global-set-key "\C-cc" 'compile)
  (autoload 'mode-compile-kill "mode-compile"
   "Command to kill a compilation launched by `mode-compile'" t)
  (global-set-key "\C-ck" 'mode-compile-kill)
#+end_src
*** YAML
    :PROPERTIES:
    :ID:       b37acdb0-1ecd-43e5-a92a-5380a5553263
    :END:
More ruby days.
#+begin_src emacs-lisp
  (autoload 'yaml-mode "yaml-mode" "Yaml editing mode" t)
  
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.yaml$" . yaml-mode))
#+end_src

*** HAML
    :PROPERTIES:
    :ID:       25c5fc08-8ed9-4c8e-9c9a-374e3e705d5a
    :END:
No seriously, I wrote lots of Ruby.
#+begin_src emacs-lisp
  (autoload 'haml-mode "haml-mode" "" t)
  (add-hook 'haml-mode-hook '(lambda ()
                               (setq indent-tabs-mode nil)))
  
  (add-to-list 'auto-mode-alist '("\\.haml$" . haml-mode))
  (add-to-list 'auto-mode-alist '("\\.sass$" . sass-mode))
#+end_src
*** Tramp
    :PROPERTIES:
    :ID:       e8416c36-fe80-4ec2-831b-69134111cc35
    :END:
#+begin_src emacs-lisp
  (require 'tramp-loaddefs)
  (require 'tramp)
  (eval-after-load 'tramp
    (progn
      (setq tramp-default-method "ssh")
      (setq tramp-verbose 6)))
#+end_src
*** GNU Global
    :PROPERTIES:
    :ID:       17fec222-08cc-4942-bd94-f9d4fb788c25
    :END:
Thank you Britt.
#+begin_src emacs-lisp
  (require 'gtags-autoloads)
  
  (defun my-gtags-settings ()
    "Settings for gtags."
  
    ;; Key bindings.
    (define-prefix-command 'gtags-keymap)
    (define-key global-map (kbd "C-c g") 'gtags-keymap)
  
    (define-key gtags-mode-map (kbd "C->") 'gtags-find-tag-from-here)
    (define-key gtags-mode-map (kbd "C-<") 'gtags-pop-stack)
    (define-key gtags-mode-map (kbd "C-c g s") 'gtags-find-symbol)
    (define-key gtags-mode-map (kbd "C-c g t") 'gtags-find-tag)
    (define-key gtags-mode-map (kbd "C-c g r") 'gtags-find-rtag)
    (define-key gtags-mode-map (kbd "C-c g p") 'my-gtags-find-file)
    (define-key gtags-mode-map (kbd "C-c g v") 'gtags-visit-rootdir)
    (define-key gtags-mode-map [mouse-2] 'gtags-find-tag-by-event)
    (define-key gtags-mode-map [mouse-3] 'gtags-pop-stack)
  
    (define-key gtags-select-mode-map (kbd "n") 'next-line)
    (define-key gtags-select-mode-map (kbd "p") 'previous-line)
    (define-key gtags-select-mode-map (kbd "RET") 'gtags-select-tag)
    (define-key gtags-select-mode-map (kbd "C-<") 'gtags-pop-stack)
    (define-key gtags-select-mode-map (kbd "C->") 'gtags-select-tag)
    (define-key gtags-select-mode-map (kbd "q") 'gtags-pop-stack)
    (define-key gtags-select-mode-map [mouse-2] 'gtags-select-tag-by-event)
    (define-key gtags-select-mode-map [mouse-3] 'gtags-pop-stack)
  
    ;; Highlight gtags item line.
    (add-hook 'gtags-select-mode-hook '(lambda () (hl-line-mode 1)))
  
    ;; Update gtags data after save file.
    (defun gtags-update ()
      "Update gtags data."
      (interactive)
      (start-process "gtags-update" nil "global" "-u"))
    ; (add-hook 'after-save-hook 'gtags-update) ;ahh, no
  
    ;; visit current file under cursor.
    (defun my-gtags-find-file ()
      "Gtags find file, and jump to last exit position."
      (interactive)
      (gtags-find-file)
      (pop-global-mark))
  
    ;; find current header file under cursor.
    (defun my-gtags-find-this-file ()
      "Gtags find current header file under cursor."
      (interactive)
      (let (tagname)
        (setq tagname (concat (current-word) ".h"))
        (gtags-push-context)
        (gtags-goto-tag tagname "Po"))
      (pop-global-mark))
    (define-key gtags-mode-map [M-mouse-2] 'my-gtags-find-this-file)
  )
  
  (eval-after-load "gtags"
    '(my-gtags-settings))
#+end_src
*** Android
    :PROPERTIES:
    :ID:       acc7d0e7-3f18-40f2-9b60-28389ee05743
    :END:
#+begin_src emacs-lisp
  (autoload 'android-mode "android-mode.el" "Android minor mode" t)
  (autoload 'android "/opt/android-sdk/tools/lib/android.el" "Google provided android emacs" t)
#+end_src
*** Smart tab
    :PROPERTIES:
    :ID:       0015eb36-2e29-44f8-8fec-12696fa5070f
    :END:
#+begin_src emacs-lisp
  (require 'smart-tab)
#+end_src
*** Python
    :PROPERTIES:
    :ID:       19ef428e-9397-4ebe-9f0a-d2c75bdb4c13
    :END:
#+begin_src emacs-lisp
  (add-hook 'python-mode-hook
            '(lambda ()
               (linum-mode 1)
               (setq show-trailing-whitespace t)))
#+end_src
** Programs
   :PROPERTIES:
   :ID:       cb65de78-396a-4243-8bd8-4132d982e360
   :END:
*** notmuch
    :PROPERTIES:
    :ID:       705f65b0-cd4f-4c2f-a7da-dc340505dbbc
    :END:
I'm not a fan that this isn't a simple =use-package= thing, but the
notmuch emacs implementation generally has to match the notmuch
binary - and it's easier to just use whatever my distro packages.
#+begin_src emacs-lisp
  (unless (require 'notmuch nil t)
    (message "Notmuch could not be loaded, should disable sending mail"))
#+end_src
**** Sending mail
     :PROPERTIES:
     :ID:       58944cd4-e6a8-4053-8b9f-b51cd3e8bf34
     :END:
We're just borrowing the gnus settings here..
#+begin_src emacs-lisp
  (setq smtpmail-auth-credentials "~/.authinfo")

  (setq notmuch-fcc-dirs '((".*igneous.*" . "ig/sent")
                           (".*codemac.net.*" . "cm/INBOX.Sent Items")))

#+end_src
The smtpmail-multi-accounts block has a strict ordering. By using ssl
I get to avoid most of the complications. It goes, in order:

1. =smtpmail-smtp-user=
2. =smtpmail-smtp-server=
3. =stmpmail-smtp-service= (port)
4. =mail-specify-envelope-from= (not needed, especially if you're
   using this.
5. =smtpmail-stream-type= (ssl, starttls, or plain. USE SSL if you
   want to live)
6. starttls crap
7. starttls crap
8. =smtpmail-local-domain= (hostname to use as where it's sent from. I
   set this usually to the hostname of the email provider.)
  
#+begin_src emacs-lisp
  (setq smtpmail-multi-accounts '((igneous . ("jeffmickey@igneoussystems.com"
                                              "smtp.gmail.com"
                                              465
                                              nil
                                              ssl
                                              nil
                                              nil
                                              "igneoussystems.com"))
                                  (codemac . ("codemac@fastmail.com"
                                              "mail.messagingengine.com"
                                              465
                                              nil
                                              ssl
                                              nil
                                              nil
                                              "codemac.net"))))

  (setq smtpmail-multi-default-account 'codemac)
  (setq smtpmail-multi-associations '(("jm@igneous.io\\|jeffmickey@igneoussystems.com" igneous)
                                      ("j@codemac.net\\|jeff@archlinux.org\\|jm@vt.edu\\|jmickey@vt.edu" codemac)))

  (setq send-mail-function 'smtpmail-multi-send-it)
  (setq message-send-mail-function 'smtpmail-multi-send-it)

#+end_src
***** queueing
      :PROPERTIES:
      :ID:       f884dff3-0e19-41e1-969b-8911fcc05f68
      :END:
#+begin_src emacs-lisp
  (setq smtpmail-queue-mail  t  ;; start in non-queuing mode
        smtpmail-queue-dir   "~/mail/queue")

  (setq user-full-name "Jeff Mickey")
  (setq user-mail-address "j@codemac.net")

  (setq message-auto-save-directory "~/mail/cm/INBOX.Drafts/cur")
#+end_src
***** Message view
      :PROPERTIES:
      :ID:       609c8599-feea-4606-8444-3a243b306e2c
      :END:
#+begin_src emacs-lisp
  (setq message-citation-line-format "* %f [%Y-%m-%d %H:%M]:")
  (setq message-citation-line-function 'message-insert-formatted-citation-line)

  (defun cm/message-mode-hook ()
    (local-set-key (kbd "C-c M-o") 'org-mime-htmlize)
    (orgstruct-mode 1))
  (add-hook 'message-mode-hook 'cm/message-mode-hook)

  ;; set these to something damn high I hate elided messages 
  (setq notmuch-wash-citation-lines-prefix 1024)
  (setq notmuch-wash-citation-lines-suffix 1024)
  (setq notmuch-wash-signature-lines-max 0)
  (setq notmuch-wash-wrap-lines-length fill-column)
#+end_src
***** Keybindings
      :PROPERTIES:
      :ID:       dd303b47-13d6-48df-bb7f-93a81ac25edc
      :END:
For some reason the ~=~ sign is used for refresh in notmuch. This is
horrifying.
#+begin_src emacs-lisp
  (defun cm/notmuch-archive-unread-all ()
    (interactive)
    (notmuch-search-tag-all '("-inbox" "-unread")))

  (eval-after-load 'notmuch
    '(define-key notmuch-common-keymap "g" 'notmuch-refresh-this-buffer))
  (eval-after-load 'notmuch
    '(define-key notmuch-common-keymap "A" 'cm/notmuch-archive-unread-all))

  (setq notmuch-saved-searches
        '((:name "inbox"         :query "tag:inbox"                 :key "i" :sort-order 'oldest-first)
          (:name "unread"        :query "tag:unread"                :key "u" :sort-order 'newest-first)
          (:name "inbox-igneous" :query "tag:igneous AND tag:inbox" :key "w" :sort-order 'oldest-first)
          (:name "inbox-codemac" :query "tag:codemac AND tag:inbox" :key "c" :sort-order 'oldest-first)))

  (global-set-key (kbd "C-c i") 'notmuch-jump-search)
#+end_src
*** Geiser
    :PROPERTIES:
    :ID:       10f9438e-5499-4cac-8d6f-6fe2ceec10d2
    :END:
Let's get our scheme on!
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.guix-profile/share/emacs/site-lisp")
  (require 'geiser-install)
  ;; racket is great and all, but I need me some ffi, ice-9, and of course, gnu.
  (setq geiser-active-implementations '(guile))
#+end_src
*** Muse
    :PROPERTIES:
    :ID:       33123e64-e792-45bc-8260-9ea8a40ca039
    :END:
Good for person wikis, however I pretty much exclusively use =org-blog=/=org-export= now.
#+begin_src emacs-lisp
  (add-hook 'muse-mode-hook '(lambda ()
                               (footnote-mode 1)
                               (flyspell-mode 1)
                               (auto-fill-mode 1)))
  
  ;; My wiki's!
  (setq muse-project-alist
        '(("Personal Miki" ("~/miki/src" :default "index")
           (:base "html" :path "~/miki/html"))))
#+end_src

*** Org
    :PROPERTIES:
    :ID:       2a2bc3dc-a714-4bd9-adb1-c262ffcd5f62
    :END:
Holy god. Let it begin.
**** Initialize org mode
     :PROPERTIES:
     :ID:       9c315d7c-fa8f-4e3c-843c-a9c37b06486f
     :END:
I add a =*.org= regex to the =auto-mode-alist=, start up org-protocol
so I can use my Firefox bookmark and emacsclient integration, and
org-mouse in case I already have a pointing device. I imagine
=org-mouse= will be more useful when I try and run emacs on a tablet.
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))

  (require 'org-loaddefs)
  (require 'org)
  (require 'org-protocol)
  (require 'org-mouse)
  (require 'org-notmuch)
#+end_src
**** Org Agenda
     :PROPERTIES:
     :ID:       9fdf73e8-52bf-4c3a-b0da-86280d3929fe
     :END:
These are some functions stolen from [[http://sachachua.com/][Sacha Chua]] to make some fun
agenda stuff. The org-agenda-load is especially nice when you use lots
of schedule events, you can figure out just how busy you've really
decided you are.
#+begin_src emacs-lisp  
  (defun sacha/org-agenda-load (match)
    "Can be included in `org-agenda-custom-commands'."
    (let ((inhibit-read-only t)
          (time (sacha/org-calculate-free-time
                 ;; today
                 (calendar-gregorian-from-absolute org-starting-day)
                 ;; now if today, else start of day
                 (if (= org-starting-day
                        (time-to-days (current-time)))
                     (let* ((now (decode-time))
                            (cur-hour (nth 2 now))
                            (cur-min (nth 1 now)))
                       (+ (* cur-hour 60) cur-min))
                   (let ((start (car (elt org-agenda-time-grid 2))))
                     (+ (* (/ start 100) 60) (% start 100))))
                   ;; until the last time in my time grid
                 (let ((last (car (last (elt org-agenda-time-grid 2)))))
                   (+ (* (/ last 100) 60) (% last 100))))))
      (goto-char (point-max))
      (insert (format
               "%.1f%% load: %d minutes scheduled, %d minutes to be scheduled, %d minutes free, %d minutes gap - %.1f total work hours planned\n"
               (/ (elt time 1) (* .01 (elt time 2)))
               (elt time 0)
               (elt time 1)
               (elt time 2)
               (- (elt time 2) (elt time 1))
               (/ (+ (elt time 0) (elt time 1)) 60)
               ))))
  
  (defun sacha/org-calculate-free-time (date start-time end-of-day)
    "Return a cons cell of the form (TASK-TIME . FREE-TIME) for DATE, given START-TIME and END-OF-DAY.
  DATE is a list of the form (MONTH DAY YEAR).
  START-TIME and END-OF-DAY are the number of minutes past midnight."
    (save-window-excursion
    (let ((files org-agenda-files)
          (total-unscheduled 0)
          (total-gap 0)
          file
          rtn
          rtnall
          entry
          (total-scheduled 0)
          (last-timestamp start-time)
          scheduled-entries)
      (while (setq file (car files))
        (catch 'nextfile
          (org-check-agenda-file file)
          (setq rtn (org-agenda-get-day-entries file date :scheduled :timestamp))
          (setq rtnall (append rtnall rtn)))
        (setq files (cdr files)))
      ;; For each item on the list
      (while (setq entry (car rtnall))
        (let ((time (get-text-property 1 'time entry)))
          (cond
           ((and time (string-match "\\([^-]+\\)-\\([^-]+\\)" time))
            (setq scheduled-entries
                  (cons
                   (cons
                    (save-match-data (org-matcher-time (match-string 1 time)))
                    (save-match-data (org-matcher-time (match-string 2 time))))
                   scheduled-entries)))
           ((and
             time
             (string-match "\\([^-]+\\)\\.+" time)
             (string-match "^[A-Z]+ \\(\\[#[A-Z]\\] \\)?\\([0-9]+\\)"
                           (get-text-property 1 'txt entry)))
            (setq scheduled-entries
                  (let ((start (and (string-match "\\([^-]+\\)\\.+" time)
                                    (appt-convert-time (match-string 1 time)))))
                    (cons
                     (cons start
                           (and (string-match
                                 "^[A-Z]+ \\(\\[#[A-Z]\\] \\)?\\([0-9]+\\) "
                                 (get-text-property 1 'txt entry))
                                (+ start
                                   (string-to-number
                                    (match-string
                                     2
                                     (get-text-property 1 'txt entry))))))
                          scheduled-entries))))
           ((and
             (get-text-property 1 'txt entry)
             (string-match "^[A-Z]+ \\(\\[#[A-Z]\\] \\)?\\([0-9]+\\)"
                           (get-text-property 1 'txt entry)))
            (setq total-unscheduled
                  (+ (string-to-number
                      (match-string 2 (get-text-property 1 'txt entry)))
                     total-unscheduled)))))
        (setq rtnall (cdr rtnall)))
      ;; Sort the scheduled entries by time
      (setq scheduled-entries
            (sort scheduled-entries (lambda (a b) (< (car a) (car b)))))
  
      (while scheduled-entries
        (let ((start (car (car scheduled-entries)))
              (end (cdr (car scheduled-entries))))
        (cond
         ;; are we in the middle of this timeslot?
         ((and (>= last-timestamp start)
               (<= last-timestamp end))
          ;; move timestamp later, no change to time
          (setq total-scheduled (+ total-scheduled (- end last-timestamp)))
          (setq last-timestamp end))
         ;; are we completely before this timeslot?
         ((< last-timestamp start)
          ;; add gap to total, skip to the end
          (setq total-gap (+ (- start last-timestamp) total-gap))
          (setq total-scheduled (+ total-scheduled (- end start)))
          (setq last-timestamp end)))
        (setq scheduled-entries (cdr scheduled-entries))))
      (if (< last-timestamp end-of-day)
          (setq total-gap (+ (- end-of-day last-timestamp) total-gap)))
      (list total-scheduled total-unscheduled total-gap))))
#+end_src
**** Org Clock
     :PROPERTIES:
     :ID:       fbb22f25-0f77-44c8-ab44-47187909d25a
     :END:
This adds automatic task clocking. It's incredibly useful to figure
out how long tasks took that you start and stop.
#+begin_src emacs-lisp  
  (defun org-clock-in-if-starting ()
    "Clock in when the task is marked STARTED."
    (when (and (string= org-state "STARTED")
               (not (string= org-last-state org-state)))
      (org-clock-in)))
  
  (defadvice org-clock-in (after sacha activate)
    "Set this task's status to 'STARTED'."
    (org-todo "STARTED"))
  
  (defun org-clock-out-if-waiting ()
    "Clock in when the task is marked STARTED."
    (when (and (string= org-state "WAITING")
               (not (string= org-last-state org-state)))
      (org-clock-out)))
  
  (defun org-clock-out-if-started-todo ()
    (when (and (or (string= org-state "TODO")
                   (string= org-state "NEXT"))
               (string= org-last-state "STARTED"))
      (if (org-clocking-p)
          (org-clock-out))))
  
  (add-hook 'org-after-todo-state-change-hook 'org-clock-in-if-starting)
  (add-hook 'org-after-todo-state-change-hook 'org-clock-out-if-waiting)
  (add-hook 'org-after-todo-state-change-hook 'org-clock-out-if-started-todo)
#+end_src

Functions borrowed from Sacha Chua.
#+begin_src emacs-lisp  
  (defun sacha/org-agenda-clock (match)
    ;; Find out when today is
    (let* ((inhibit-read-only t))
      (goto-char (point-max))
      (org-dblock-write:clocktable
       `(:scope agenda
         :maxlevel 4
         :tstart ,(format-time-string "%Y-%m-%d" (calendar-time-from-absolute (1+ org-starting-day) 0))
         :tend ,(format-time-string "%Y-%m-%d" (calendar-time-from-absolute (+ org-starting-day 2) 0))))))
  
  (defvar org-my-archive-expiry-days 7
    "The number of days after which a completed task should be auto-archived.
  This can be 0 for immediate, or a floating point value.")
  
  (defun org-my-archive-done-tasks ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (let ((done-regexp
             (concat "\\* \\(" (regexp-opt org-done-keywords) "\\) "))
            (state-regexp
             (concat "- State \"\\(" (regexp-opt org-done-keywords)
                     "\\)\"\\s-*\\[\\([^]\n]+\\)\\]")))
        (while (re-search-forward done-regexp nil t)
          (let ((end (save-excursion
                       (outline-next-heading)
                       (point)))
                begin)
            (goto-char (line-beginning-position))
            (setq begin (point))
            (if (re-search-forward state-regexp end t)
                (let* ((time-string (match-string 2))
                       (when-closed (org-parse-time-string time-string)))
                  (if (>= (time-to-number-of-days
                           (time-subtract (current-time)
                                          (apply #'encode-time when-closed)))
                          org-my-archive-expiry-days)
                      (org-archive-subtree)))
              (goto-char end)))))
      (save-buffer)))
#+end_src

**** Run an auto archiving script after saves. *This currently does not work!*
     :PROPERTIES:
     :ID:       3f3818a7-f12d-4a2c-9ac2-9c2f527b5ca8
     :END:
#+begin_src emacs-lisp  
  (setq safe-local-variable-values (quote ((after-save-hook archive-done-tasks))))
  
  (defalias 'archive-done-tasks 'org-my-archive-done-tasks)
#+end_src
**** Receipt Agenda
     :PROPERTIES:
     :ID:       86b9b44b-96cd-47c3-8fd5-3086cb77c05b
     :END:
#+begin_src emacs-lisp
  (defun org-receipt-agenda (match)
    (setq org-agenda-include-all-todo nil
                  org-agenda-ndays 7
                  org-agenda-show-all-dates t
                  )
    (org-agenda-list)
    )
#+end_src
**** Custom agendas
     :PROPERTIES:
     :ID:       16aafc16-4240-4a4a-98f6-92186bc07d14
     :END:
#+begin_src emacs-lisp  
  (defun my-agenda-sort-by-inactive-timestamp (a b)
    "Sort by interactive timestamp. Oldest first, items without any ts at the bottom."
    (let* ((ma (or (get-text-property 1 'org-marker a)
                   (get-text-property 1 'org-hd-marker a)))
           (mb (or (get-text-property 1 'org-marker b)
                   (get-text-property 1 'org-hd-marker b)))
           (tsa (org-entry-get ma "TIMESTAMP_IA"))
           (tsb (org-entry-get mb "TIMESTAMP_IA"))
           (ta (when tsa (date-to-time tsa)))
           (tb (when tsb (date-to-time tsb))))
      (cond ((eq tsa nil) +1)
            ((eq tsb nil) -1)
            ((time-less-p ta tb)
             -1)
            ((time-less-p tb ta)
             +1)
            (t nil))))

  (setq org-agenda-custom-commands
        '(("d" "Full Day Agenda"
           ((agenda)
            (tags "PROJECT/!WAITING" ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
                                      (org-agenda-sorting-strategy '(user-defined-up))))
            (todo "WAITING" ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
                             (org-agenda-sorting-strategy '(user-defined-up))))
            (tags-todo "-MAYBE-BLOCKED=\"t\"" ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
                                               (org-agenda-sorting-strategy '(user-defined-up))))))
          ("i" "Inbox"
           ((tags-todo "-{.*}")))
          ("n" "Next agenda"
           ((todo "WAITING")
            (todo "NEXT")
            (todo "STARTED"))
           ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
            (org-agenda-sorting-strategy '(user-defined-up))))
          ("v" "INTERNET agenda"
           ((tags-todo "INTERNET-BLOCKED=\"t\"/!-WAITING"))
           ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
            (org-agenda-sorting-strategy '(user-defined-up))))
          ("c" "COMPUTER agenda"
           ((tags-todo "COMPUTER-BLOCKED=\"t\"/!-WAITING"))
           ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
            (org-agenda-sorting-strategy '(user-defined-up))))
          ("w" "Work Agenda"
           ((tags-todo "WORK-BLOCKED=\"t\"/!-WAITING")
            (tags "WORK+PROJECT")
            (tags "WORK"))
           ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
            (org-agenda-sorting-strategy '(user-defined-up))))
          ("h" "Home Agenda"
           ((tags-todo "HOME-BLOCKED=\"t\"/!-WAITING")
            (tags "HOME+PROJECT")
            (tags "HOME"))
           ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
            (org-agenda-sorting-strategy '(user-defined-up))))
          ("r" "Errand Agenda"
           ((tags-todo "ERRAND-BLOCKED=\"t\"/!-WAITING")
            (tags "ERRAND+PROJECT")
            (tags "ERRAND"))
           ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
            (org-agenda-sorting-strategy '(user-defined-up))))
          ("p" "Phone Agenda"
           ((tags-todo "PHONE-BLOCKED=\"t\"/!-WAITING")
            (tags "PHONE+PROJECT")
            (tags "PHONE"))
           ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
            (org-agenda-sorting-strategy '(user-defined-up))))
          ("o" "Project Agenda"
           ((tags-todo "PROJECT/!-WAITING")
            (tags "PROJECT"))
           ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
            (org-agenda-sorting-strategy '(user-defined-up))))
          ("l" "People Agenda"
           ((todo "-ERRAND-HOME-INTERNET-PROJECT-COMPUTER-PHONE"))
           ((org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
            (org-agenda-sorting-strategy '(user-defined-up))))
          ("x" "Tasks" ((tags-todo "-BLOCKED=\"t\""
                                   ((org-agenda-overriding-header "Tasks sorted by TIMESTAMP_IA")
                                    (org-agenda-cmp-user-defined 'my-agenda-sort-by-inactive-timestamp)
                                    (org-agenda-sorting-strategy '(user-defined-up))))))
          ("Z" "Receipt Agenda"
           ((org-receipt-agenda)))))
#+end_src
**** Useful setq's
     :PROPERTIES:
     :ID:       8bb80482-a3c3-4e9b-bc23-27fdfdf4d14c
     :END:
#+begin_src emacs-lisp  
  (setq org-stuck-projects
            '("-MAYBE-DONE" "TODO"))

  (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
  (setq org-return-follows-link t)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (setq org-fontify-done-headline t)
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)
  (setq org-clock-idle-time 10)

  (setq org-default-notes-files '("~/org/_notes/notes.org"))
  (setq org-agenda-files '("~/org/" "~/org/_notes/"))
  (setq org-refile-targets '((nil :maxlevel . 5) (org-agenda-files :maxlevel . 5)))

  (setq org-agenda-tags-column -90)
  (setq org-tags-column -90)

  (setq org-log-done t)
  (setq org-hide-leading-stars t)
  (setq org-return-follows-link t)
  (setq org-agenda-include-all-todo t)
  (setq org-agenda-ndays 7)
  (setq org-agenda-include-diary t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-start-on-weekday nil)
  ;(setq org-completion-use-ido t)
  (setq org-agenda-show-all-dates t)
  (setq org-reverse-note-order nil)
  (setq org-fontify-done-headline t)
  (setq org-special-ctrl-k t)
  (setq org-special-ctrl-a/e t)
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-enforce-todo-dependencies t)
  (setq org-outline-path-complete-in-steps nil) ;ido lol
  (setq org-refile-use-outline-path 'file)
  (setq org-use-speed-commands t)
  ;; less file local settings!
  (setq org-archive-location "_archive/%s_old::")
  (setq org-global-properties '(("Effort_ALL" . "0:10 0:20 0:30 0:40 0:50 1:00 2:00 3:00 4:00 5:00 6:00 7:00 8:00 9:00 10:00 11:00 12:00")))
  (setq org-columns-default-format "%TODO %50ITEM(Task) %17Effort(Estimated Effort){:} %CLOCKSUM")

  (global-set-key (kbd "<f6>") 'org-clock-goto)
#+end_src
**** Tags and todo keywords
     :PROPERTIES:
     :ID:       49034a34-2766-4962-bd53-676f2d108704
     :END:
#+begin_src emacs-lisp
  (setq org-tag-alist '((:startgroup)
                        ("HOME" . ?h)
                        ("WORK" . ?w)
                        ("ERRAND" . ?r)
                        (:endgroup)
                        ("COMPUTER" . ?c)
                        ("INTERNET" . ?i)
                        ("PHONE" . ?p)
                        ("EMAIL" . ?m)
                        ("OUTREACH" . ?h)
                        ("DISPATCH" . ?d)
                        ("PROJECT" . ?o)))
  
  (setq org-log-done '(note))
  (setq org-log-into-drawer t) ; record state changes into LOGBOOK
  (setq org-todo-keywords
        '((sequence "TODO(t@)" "NEXT(n!)" "STARTED(s)" "WAITING(w@)" "|" "DONE(d@)" "NVM(v@)" "MAYBE(m@)")))
  (setq org-tags-exclude-from-inheritance '("PROJECT"))
  ;(setq org-agenda-category-icon-alist
  ;      '(("netapp" "" nil t)
#+end_src
**** org export
     :PROPERTIES:
     :ID:       8eedeae4-7a30-4dfe-94ff-93827481d847
     :END:
#+begin_src emacs-lisp
  (require 'pandoc-mode)
  ;; mediawiki + pandoc hack
  (setq pandoc-binary "/Users/jmickey/bin/pandoc")
  
  (defun cm/org-export-as-pandoc ()
    (interactive)
    (org-export-as-html 3 nil "*Org HTML Export*" t nil)
    (with-current-buffer "*Org HTML Export*"
      (pandoc-mode 1)
      (pandoc-set-write "mediawiki")
      (pandoc-run-pandoc nil)
      (pandoc-view-output)))
  
  (setq org-export-with-sub-superscripts nil)
  (setq org-pretty-entities-include-sub-superscripts nil)
  (setq org-use-sub-superscripts nil)
  
  ;(org-babel-load-file (expand-file-name
  ;                      "org-docco.org"
  ;                      (expand-file-name
  ;                       "scripts"
  ;                       (expand-file-name
  ;                        "contrib"
  ;                        (expand-file-name
  ;                         "org-src"
  ;                         dotfiles-dir)))))
#+end_src
**** org babel & export
     :PROPERTIES:
     :ID:       f6ce34e2-98fe-4916-aead-07bd1e3d1a1f
     :END:
#+begin_src emacs-lisp  
  (if cm/using-rc
      (setq org-babel-default-header-args:ditaa '((:results . "file")
                                                  (:exports . "results")
                                                  (:java . "'-Dfile.encoding=UTF-8'"))))
  (setq org-ditaa-jar-path "/usr/share/java/ditaa/ditaa-0_9.jar")
  (setq org-plantuml-jar-path plantuml-jar-path)
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)

  (org-babel-do-load-languages 
   'org-babel-load-languages
   `((emacs-lisp . t)
     (C . t)
     (R . t)
     (clojure . t)
     (ditaa . t)
     (dot . t)
     (gnuplot . t)
     (haskell . t)
     (latex . t)
     (ledger . t)
     (lisp . t)
     (org . t)
     (perl . t)
     (plantuml . t)
     (python . t)
     (ruby . t)
     (scheme . t)
     (sh . t)
     (sql .t)))
  (setq org-confirm-babel-evaluate t)  ; nah, let's be safe

  (autoload 'org-mime-org-buffer-htmlize "org-mime" "org-mime-org-buffer-htmlize" t nil)
  (defun cm/org-mime-send-buffer-hook ()
    (defun org-export-grab-title-from-buffer ()
      ""
      "!! replace me !!"))

  (add-hook 'org-mime-send-buffer-hook 'cm/org-mime-send-buffer-hook)
#+end_src
**** Publishing
     :PROPERTIES:
     :ID:       338bb160-77e1-4a63-ab6c-c80aab220da8
     :END:
How I deploy my personal website.
#+begin_src emacs-lisp
  ;; Inline images in HTML instead of producting links to the image
  (setq org-export-html-inline-images t)

  ;; Use org.css from the norang website for export document stylesheets
  ;(setq org-export-html-style-extra "<link rel=\"stylesheet\" href=\"http://doc.norang.ca/org.css\" type=\"text/css\" />")
  ;(setq org-export-html-style-include-default nil)

  ;; Do not generate internal css formatting for HTML exports
  (setq org-export-htmlize-output-type nil)
  ;; Export with LaTeX fragments
  (setq org-export-with-LaTeX-fragments t)

  ;; List of projects
  ;; - codemac.net -- My personal website
  ;; - org-doc -- export all org documents
  (setq org-publish-project-alist
        '(("codemac-org"
           :base-directory "~/org/_www/codemac.net"
           :publishing-directory "/tmp/codemac.net"
           :recursive t
           :base-extension "org"
           :publishing-function org-html-publish-to-html
           :exclude-tags ("noexport" "todo")
           :html-preamble ""
           :html-postamble ""
           :style nil
           :section-numbers nil
           :style-include-default nil
           :auto-sitemap t
           :sitemap-filename "sitemap.html")
          ("codemac-static"
           :base-directory "~/org/_www/codemac.net"
           :publishing-directory "/tmp/codemac.net"
           :base-extension "css\\|pdf\\|png\\|jpg\\|gif\\|js\\|txt\\|mp3\\|ogg\\|swf"
           :publishing-function org-publish-attachment
           :recursive t)
          ("codemac" :components ("codemac-org" "codemac-static"))
          ("org-doc-org"
           :base-directory "~/org/"
           :publishing-directory "/tmp/published-org"
           :recursive t
           :section-numbers nil
           :table-of-contents nil
           :base-extension "org"
           :publishing-function (org-html-publish-to-html org-org-publish-to-org)
           :plain-source t
           :htmlized-source t
           :style-include-default nil
           :style "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
           :auto-sitemap t
           :sitemap-filename "index.html"
           :sitemap-title "Test Publishing Area"
           :sitemap-style "tree"
           :author-info nil
           :creator-info nil)
          ("org-doc-static"
           :base-directory "~/org/"
           :publishing-directory "/tmp/published-org"
           :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
           :publishing-function org-publish-attachment
           :recursive t
           :author nil)
          ("org-doc" :components ("org-doc-org" "org-doc-static"))))

  (defun org-save-then-publish ()
    (interactive)
    (save-buffer)
    (org-save-all-org-buffers)
    (org-publish-current-project))
#+end_src
**** Misc Funcs
     :PROPERTIES:
     :ID:       ef5ab78f-e0b9-4e28-b1b1-256a1253ec39
     :END:
#+begin_src emacs-lisp
    (defun org-insert-datetime ()
      (interactive)
      (insert (format-time-string "%Y-%m-%d %a %H:%M %z")))
#+end_src
**** Link Types
     :PROPERTIES:
     :ID:       dab4061f-b05e-4689-ba82-82ab90ce1d69
     :END:
#+begin_src emacs-lisp
  ;; org links!
  (org-add-link-type "man" 'org-man-open)
  (add-hook 'org-store-link-functions 'org-man-store-link)

  (defcustom org-man-command 'man
    "The Emacs command to be used to display a man page."
    :group 'org-link
    :type '(choice (const man) (const woman)))

  (defun org-man-open (path)
    "Visit the manpage on PATH.
       PATH should be a topic that can be thrown at the man command."
    (funcall org-man-command path))

  (defun org-man-store-link ()
    "Store a link to a manpage."
         (when (memq major-mode '(Man-mode woman-mode))
           ;; This is a man page, we do make this link
           (let* ((page (org-man-get-page-name))
                  (link (concat "man:" page))
                  (description (format "Manpage for %s" page)))
             (org-store-link-props
              :type "man"
              :link link
              :description description))))

  (defun org-man-get-page-name ()
    "Extract the page name from the buffer name."
    ;; This works for both `Man-mode' and `woman-mode'.
    (if (string-match " \\(\\S-+\\)\\*" (buffer-name))
        (match-string 1 (buffer-name))
      (error "Cannot create link to this man page")))

  ;; cisco links
  (defun org-link-type-cisco-open (path)
    "path is the userid"
    (shell-command (concat "open \"http://wwwin-tools.cisco.com/dir/details/" path "\"")))

  (org-add-link-type "cisco" 'org-link-type-cisco-open)

  (defun org-link-type-websec-open (path)
    "path is the jira number"
    (shell-command (concat "open \"https://jira.ironport.com/browse/WEBSEC-" path "\"")))
  (org-add-link-type "websec" 'org-link-type-websec-open)

  (defun org-link-type-sas-open (path)
    "path is the jira number"
    (shell-command (concat "open \"https://jira.ironport.com/browse/ENGSAS-" path "\"")))
  (org-add-link-type "engsas" 'org-link-type-sas-open)

  (defun org-link-type-netapp-open (path)
    "path is username"
    (shell-command (concat "open \"http://burtweb-prd.eng.netapp.com/burt/burt-bin/profile?user=" path "\"")))
  (org-add-link-type "netapp" 'org-link-type-netapp-open)

  ;; capture for mac os x popup
  (defun cm/org-capture-other-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "Org-Capture")
                  (width . 120)
                  (height . 20)
                  (menu-bar-lines . 0)
                  (tool-bar-lines . 0)
                  (auto-lower . nil)
                  (auto-raise . t)))
    (select-frame-by-name "Org-Capture")
    (if (condition-case nil
            (progn (org-capture) t)
          (error nil))
        (delete-other-windows)
      (cm/org-capture-other-frame-cleanup)))

  (defun cm/org-capture-other-frame-cleanup ()
    "Close the Org-Capture frame."
    (if (equal "Org-Capture" (frame-parameter nil 'name))
        (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook 'cm/org-capture-other-frame-cleanup)
#+end_src
**** Org Capture
     :PROPERTIES:
     :ID:       47a9dc31-f51e-4ee3-b06f-44848cbe9a04
     :END:
#+begin_src emacs-lisp
  ;; org capture!
  (setq org-directory "~/org")
  (setq org-default-notes-file (concat org-directory "/gtd.org"))
  (define-key global-map "\C-cr" 'org-capture)
  (setq org-capture-templates
        `(("t" "Todo" entry (file+headline "~/org/gtd.org" "Inbox") "* TODO %?\n  %U\n  %i\n  %a" :prepend t)
          ("j" "Journal" entry (file ,(format-time-string "~/org/_editorial/%Y.%m.org")) "* %U %?\n\n  %i\n  %a" :prepend nil)
          ("c" "Add note to currently clocked task" entry (clock) "* %U %?\n%a\n\n%i")
          ("n" "Timed Notes" entry (file ,(format-time-string "~/org/_notes/%Y.org")) "* %U %?\n\n  %i\n  %a" :prepend nil)
          ("w" "Work capture" entry (file "~/org/igneous.org") "* %U %?\n\n  %i\n  %a" :prepend nil)
          ("l" "Life Fitness" table-line (file+headline "~/org/fitness.org" "Fitness") ,(concat (format-time-string "| %Y.%m.%d-%H:%M |") " %^{Weight} | | %^{RHR} |") :table-line-pos "II-1")
          ("x" "org-capture" entry (file+headline "~/org/_notes/www.org" "Archived Content") "* %^{Title}p: %:description\n\n  Source: %U %c\n\n  %i")))
  
  (defun gtd ()
    (interactive)
    (find-file "~/org/gtd.org"))
  
  ;; Set up my diary file
  (setq diary-file "~/org/diary") ;; deal with the fact that it's in the org folder
  
  ;;
  
  (setq org-src-fontify-natively nil)
#+end_src

Also - remember to give everything an id number. This will really help
any of my plans to get org mode todos into easier to consume formats.
#+begin_src emacs-lisp
(add-hook 'org-capture-prepare-finalize-hook 'org-id-get-create)
#+end_src

Finally, before I save a file, add the id's! This is way too much, so
I've commented it out for now
#+begin_src emacs-lisp
  (defun cm/org-add-ids-to-headlines-in-file ()
    "Add ID properties to all headlines in the current file which
  do not already have one."
    (interactive)
     ;;(org-map-entries 'org-id-get-create))
    )

  (add-hook 'org-mode-hook
            (lambda ()
              (add-hook 'before-save-hook 'cm/org-add-ids-to-headlines-in-file nil 'local)))
#+end_src

**** Appt Reminders
     :PROPERTIES:
     :ID:       ac746ebc-a17c-443d-9430-876cd1330c57
     :END:
This creates the appt buffer so we get notifications about
appointments in the org mode calendar. It's not perfect, but it does
help with my forgetfulness.

#+begin_src emacs-lisp
  (appt-activate)
  (org-agenda-to-appt)
#+end_src
*** W3M
    :PROPERTIES:
    :ID:       79e3e87f-f769-4325-ac15-450572f79a6a
    :END:
#+begin_src emacs-lisp
  (autoload 'w3m-browse-url "w3m-load" "" t)
#+end_src
*** RCIRC
    :PROPERTIES:
    :ID:       63cf268e-8426-426f-a6fe-62492899d659
    :END:
#+begin_src emacs-lisp
  ; (eval-after-load 'rcirc '(require 'rcirc-color))
  ; (require 'rcirc)
  ; ;; colors!
  ; 
  ; 
  ; (add-hook 'rcirc-markup-colors 'rcirc-markup-text-functions)
  ; 
  ; (defvar rcirc-color-vector ["black" "red" "green" "yellow" "blue" "magenta" "cyan" "white"]
  ;   "Vector of color names for the numbers 0-7.")
  ; 
  ; (defun rcirc-markup-colors (process sender response channel-buffer)
  ;   (while (re-search-forward "\C-c\\([0-7]\\)\\(.*?\\)\C-c" nil t)
  ;     (rcirc-add-face (match-beginning 0) (match-end 0)
  ;                     (cons 'foreground-color
  ;                           (aref rcirc-color-vector (string-to-number (match-string 1)))))
  ;     ;; start deleting at the end
  ;     (delete-region (1- (match-end 0)) (match-end 0))
  ;     (delete-region (match-beginning 0) (match-end 1))))
  ; 
  ; ;; Turn on logging everything to a special buffer, for debugging.
  ; ;(setq rcirc-debug-flag t)
  ; ;; scroll as little as possible
  ; (add-hook 'rcirc-mode-hook
  ;           (lambda ()
  ;             (set
  ;              (make-local-variable 'scroll-conservatively)
  ;              8192)))
  ; 
  ; ;; add reconnect
  ; (eval-after-load 'rcirc
  ;   '(defun-rcirc-command reconnect (arg)
  ;      "Reconnect the server process."
  ;      (interactive "i")
  ;      (unless process
  ;        (error "There's no process for this target"))
  ;      (let* ((server (car (process-contact process)))
  ;             (port (process-contact process :service))
  ;             (nick (rcirc-nick process))
  ;             channels query-buffers)
  ;        (dolist (buf (buffer-list))
  ;          (with-current-buffer buf
  ;            (when (eq process (rcirc-buffer-process))
  ;              (remove-hook 'change-major-mode-hook
  ;                           'rcirc-change-major-mode-hook)
  ;              (if (rcirc-channel-p rcirc-target)
  ;                  (setq channels (cons rcirc-target channels))
  ;                (setq query-buffers (cons buf query-buffers))))))
  ;        (delete-process process)
  ;        (rcirc-connect server port nick
  ;                       rcirc-default-user-name
  ;                       rcirc-default-full-name
  ;                       channels))))

#+end_src
This means that the format of the join command no longer supports
space separated channels - however - does now support keyed/passworded
channels correctly. The format is: =#channela,#channelb ,passwordb=
#+begin_src emacs-lisp
  ; (eval-after-load 'rcirc
  ;   '(defun-rcirc-command join (channels)
  ;      "Join CHANNELS.
  ; CHANNELS is a comma- or space-separated string of channel names."
  ;      (interactive "sJoin channels: ")
  ;      (let* ((chanpass (split-string channels " " t))
  ;             (split-channels (split-string (car chanpass) "," t))
  ;             (buffers (mapcar (lambda (ch)
  ;                                (rcirc-get-buffer-create process ch))
  ;                              split-channels)))
  ;        (rcirc-send-string process (concat "JOIN " channels))
  ;        (when (not (eq (selected-window) (minibuffer-window)))
  ;          (dolist (b buffers) ;; order the new channel buffers in the buffer list
  ;            (switch-to-buffer b))))))
  ; 
  ; (eval-after-load 'rcirc
  ;   '(defun rcirc (arg)
  ;      "Connect to all servers in `rcirc-server-alist'.
  ; 
  ; Do not connect to a server if it is already connected.
  ; 
  ; If ARG is non-nil, instead prompt for connection parameters."
  ;      (interactive "P")
  ;      (if arg
  ;          (let* ((server (completing-read "IRC Server: "
  ;                                          rcirc-server-alist
  ;                                          nil nil
  ;                                          (caar rcirc-server-alist)
  ;                                          'rcirc-server-name-history))
  ;                 (server-plist (cdr (assoc-string server rcirc-server-alist)))
  ;                 (port (read-string "IRC Port: "
  ;                                    (number-to-string
  ;                                     (or (plist-get server-plist :port)
  ;                                         rcirc-default-port))
  ;                                    'rcirc-server-port-history))
  ;                 (nick (read-string "IRC Nick: "
  ;                                    (or (plist-get server-plist :nick)
  ;                                        rcirc-default-nick)
  ;                                    'rcirc-nick-name-history))
  ;                 (user-name (read-string "IRC Username: "
  ;                                         (or (plist-get server-plist :user-name)
  ;                                             rcirc-default-user-name)
  ;                                         'rcirc-user-name-history))
  ;                 (password (read-passwd "IRC Password: " nil
  ;                                        (plist-get server-plist :password)))
  ;                 (channels (read-string "IRC Channels: "
  ;                                        (plist-get server-plist :channels)))
  ;                 (encryption (rcirc-prompt-for-encryption server-plist)))
  ;            (rcirc-connect server port nick user-name
  ;                        rcirc-default-full-name
  ;                        channels password encryption))
  ;        ;; connect to servers in `rcirc-server-alist'
  ;        (let (connected-servers)
  ;       (dolist (c rcirc-server-alist)
  ;         (let ((server (car c))
  ;               (nick (or (plist-get (cdr c) :nick) rcirc-default-nick))
  ;               (port (or (plist-get (cdr c) :port) rcirc-default-port))
  ;               (user-name (or (plist-get (cdr c) :user-name)
  ;                              rcirc-default-user-name))
  ;               (full-name (or (plist-get (cdr c) :full-name)
  ;                              rcirc-default-full-name))
  ;               (channels (plist-get (cdr c) :channels))
  ;               (password (plist-get (cdr c) :password))
  ;               (encryption (plist-get (cdr c) :encryption))
  ;               contact)
  ;           (when server
  ;             (let (connected)
  ;               (dolist (p (rcirc-process-list))
  ;                 (when (string= server (process-name p))
  ;                   (setq connected p)))
  ;               (if (not connected)
  ;                   (condition-case e
  ;                       (rcirc-connect server port nick user-name
  ;                                      full-name channels password encryption)
  ;                     (quit (message "Quit connecting to %s" server)))
  ;                 (with-current-buffer (process-buffer connected)
  ;                   (setq contact (process-contact
  ;                                  (get-buffer-process (current-buffer)) :host))
  ;                   (setq connected-servers
  ;                         (cons (if (stringp contact) contact server)
  ;                               connected-servers))))))))
  ;       (when connected-servers
  ;         (message "Already connected to %s"
  ;                  (if (cdr connected-servers)
  ;                      (concat (mapconcat 'identity (butlast connected-servers) ", ")
  ;                              ", and "
  ;                              (car (last connected-servers)))
  ;                    (car connected-servers))))))))

#+end_src

#+begin_src emacs-lisp
  ; (setq rcirc-default-nick "codemac")
  ; (setq rcirc-default-user-name "codemac")
  ; (setq rcirc-default-user-full-name "codemac")
  ; 
  ; (setq rcirc-server-alist cm/rcirc-server-alist)
  ; (setq rcirc-authinfo cm/rcirc-authinfo)
  ; (setq rcirc-startup-channels-alist '(("\\.freenode\\.net$" "#emacs")))
  ; 
  ; ;  (setq rcirc-time-format "%H:%M ") ; << that format suckts, nvm.
#+end_src
**** Reconnect
     :PROPERTIES:
     :ID:       3eab2e32-f8ff-4dba-a3c2-fe0c198c21b2
     :END:
#+begin_src emacs-lisp
  ; (defun-rcirc-command reconnect (arg)
  ;   "Reconnect the server process."
  ;   (interactive "i")
  ;   (if (buffer-live-p rcirc-server-buffer)
  ;       (with-current-buffer rcirc-server-buffer
  ;         (let ((reconnect-buffer (current-buffer))
  ;               (server (or rcirc-server rcirc-default-server))
  ;               (port (if (boundp 'rcirc-port) rcirc-port rcirc-default-port))
  ;               (nick (or rcirc-nick rcirc-default-nick))
  ;               channels)
  ;           (dolist (buf (buffer-list))
  ;             (with-current-buffer buf
  ;               (when (equal reconnect-buffer rcirc-server-buffer)
  ;                 (remove-hook 'change-major-mode-hook
  ;                              'rcirc-change-major-mode-hook)
  ;                 (let ((server-plist (cdr (assoc-string server rcirc-server-alist)))) 
  ;                   (when server-plist 
  ;                     (setq channels (plist-get server-plist :channels)))))))
  ;           (if process (delete-process process))
  ;           (rcirc-connect server port nick rcirc-default-user-name rcirc-default-full-name channels)))))
  ; 
  ; ;;; Attempt reconnection at increasing intervals when a connection is
  ; ;;; lost.
  ; 
  ; (defvar rcirc-reconnect-attempts 0)
  ; 
  ; ;;;###autoload
  ; (define-minor-mode rcirc-reconnect-mode
  ;   nil nil " Reconnect" nil
  ;   (if rcirc-reconnect-mode
  ;       (progn
  ;         (make-local-variable 'rcirc-reconnect-attempts)
  ;         (add-hook 'rcirc-sentinel-hooks
  ;                   'rcirc-reconnect-schedule nil t))
  ;     (remove-hook 'rcirc-sentinel-hooks
  ;                  'rcirc-reconnect-schedule t)))
  ; 
  ; (defun rcirc-reconnect-schedule (process &optional sentinel seconds)
  ;   (condition-case err
  ;       (when (and (eq 'closed (process-status process))
  ;                  (buffer-live-p (process-buffer process)))
  ;         (with-rcirc-process-buffer process
  ;           (unless seconds
  ;             (setq seconds (exp (1+ rcirc-reconnect-attempts))))
  ;           (rcirc-print
  ;            process "my-rcirc.el" "ERROR" rcirc-target
  ;            (format "scheduling reconnection attempt in %s second(s)." seconds) t)
  ;           (run-with-timer seconds nil 'rcirc-reconnect-perform-reconnect process)))
  ;     (error (rcirc-print process "RCIRC" "ERROR" nil
  ;                         (format "%S" err) t))))
  ; 
  ; (defun rcirc-reconnect-perform-reconnect (process)
  ;   (when (and (eq 'closed (process-status process))
  ;              (buffer-live-p (process-buffer process)))
  ;     (with-rcirc-process-buffer process
  ;       (when rcirc-reconnect-mode
  ;         (if (get-buffer-process (process-buffer process))
  ;             ;; user reconnected manually
  ;             (setq rcirc-reconnect-attempts 0)
  ;           (let ((msg (format "attempting reconnect to %s..."
  ;                              (process-name process))))
  ;             (rcirc-print process "my-rcirc.el" "ERROR" rcirc-target
  ;                          msg t))
  ;           ;; remove the prompt from buffers
  ;           (condition-case err
  ;               (progn
  ;                 (save-window-excursion
  ;                   (save-excursion
  ;                     (rcirc-cmd-reconnect nil)))
  ;                 (setq rcirc-reconnect-attempts 0))
  ;             ((quit error)
  ;              (incf rcirc-reconnect-attempts)
  ;              (rcirc-print process "my-rcirc.el" "ERROR" rcirc-target
  ;                           (format "reconnection attempt failed: %s" err)  t)
  ;              (rcirc-reconnect-schedule process))))))))
#+end_src
*** ERC
    :PROPERTIES:
    :ID:       5ba53dbe-b88d-44e9-8121-462325ca2422
    :END:
What I generally end up using for irc, but weechat always tends to win
me over.
#+begin_src emacs-lisp
  (setq erc-user-full-name "codemac")
  (setq erc-email-userid "j@codemac.net")
  (setq erc-nick "codemac")
  (setq erc-prompt-for-password nil)
  ;; ERC Time stamps
  (setq erc-timestamp-only-if-changed-flag t)
  (setq erc-timestamp-format "[%H:%M:%S] ")
  (setq erc-insert-timestamp-function 'erc-insert-timestamp-left)

  ;; Auto-fill (static size so log files look decent)
  (setq erc-fill-column 100)
  (setq erc-fill-function 'erc-fill-static)
  (setq erc-fill-static-center 15)
  (setq erc-join-buffer 'bury)

  (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT"))

  ;; Auto join the given channels
  (erc-autojoin-mode t)
  (setq erc-autojoin-channels-alist cm/erc-autojoin-channels-alist)

  (setq erc-server-auto-reconnect t)
  (setq erc-server-reconnect-attempts 5)
  (setq erc-server-reconnect-timeout 5)
  ;; Some other settings
  (setq erc-max-buffer-size 20000)
  (setq erc-track-showcount t)
  (setq erc-auto-query 'bury)             ; Private messages go to a hidden buffer
  (setq erc-autojoin-timing 'ident) ; wait for the delay (or ident resolution)
  (setq erc-autojoin-delay 15)

    ;; Setup ERC buffers
  (defun cm/erc-hook ()
    "Correctly configure ERC buffers"
    (auto-fill-mode 0)                    ; disable auto fill
    (setq truncate-lines nil)            ; wrap lines
    ;; Add some modules
    (add-to-list 'erc-modules 'scrolltobottom)
    (add-to-list 'erc-modules 'truncate)
    (add-to-list 'erc-modules 'hl-nicks)
    (erc-update-modules))

  (defun cm/erc-begin ()
    (interactive)
    (erc-ssl :server "chat.freenode.net" :port 6697)
    (erc :server "localhost"))

  (add-hook 'erc-mode-hook 'cm/erc-hook)
  (add-hook 'erc-join-hook 'bitlbee-netrc-identify)

#+end_src
**** Bitlbee Support
     :PROPERTIES:
     :ID:       65b67613-38e8-418f-9abc-9a93e86e441e
     :END:
#+begin_src emacs-lisp
  (defun bitlbee-netrc-identify ()
    "Auto-identify for Bitlbee channels using authinfo or netrc.
    
     The entries that we look for in netrc or authinfo files have
     their 'port' set to 'bitlbee', their 'login' or 'user' set to
     the current nickname and 'server' set to the current IRC
     server's name.  A sample value that works for authenticating
     as user 'keramida' on server 'localhost' is:
    
     machine localhost port bitlbee login keramida password supersecret"
    (interactive)
    (when (string= (buffer-name) "&bitlbee")
      (let* ((secret (plist-get (nth 0 (auth-source-search :max 1
                                                           :host erc-server
                                                           :user (erc-current-nick)
                                                           :port "bitlbee"))
                                :secret))
             (password (if (functionp secret)
                           (funcall secret)
                         secret)))
        (erc-message "PRIVMSG" (concat (erc-default-target) " " "identify" " " password) nil))))

  ;; Enable the netrc authentication function for &biblbee channels.
  ;(add-hook 'erc-join-hook 'bitlbee-netrc-identify)
#+end_src
*** Jabber
    :PROPERTIES:
    :ID:       cf368eef-c121-411f-ad2c-1560d4a0882f
    :END:
Directly use jabber with elisp! It's painfully slow, and the single
threaded nature of emacs means it turns out to be quite a failure if
you are trying to edit anything.
#+begin_src emacs-lisp
    (autoload 'jabber-connect-all "jabber" "" t)
    ;; Show my status in the header along with theirs! woo!
    (eval-after-load 'jabber
      (progn
        (setq jabber-chat-header-line-format
              '(" " (:eval (jabber-jid-displayname jabber-chatting-with))
                " " (:eval (jabber-jid-resource jabber-chatting-with)) "\t";
                (:eval (let ((buddy (jabber-jid-symbol jabber-chatting-with)))
                         (propertize
                          (or
                           (cdr (assoc (get buddy 'show) jabber-presence-strings))
                           (get buddy 'show))
                          'face
                          (or (cdr (assoc (get buddy 'show) jabber-presence-faces))
                              'jabber-roster-user-online))))
                "\t" (:eval (get (jabber-jid-symbol jabber-chatting-with) 'status))
                (:eval (unless (equal "" *jabber-current-show*)
                         (concat "\t You're " *jabber-current-show*
                                 " (" *jabber-current-status* ")")))))
        ;; Open urls!
        (add-hook 'jabber-chat-mode-hook 'goto-address)
        
        ;; fun keybindings!
        (defun my-jabber-chat-delete-or-bury ()
          (interactive)
          (if (eq 'jabber-chat-mode major-mode)
              (condition-case e 
                  (delete-frame)
                (error 
                 (if (string= "Attempt to delete the sole visible or iconified frame" 
                              (cadr e))
                     (bury-buffer))))))
        
    ;    (define-key jabber-chat-mode-map [escape] 'my-jabber-chat-delete-or-bury)
        (define-key mode-specific-map "jr"
          (lambda () 
            (interactive) 
            (switch-to-buffer "*-jabber-*")))
        (define-key mode-specific-map "jc"
          '(lambda () 
             (interactive) 
             (call-interactively 'jabber-connect)))
        (define-key mode-specific-map "jd"
          '(lambda () 
             (interactive) 
             (call-interactively 'jabber-disconnect)))
        (define-key mode-specific-map "jj"
          '(lambda () 
             (interactive) 
             (call-interactively 'jabber-chat-with)))
        (define-key mode-specific-map "ja"
          '(lambda () 
             (interactive) 
             (jabber-send-presence "away" "" 10)))
        (define-key mode-specific-map "jo"
          '(lambda () 
             (interactive) 
             (jabber-send-presence "" "" 10)))
        (define-key mode-specific-map "jx"
          '(lambda () 
             (interactive) 
             (jabber-send-presence "xa" "" 10)))))

    ;;;; hipchat support
    (setq ssl-program-name "gnutls-cli"
          ssl-program-arguments '("--insecure" "-p" service host)
          ssl-certificate-verification-policy 1)
     
    ;; Connect using jabber.el
    ;; M-x jabber-connect <RET>
     
    ;; Config
    (setq jabber-account-list '(("75698_604162@chat.hipchat.com")))
    (defvar hipchat-number "75698")
    (defvar hipchat-nickname "Jeff Mickey")

    ;; Join a room
    (defun cm/hipchat-join (room)
      (interactive "sRoom name: ")
      (jabber-groupchat-join
       (jabber-read-account)
       (concat hipchat-number "_" room "@conf.hipchat.com")
       hipchat-nickname
       t))

    ;; Mention nicknames in a way that HipChat clients will pickup
    (defun hipchat-mention (nickname)
      (interactive
       (list (jabber-muc-read-nickname jabber-group "Nickname: ")))
      (insert (concat "@\"" nickname "\" "))) 

  (defvar cm/hipchat-rooms '())

  (defun cm/hipchat-joinall ()
    (interactive)
    (rcirc-cmd-join (mapconcat 'identity cm/hipchat-rooms ",") (rcirc-buffer-process (get-buffer "&bitlbee@localhost")) nil))
#+end_src
*** SLIME
    :PROPERTIES:
    :ID:       bb361611-de0c-480f-8919-e1ed77b583e0
    :END:
#+begin_src emacs-lisp
  ;(setq inferior-lisp-program "sbcl")
  ;(require 'slime-autoloads)
  ;(slime-setup '(slime-fancy))
  ;(load (expand-file-name "/home/codemac/.quicklisp/slime-helper.el"))

#+end_src
*** SQL
    :PROPERTIES:
    :ID:       b4967d83-57f9-4cb9-879f-f3a395509419
    :END:
Who needs a command line anyways..
#+begin_src emacs-lisp
  (defun sql-make-smart-buffer-name ()
    "Return a string that can be used to rename a SQLi buffer.
  
  This is used to set `sql-alternate-buffer-name' within
  `sql-interactive-mode'."
    (or (and (boundp 'sql-name) sql-name)
        (concat (if (not(string= "" sql-server))
                    (concat
                     (or (and (string-match "[0-9.]+" sql-server) sql-server)
                         (car (split-string sql-server "\\.")))
                     "/"))
                sql-database)))
  
  (add-hook 'sql-interactive-mode-hook
            (lambda ()
              (setq sql-alternate-buffer-name (sql-make-smart-buffer-name))
              (sql-rename-buffer)))
#+end_src
*** Flymake
    :PROPERTIES:
    :ID:       b379d31d-a542-496b-ad6b-31817952e93d
    :END:
#+begin_src emacs-lisp
  ;; stolen from http://www.reddit.com/r/emacs/comments/i05v3/emacs_and_pylint/c1ztm6x (user kanak on /r/emacs)
  (require 'flymake)
  
  (setq *cm/flychecker-directory* "~/.emacs.d/flycheck")
  
  (defmacro def-flymake-init (mode checker-file)
    "Writes a function called flymake-MODE-init which contains the usual boilerplate for a default flymake initialization."
    `(defun ,(intern (format "flymake-%s-init" mode)) () 
        (let* ((temp-file (flymake-init-create-temp-buffer-copy 
                     'flymake-create-temp-inplace)) 
         (local-file (file-relative-name 
                      temp-file 
                      (file-name-directory buffer-file-name)))) 
    (list (expand-file-name ,checker-file *cm/flychecker-directory*) (list local-file)))))
  
  (defmacro def-flymake-cleanup (mode extlist)
    "Writes a function called flymake-MODE-cleanup which removes files with specified extensions in current directory."
    `(defun ,(intern (format "flymake-%s-cleanup" mode)) ()
   (when flymake-temp-source-file-name
     (let* ((temp-files
             (mapcar (lambda (ext)
                       (concat 
                        (file-name-sans-extension flymake-temp-source-file-name) ext))
                     ,extlist)))
       (dolist (f temp-files)
         (when (file-exists-p f)
           (flymake-safe-delete-file f)))))
   (flymake-simple-cleanup)))
  
  (def-flymake-init "python" "~/.emacs.d/flycheckbin/pychecker.sh")
  (add-to-list 'flymake-allowed-file-name-masks '("\\.py\\'" flymake-python-init)) 
  
  ;; flyspell
  (setq ispell-program-name "aspell")
  (setq ispell-list-command "list")
  (setq ispell-extra-args '("--sug-mode=ultra"))
#+end_src
*** EMMS - Emacs MultiMedia System
    :PROPERTIES:
    :ID:       0e42f65c-aca2-4cbb-9633-1d8cedaefaa8
    :END:
Now w/mopidy
#+begin_src emacs-lisp
  (require 'emms-setup)
  (emms-standard)
  (require 'emms-browser)
  (require 'emms-player-mpd)
  (add-to-list 'emms-info-functions 'emms-info-mpd)
  (add-to-list 'emms-player-list 'emms-player-mpd)

  (require 'emms-volume)
  (setq emms-volume-change-function 'emms-volume-mpd-change)

  (setq emms-info-asynchronosly t)
  (add-hook 'emms-player-started-hook 'emms-show)
  (setq emms-show-format "NP: %s")
  (setq emms-mode-line-icon-before-format ""
        emms-mode-line-format " %s"
        emms-mode-line-icon-color "blue")

  (if (executable-find "find")
      (setq emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find))

  ;; reserve a key namespace for emms
  (global-set-key (kbd "C-c m p") 'emms-pause)
  (global-set-key (kbd "C-c m m") 'emms-smart-browse)
#+end_src
** Custom
   :PROPERTIES:
   :ID:       3897ecf3-7d82-47a2-b736-abf8204a83b4
   :END:
*** Journal
    :PROPERTIES:
    :ID:       f11177ea-8f27-467c-bcc1-ee237fa6c0be
    :END:
Old text file journaling stuff. It really was quite nice, but org mode
once again ate my soul.
#+begin_src emacs-lisp
  (defun insert-date ()
    (interactive)
    (insert (format-time-string "%c")))
  
  (defun insert-header-newday ()
    (interactive)
    (insert "\n////////////////////////////////////////////////////////////////////////\n")
    (insert "// ")
    (insert-date)
    (insert "\n\n"))
  
  (defun insert-header-continue ()
    (interactive)
    (insert (format-time-string "\n                             ** %T **"))
    (insert "\n\n"))
  
  (defun insert-correct-header ()
    (interactive)
    (insert-header-newday))
  
  (defun journal ()
    (interactive)
    (find-file "~/doc/journal.txt")
    (end-of-buffer)
    (insert-correct-header)
    (auto-fill-mode 1)
    (flyspell-mode 1))
#+end_src
*** Blog
    :PROPERTIES:
    :ID:       5f6385d7-5212-4463-b3e8-df47357a4d69
    :END:
Some helper functions for publishing with ikiwiki
#+begin_src emacs-lisp
  (defun blog-insert-meta ()
    (interactive)
    (insert "[[!meta title=\"\"]]\n")
    (insert "[[!tag ]]\n")
    (insert "\n"))
  
  (defun blog-last ()
    (interactive)
    (let ((wiki-dir "~/www/wiki/blog/"))
      (find-file
       (concat wiki-dir
               (number-to-string (apply 'max (mapcar 'string-to-number
                                                     (mapcar '(lambda (a) (substring a 0 -5))
                                                             (directory-files wiki-dir nil "[0-9]*\\.mdwn" t )))))
               ".mdwn"))))
  
  (defun blog-find-next ()
    (interactive)
    (let ((wiki-dir "~/www/wiki/blog/"))
      (find-file 
       (concat wiki-dir 
               (number-to-string (1+ (apply 'max
                                            (mapcar 'string-to-number 
                                                    (mapcar '(lambda (a) (substring a 0 -5)) 
                                                            (directory-files wiki-dir nil "[0-9]*\\.mdwn" t))))))
               ".mdwn"))))
  
  (defun blog-next ()
    (interactive)
    (blog-find-next)
    (end-of-buffer)
    (blog-insert-meta))  
#+end_src
*** IronPort
    :PROPERTIES:
    :ID:       93a9fa67-ac11-4cc7-9a69-a0517086bc67
    :END:
A wholly owned subsidiary of Cisco.
#+begin_src emacs-lisp
  (defun ip-p4-cmd (command)
    "Run a command through p4 correctly, synchronously."
    (interactive)
    (let ((bn (buffer-file-name))
          (ppos (point)))
      (call-process-shell-command
       (concat
        "P4USER=jmickey "
        "P4PORT=perforce.ironport.com:1666 "
        "P4CONFIG=P4ENV "
        command " "
        bn))
      (find-alternate-file bn)
      (goto-char ppos)))
  
  (defun ip-p4-info (cmd)
    "Run a command through p4 asynchronously in an output buffer"
    (interactive)
    (let* ((bfn (buffer-file-name))
          (nbn (concat "*p4i:" (buffer-name) "*")))
          
      (start-process-shell-command nbn
                                   (get-buffer-create nbn)
                                   (concat
                                    "P4USER=jmickey "
                                    "P4PORT=perforce.ironport.com:1666 "
                                    "P4CONFIG=P4ENV "
                                    cmd " "
                                    bfn))
      (switch-to-buffer nbn)))
  
  (defun ip-p4-edit ()
    "Mark file as edit in perforce, reload buffer as editable, reset pointer"
    (interactive)
    (ip-p4-cmd "p4 edit"))
  
  (defun ip-p4 ()
    "Run arbitrary p4 command on current file"
    (interactive)
    (ip-p4-cmd (concat "p4 " (ido-completing-read "p4 "
                                                  (list
                                                   "edit"
                                                   "revert")))))
    
  (defun ip-p4-filelog ()
    "Show filelog output"
    (interactive)
    (ip-p4-info "p4 filelog -i"))
  
  (defun ip-p4pr ()
    "Show perforce blame"
    (interactive)
    (ip-p4-info "p4pr"))
  
  (defun sql-connect-preset (name)
    "Connect to a predefined SQL connection listed in `sql-connection-alist'"
    (eval `(let ,(cdr (assoc name ip-sql-connection-alist))
      (flet ((sql-get-login (&rest what)))
        (sql-product-interactive sql-product)))))
  
  (defun ip-sql-get-names (tlist)
    (if tlist (append (list (caar tlist)) (ip-sql-get-names (cdr tlist)))))
  
  (defun ip-sql-connect ()
    "Ido ask which!"
    (interactive)
    (sql-connect-preset (ido-completing-read "Connect to: " (ip-sql-get-names ip-sql-connection-alist))))
#+end_src
*** Tup
    :PROPERTIES:
    :ID:       b14441a2-77bc-4444-bcda-db6ef2ea9331
    :END:
#+begin_src emacs-lisp
  (require 'tup-mode)
#+end_src

* EXWM
  :PROPERTIES:
  :ID:       cfaf9b3f-9ab8-449e-ac79-1d671655f1aa
  :END:
I manage my windows in X with emacs.


Well, at least I'm trying
#+begin_src emacs-lisp
  ;; Shrink fringes to 1 pixel
  (fringe-mode 1)

  ;; You may want Emacs to show you the time
  ;(setq display-time-default-load-average nil)
  ;(display-time-mode t)


  ;; You are strongly encouraged to enable `ido-mode' (or something similar) to
  ;; alter to default behavior of 'C-x b', or you will take great pains to switch
  ;; to or back from a floating frame (remember 'C-x 5 o' if you refuse this
  ;; proposal however)
  ;;(ido-mode 1)

  ;; Load EXWM
  (require 'exwm)

  ;; All buffers created in EXWM mode are named "*EXWM*". You may want to change
  ;; it in `exwm-update-class-hook' and `exwm-update-title-hook', which are run
  ;; when a new window class name or title is available. Here's some advice on
  ;; this subject:
  ;; + Always set the second argument of `rename-buffer' to `t' to avoid naming
  ;;   conflict.
  ;; + Only renaming buffer in one hook and avoid it in the other. There's no
  ;;   guarantee on the order in which they are run.
  ;; + For applications with multiple windows (e.g. GIMP), the class names of all
  ;;   windows are probably the same. Using window titles for them makes more
  ;;   sense.
  ;; + Some application change its title frequently (e.g. browser, terminal).
  ;;   Its class name may be more suitable for such case.
  ;; In the following example, we use class names for all windows expect for
  ;; Java applications and GIMP.
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                (rename-buffer exwm-class-name t))))
  (add-hook 'exwm-update-title-hook
            (lambda ()
              (when (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
                (rename-buffer exwm-title t))))

  ;; `exwm-input-set-key' allows you to set a global key binding (available in
  ;; any case). Following are a few examples.
  ;; + We always need a way to go back to line-mode from char-mode
  (exwm-input-set-key (kbd "s-r") 'exwm-reset)
  ;; + Bind a key to switch workspace interactively
  (exwm-input-set-key (kbd "s-n") 'exwm-workspace-switch)
  ;; + Set shortcuts to switch to a certain workspace.
  (exwm-input-set-key (kbd "s-0")
                      (lambda () (interactive) (exwm-workspace-switch 0)))
  (exwm-input-set-key (kbd "s-1")
                      (lambda () (interactive) (exwm-workspace-switch 1)))
  (exwm-input-set-key (kbd "s-2")
                      (lambda () (interactive) (exwm-workspace-switch 2)))
  (exwm-input-set-key (kbd "s-3")
                      (lambda () (interactive) (exwm-workspace-switch 3)))
  ;; + Application launcher ('M-&' also works if the output buffer does not
  ;;   bother you). Note that there is no need for processes to be created by
  ;;   Emacs.
  (exwm-input-set-key (kbd "s-&")
                      (lambda (command)
                        (interactive (list (read-shell-command "$ ")))
                        (start-process-shell-command command nil command)))
  ;; + 'slock' is a simple X display locker provided by suckless tools. 'i3lock'
  ;;   is more feature-rich alternative.
  ;(exwm-input-set-key (kbd "s-<f2>")
   ;                   (lambda () (interactive) (start-process "" nil "slock")))

  ;; The following example demonstrates how to set a key binding only available
  ;; in line mode. It's simply done by first push the prefix key to
  ;; `exwm-input-prefix-keys' and then add the key sequence to `exwm-mode-map'.
  ;; The example shorten 'C-c q' to 'C-q'.
  (push ?\C-q exwm-input-prefix-keys)
  (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

  ;; The following example demonstrates how to use simulation keys to mimic the
  ;; behavior of Emacs. The argument to `exwm-input-set-simulation-keys' is a
  ;; list of cons cells (SRC . DEST), where SRC is the key sequence you press and
  ;; DEST is what EXWM actually sends to application. Note that SRC must be a key
  ;; sequence (of type vector or string), while DEST can also be a single key.
  (exwm-input-set-simulation-keys
   '(([?\C-b] . left)
     ([?\C-f] . right)
     ([?\C-p] . up)
     ([?\C-n] . down)
     ([?\C-a] . home)
     ([?\C-e] . end)
     ([?\M-v] . prior)
     ([?\C-v] . next)))

  ;; Do not forget to enable EXWM. It will start by itself when things are ready.
  (exwm-enable)

  ;Configuration of X init script
  ;
  ;~/.xinitrc:
  ;
  ;# Set themes, etc
  ;gnome-settings-daemon &
  ;
  ;# Set fallback cursor
  ;xsetroot -cursor_name left_ptr
  ;
  ;# Set keyboard repeat rate
  ;xset r rate 200 60
  ;
  ;# Finally launch emacs
  ;exec dbus-launch --exit-with-session emacs
  ;
  ;Other configurations
  ;
  ;Append the following line to your ~/.profile to start EXWM when you login on tty5:
  ;
  ;[ -z "$DISPLAY" -a "$(tty)" = '/dev/tty5' ] && exec xinit -- vt05
#+end_src 
    
* Directory Specific Code
  :PROPERTIES:
  :ID:       2fbd3ec2-ed82-414f-9bf9-bfecad2a9db5
  :END:
** Directory classes
   :PROPERTIES:
   :ID:       50d34be2-13f5-43c5-8b0a-e1dfbd05fc16
   :END:
#+begin_src emacs-lisp
  ;; check in all the time! (Need to learn to avoid master as well..)
  (defun cm/after-save-commit ()
    (if cm/gitty-files
        (call-interactively 
         (lambda (title)
           (interactive "sCommit title: ")
           (let* ((bfn (buffer-file-name))
                  (gitroot (substring (shell-command-to-string "git rev-parse --show-toplevel") 0 -1))
                  (shortname (car (split-string bfn (concat gitroot "/") t))))
             (shell-command (concat "git add " bfn " && git commit -m '" shortname ": " title "'")))))))

  ;; set this variable in your .dir-locals.el so saving becomes enabled
  (defvar cm/gitty-files nil)

  (defun cm/igneous-product-config ()
    ;; add an after-save-hook that runs git commit!
    (add-hook 'after-save-hook 'cm/after-save-commit))
#+end_src
** Directories
   :PROPERTIES:
   :ID:       f6cd9ef5-406e-40db-824b-3e8a2631420a
   :END:
* Disabled lisp
  :PROPERTIES:
  :ID:       0daffd72-11cb-4c40-9803-d8052e4d3009
  :END:
#+begin_src emacs-lisp
  ; have to figure out how to comment multiple lines...
#+end_src

** All edit in occur
   :PROPERTIES:
   :ID:       afa1fcb9-1dbe-41d1-ad68-2362ba5d4b76
   :END:
Turns out that occur actually handles this just fine..

#+begin_src emacs-lisp
  ;; (require 'all)
  ;; (defun isearch-all ()
  ;;   "Invoke `all' from within isearch."
  ;;   (interactive)
  ;;   (let ((case-fold-search isearch-case-fold-search))
  ;;     (all (if isearch-regexp isearch-string (regexp-quote isearch-string)))))
  
  ;; (define-key isearch-mode-map (kbd "C-e") 'isearch-all)
#+end_src
** Hippe tab
   :PROPERTIES:
   :ID:       715b10ba-f8ac-4cb2-a242-3d2a6fff0a37
   :END:
I.. don't use this anymore
#+begin_src emacs-lisp
  ;(global-set-key (kbd "TAB") 'hippie-expand)
#+end_src
** ECB - Emacs Code Browser
   :PROPERTIES:
   :ID:       200c1819-7436-4f11-a439-b0d1aa07f528
   :END:
#+begin_src emacs-lisp
  ;(require 'ecb-autoloads)
#+end_src
** xcscope
   :PROPERTIES:
   :ID:       18e348cb-787b-4994-ae29-25b7a78b9169
   :END:
Gotta love cscope. Using GNU Global now.
#+begin_src emacs-lisp
  ;(require 'xcscope)
  ;(setq cscope-do-not-update-database t)
  ;
  ;(defun xcscope-minor-mode ()
  ;  (interactive)
  ;  (cscope:hook)
  ;)
  ;
  ;(add-hook 'python-mode-hook (function cscope:hook))
#+end_src
** acscope
   :PROPERTIES:
   :ID:       a1cc38e6-519f-4a58-909d-856907e9f78c
   :END:
Another way of handling cscope, though I rarely built cscope db's locally, so this was rarely used.
#+begin_src emacs-lisp
  ;(require 'ascope)
  ;
  ;;; The following line corresponds to be beginning of the "Cscope" menu.
  ;(define-key cscope:map "\C-css" 'ascope-find-this-symbol)
  ;(define-key cscope:map "\C-csg" 'ascope-find-global-definition)
  ;;(define-key cscope:map "\C-csG" 'cscope-find-global-definition-no-prompting)
  ;(define-key cscope:map "\C-csc" 'ascope-find-functions-calling-this-function)
  ;(define-key cscope:map "\C-csC" 'ascope-find-called-functions)
  ;(define-key cscope:map "\C-cst" 'ascope-find-this-text-string)
  ;;(define-key cscope:map "\C-cse" 'cscope-find-egrep-pattern)
  ;;(define-key cscope:map "\C-csf" 'cscope-find-this-file)
  ;(define-key cscope:map "\C-csi" 'ascope-find-files-including-file)
  ;(define-key cscope:map "\C-csa" 'ascope-all-symbol-assignments)
  ;;; --- (The '---' indicates that this line corresponds to a menu separator.)
  ;;(define-key cscope:map "\C-csb" 'cscope-display-buffer)
  ;;(define-key cscope:map "\C-csB" 'cscope-display-buffer-toggle)
  ;;(define-key cscope:map "\C-csn" 'cscope-next-symbol)
  ;;(define-key cscope:map "\C-csN" 'cscope-next-file)
  ;;(define-key cscope:map "\C-csp" 'cscope-prev-symbol)
  ;;(define-key cscope:map "\C-csP" 'cscope-prev-file)
  ;;(define-key cscope:map "\C-csu" 'cscope-pop-mark)
  ;;; ---
  ;;(define-key cscope:map "\C-csa" 'cscope-set-initial-directory)
  ;;(define-key cscope:map "\C-csA" 'cscope-unset-initial-directory)
  ;;; ---
  ;;(define-key cscope:map "\C-csL" 'cscope-create-list-of-files-to-index)
  ;;(define-key cscope:map "\C-csI" 'cscope-index-files)
  ;;(define-key cscope:map "\C-csE" 'cscope-edit-list-of-files-to-index)
  ;;(define-key cscope:map "\C-csW" 'cscope-tell-user-about-directory)
  ;;(define-key cscope:map "\C-csS" 'cscope-tell-user-about-directory)
  ;;(define-key cscope:map "\C-csT" 'cscope-tell-user-about-directory)
  ;;(define-key cscope:map "\C-csD" 'cscope-dired-directory))
#+end_src
** Perspective
   :PROPERTIES:
   :ID:       0174a769-874a-4b50-a5ce-dd09c03521a0
   :END:
#+begin_src emacs-lisp
  ;(require 'perspective)
  ;(persp-mode)
#+end_src
** Tabbar
   :PROPERTIES:
   :ID:       d4497aba-dae0-42df-85de-6e8388337d7e
   :END:
Nice to have going along the top sometimes. Disabled, I never used it.
#+begin_src emacs-lisp
  ;(require 'tabbar)
  ;(tabbar-mode)
  ;
  ;(global-set-key (kbd "<C-tab>") 'tabbar-forward)
  ;(global-set-key (kbd "<C-S-iso-lefttab>") 'tabbar-forward-group)
#+end_src

** End diasbled code
   :PROPERTIES:
   :ID:       cb8445c2-04c4-4fa4-980f-4037e747ba3f
   :END:
#+begin_src emacs-lisp
  ; this is where the ending mark would be
#+end_src
** Command Frequency
   :PROPERTIES:
   :ID:       9c53a156-0cb0-4367-9a19-24d6056f4ba4
   :END:
This can be useful to figure out what commands you do and don't use
all the time, so you can figure out what keybindings you need to
fix. I found that I never used the data though..
#+begin_src emacs-lisp
  ;; (require 'command-frequency)
  
  ;; (setq-default command-frequency-table-file "~/.emacs-frequency")
  
  ;; (command-frequency-table-load)
  ;; (command-frequency-mode 1)
  ;; (command-frequency-autosave-mode 1)
#+end_src

** mu4e
   :PROPERTIES:
   :ID:       67b2693a-b95f-47fc-8db4-92a9b669a177
   :END:
=mu4e= is a Maildir emacs mail mode. It's quite simple, but it's
design goals fall right in the "super perfect" range, and I think it
has a huge opportunity to succeed. It is similar to notmuch.
#+begin_src emacs-lisp
;  (require 'mu4e)
#+end_src
*** Folders
    :PROPERTIES:
    :ID:       14769157-82d3-40b0-8aea-f0a614e746ee
    :END:
These match the Outlook ones..
#+begin_src emacs-lisp
;  (setq mu4e-maildir "~/mail"
;        mu4e-sent-folder "/Sent Items"
;        mu4e-drafts-folder "/Drafts"
;        mu4e-trash-folder "/Deleted Items"
;        mu4e-refile-folder "/archive")
;  
;  (setq mu4e-maildir-shortcuts
;        '(("/INBOX" . ?i)))
;  
;  (setq mu4e-refile-folder 'cm/mu4e-refile-folder)
;  
#+end_src
*** Retrieval and Indexing
    :PROPERTIES:
    :ID:       a8d53e13-c716-4cd3-9028-8c53cfc67139
    :END:
Let's update the maildirs once every 5 minutes
#+begin_src emacs-lisp
;  (setq mu4e-get-mail-command "offlineimap"
;        mu4e-update-interval 200)
#+end_src
*** Sending mail
    :PROPERTIES:
    :ID:       1f68110e-5f40-47e1-afda-a325af1662f2
    :END:
We're just borrowing the gnus settings here..
#+begin_src emacs-lisp
;  (setq smtpmail-auth-credentials "~/.authinfo"
;        smtpmail-smtp-server "mail.netapp.com"
;        smtpmail-default-smtp-server "mail.netapp.com"
;        smtpmail-smtp-service 25
;        send-mail-function 'smtpmail-send-it
;        message-send-mail-function 'smtpmail-send-it
;        smtpmail-auth-supported '(login))
;  
;  (setq mu4e-sent-messages-behavior 'sent)
#+end_src
*** Queuing mail
    :PROPERTIES:
    :ID:       8360c965-6186-4e05-9330-2ed9ec58bf1b
    :END:
This is very useful for when I ride the train.
#+begin_src emacs-lisp
;  (setq smtpmail-queue-mail  nil  ;; start in non-queuing mode
;        smtpmail-queue-dir   "~/mail/queue/cur")
#+end_src
*** Setting the default mail client
    :PROPERTIES:
    :ID:       4ebb9da5-b997-4cb8-ba4a-c1c7bfc2a970
    :END:
#+begin_src emacs-lisp
;  (setq mail-user-agent 'mu4e-user-agent)
;  (setq user-mail-address "jmickey@netapp.com")
;  (setq user-full-name "Jeff Mickey")
#+end_src
*** Org mode integration
    :PROPERTIES:
    :ID:       34a985b7-f503-4301-809e-d36bc140fcfd
    :END:
#+begin_src emacs-lisp
;  (require 'org-mu4e)
;  (setq org-mu4e-convert-to-html t)
#+end_src
** Ido
   :PROPERTIES:
   :ID:       72b1beb3-ca21-4ef1-8741-30fac3e98ca8
   :END:
Everyone should use Ido. (well, maybe helm)
#+begin_src emacs-lisp
  ;(require 'ido)
  ;(put 'ido-exit-minibuffer 'disabled nil)
  ;(ido-mode t)
#+end_src
If the exact name isn't found, then flex matching will match against
anything with the characters in the order you've typed. It matches
only for strings that have that sequence of characters in order.
#+begin_src emacs-lisp
  ;(setq ido-enable-flex-matching t)
#+end_src

** Identica
   :PROPERTIES:
   :ID:       357a3a6d-12b9-471b-a48b-c801eb7103ea
   :END:
Microblog, baby.
#+begin_src emacs-lisp
  ;(autoload 'identica-mode "identica-mode" "" t)
  ;(setq identica-username cm/identica-username
  ;      identica-password cm/identica-password)
  ;
  ;(global-set-key "\C-cip" 'identica-update-status-interactive)
  ;(global-set-key "\C-cid" 'identica-direct-message-interactive)
#+end_src
* Cursor color
  :PROPERTIES:
  :ID:       ec982e34-e2a7-429f-b2e0-9a4a7957ba1c
  :END:
Change cursor color according to mode; inspired by
http://www.emacswiki.org/emacs/ChangingCursorDynamically valid values
are t, nil, box, hollow, bar, (bar . WIDTH), hbar, (hbar. HEIGHT); see
the docs for set-cursor-type.

This is put at the very end so that way it can override any coloring
settings that occur above. Much easier this way.
#+begin_src emacs-lisp
  (defun cm/cursor ()
    "change cursor color and type according to some minor modes."
    (cond
      (buffer-read-only
       (setq cursor-type 'hbar))
      (t 
       (set-cursor-color "yellow")
       (setq cursor-type 'box))))


  (setq cursor-type 'box)
  ;(add-hook 'post-command-hook 'cm/cursor)
  ; oh god it flashes so much. Don't know how to do this better yet.
  (blink-cursor-mode 0)
  (set-cursor-color "#ffff00")
  (set-mouse-color "#ffff00")
#+end_src
** Server process
   :PROPERTIES:
   :ID:       41e76b1a-d666-472b-a77e-b62478546956
   :END:
Start a server if it's not started, and I'm not root.
#+begin_src emacs-lisp
  ;(unless (string-equal "root" (getenv "USER"))
  ;; Only start server mode if it isn't started already
   ; (unless (server-running-p)
    ;  (server-start)))
  
  ;(add-hook 'server-visit-hook 'raise-frame)
#+end_src

