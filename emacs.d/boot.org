#+title: codemac emacs

#+begin_quote 
Emacs outshines all other editing software in approximately the same
way that the noonday sun does the stars. It is not just bigger and
brighter; it simply makes everything else vanish.

-- Neal Stephenson, "In the Beginning was the Command Line"
#+end_quote

* Introduction
:PROPERTIES:
:ID:       3214fd7e-44bf-4519-86ec-1f347de21d32
:END:
The goal of this init.org file is to document my emacs configuration
in a readable manner for those who would like to borrow from it. We'll
see how this goes!

* Org initialization
  :PROPERTIES:
  :ID:       10b789e5-616b-4d30-a27a-1c4bdd57c08c
  :END:

Unfortuantely, emacs can't read directly from org mode files just yet,
so you have to check [[file:init.el][init.el]] for more information! DRY!
** Lexical lisp
:PROPERTIES:
:ID:       f7fd4f72-2cb1-4560-b407-0144cee8b443
:END:
This must be first, and it makes everything else a little bit easier.
#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src
* Utility Functions
:PROPERTIES:
:ID:       a9f6af8a-f8fa-46a0-8d2d-8b93ff1497a6
:END:
** async-shell-command-to-string
:PROPERTIES:
:ID:       83168006-e776-4f4a-a467-ac6772515e76
:END:
Useful for making generic functions that don't totally lock up
emacs. Normally using shell-command or sentinal can be really
annoying.
#+begin_src emacs-lisp
  (defun async-shell-command-to-string (command callback)
    "Execute shell command COMMAND asynchronously in the
  background.

  Return the temporary output buffer which command is writing to
  during execution.

  When the command is finished, call CALLBACK with the resulting
  output as a string."
    (let ((output-buffer (generate-new-buffer " *temp*"))
	  (callback-fun callback))
      (set-process-sentinel
       (start-process "Shell" output-buffer shell-file-name shell-command-switch command)
       (lambda (process _change_string)
	 (when (memq (process-status process) '(exit signal))
	   (with-current-buffer output-buffer
	     (let ((output-string
		    (buffer-substring-no-properties (point-min) (point-max))))
	       (funcall callback-fun output-string)))
	   (kill-buffer output-buffer))))
      output-buffer))
#+end_src
** Unwrap lines
:PROPERTIES:
:ID:       4a478e2b-861d-4fbd-a72e-aad31fdbec9d
:END:
#+begin_src emacs-lisp
  (defun cm/unwrap-lines ()
    (interactive)
    (let ((fill-column 999999999999))
      (fill-paragraph nil t)))
#+end_src
* User Interface
  :PROPERTIES:
  :ID:       174da1e1-650e-41f1-a5de-48a0e77b8538
  :END:
** Emacs look
   :PROPERTIES:
   :ID:       0eb756bc-30b7-4bef-8d0c-a5d67d43b619
   :END:
#+begin_src emacs-lisp
  (if (boundp 'menu-bar-mode)
      (menu-bar-mode -1))
  (if (boundp 'tool-bar-mode)
      (tool-bar-mode -1))
  (if (boundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
#+end_src

I love the empty-lines notification. However, it does seem to fail on
the very last line? I haven't solved this yet.
#+begin_src emacs-lisp
  (set-default 'indicate-empty-lines t)
#+end_src

Display all the warnings! I've had this forever, I'm not so sure how
important it actually is.
#+begin_src emacs-lisp
  (require 'warnings)
  (setq warning-suppress-types nil)
#+end_src

Also, I hate the audible bell, lots.
#+begin_src emacs-lisp
  (setq visible-bell 1)
#+end_src
This adds line numbers and column numbers in the emacs
modeline. Fucking essential.
#+begin_src emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+end_src
Let's get weird.
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
#+end_src
And of course, transparency!
#+begin_src emacs-lisp
  ;; Set transparency of emacs
  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque"
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))
  
  (defun netflix ()
    (interactive)
    (set-background-color "black")
    (transparency 45))
  
  
  (defun opaque ()
    (interactive)
    (load-theme 'zenburn t)
    (set-cursor-color "yellow")
    (setq cursor-type 'box)
    (transparency 100))
#+end_src
*** Modeline management
    :PROPERTIES:
    :ID:       cbf11e79-808e-4e25-8071-0ccdd748052a
    :END:
#+begin_src emacs-lisp
  (require 'time)
  (defun cm/display-time-mail-function ()
    "Return t if new important mail, else nil"
    (let* ((s (shell-command-to-string
	       "notmuch count tag:inbox AND tag:unread"))
	   (st (string-trim s))
	   (newmail (string= "0" st)))
      (not newmail)))

  (setq display-time-mail-function nil) ;; not actually useful, always have mail
  (setq display-time-format "%Y-%m-%d %H:%M")
  (setq display-time-day-and-date t)
  (setq display-time-24hr-format t)
  (setq display-time-use-mail-icon t)
  (setq display-time-default-load-average nil)

  (display-time-mode t)
#+end_src

*** Emacs Title Bar
:PROPERTIES:
:ID:       0d4859aa-e015-4399-a8a5-4aae3471872c
:END:

RescueTime and other resources use the title bar to assess what an
application is doing. I use that to include the mode of the file I'm
currently looking at, so I can categorize what I'm doing in
emacs. Unfortunately, I haven't figured out how to include the
projectile project as well, as this would make it easy to see what was
"in scope" for something.

#+begin_src emacs-lisp
  (setq frame-title-format '("%m " invocation-name "@" (system-name)))
#+end_src

** System sepecific settings
   :PROPERTIES:
   :ID:       9af79705-bbb1-4b52-bfe7-0e05831d87b0
   :END:

Had to do some funky stuff to get around how shitty Mac OS X default
VPN settings are. Also, set different font sizes for the different
screen DPI's.

#+begin_src emacs-lisp
  (defun cm/produce-font (size)
    (let* ((sizestr (number-to-string size))
	   (suffix "") ;; manually set hinting things here
	   (fixed (concat "DejaVu Sans Mono-" (number-to-string size) suffix))
	   (variable (concat "EtBembo-" (number-to-string (* size 1.3)) suffix)))
      (set-face-attribute 'default nil :font fixed)
      (set-face-attribute 'fixed-pitch nil :font fixed)
      (if (find-font (font-spec :name "EtBembo-12"))
	  (set-face-attribute 'variable-pitch nil :font variable)
	(set-face-attribute 'variable-pitch nil :font fixed))))


  (cond
    ((equal (system-name) "penolpe")
     (cm/produce-font 9))
    ((equal (system-name) "jmickey-mbp")
     (cm/produce-font 13))
    (t
     (cm/produce-font 11)))

  ;; gotta figure out a better way for unicode
  ;;
  ;; This doesn't work currently because emacs doesn't support color bitmaps.
  ;  (cond
  ;   ((member "Noto Color Emoji" (font-family-list))
  ;    (set-fontset-font t 'unicode "Noto Color Emoji" nil 'prepend))
  ;   ((member "symbola" (font-family-list))
  ;    (set-fontset-font t 'unicode "Symbola" nil 'prepend)))


#+end_src
* Environment
  :PROPERTIES:
  :ID:       75fc0c8b-e66b-4f0f-ad21-72adef4fd23e
  :END:

** Prefer newer code
:PROPERTIES:
:ID:       352066ee-f4d6-4748-98c6-4057ff8622ab
:END:
Avoids the problem where bytecode is older and loaded by emacs.

#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src

** Common Lisp
    :PROPERTIES:
    :ID:       5803e34a-7304-429a-ba92-f69e14623941
    :END:

Common lisp has things like =cl-loop=, which are life.

#+begin_src emacs-lisp
  (require 'cl-lib)
#+end_src

** TLS Security shenanigans
:PROPERTIES:
:ID:       324041E0-984C-4004-829A-97DFE4800DCE
:END:

Mac OS X is TERRIBLE.
#+begin_src emacs-lisp
  (require 'gnutls)
  
  (when (eq system-type 'darwin)
    (add-to-list 'gnutls-trustfiles "/private/etc/ssl/cert.pem"))
  (setq gnutls-verify-error t
	network-security-level 'high)
  
#+end_src

** Yes I can scroll left
   :PROPERTIES:
   :ID:       4ac2d83a-08d8-437d-8937-e8775ae454b9
   :END:
#+begin_src emacs-lisp
  (put 'scroll-left 'disabled nil)
#+end_src

** Dvorak
   :PROPERTIES:
   :ID:       662be27f-102a-42dd-8a9e-c9b7269fc129
   :END:
The dvorak keyboard layout is really advantageous to those of us who
write emails all day (read: me). However, it does create some problem
with things like =C-x= in Emacs. In dvorak, =x= is =b= on the
keyboard, meaning you're reaching quite far with your hand.

I'm going to try out switching =C-t= and =C-x= as per suggested by
[[http://ergoemacs.org/emacs/emacs_dvorak_C-x.html][XahLee's page]] on the dvorak =C-x= problem.

#+begin_src emacs-lisp
  (keyboard-translate ?\C-x ?\C-t)
  (keyboard-translate ?\C-t ?\C-x)
#+end_src

Also, let's get angry about using C-x until I'm used to it actually being C-t.

#+begin_src emacs-lisp
  (global-set-key
   (kbd "C-t") 
   (lambda ()
     (interactive)
     (run-with-timer 
      0.3 nil 
      (lambda ()
        ;; Assuming these are the default values
        (setq visible-bell nil)
        (setq ring-bell-function 'ignore)))
     (setq visible-bell t)
     (setq ring-bell-function nil)
     (error "Don't press that button.")))
#+end_src

** Shell paths
   :PROPERTIES:
   :ID:       0e40240f-a2c3-4c03-b55d-d66e5cc0ce44
   :END:

Add some normal locations to the path in case it's not when I click an
emacs icon (instead of launching from the shell).
#+begin_src emacs-lisp
  (when (eq system-type 'gnu/linux)
    (let* ((home-dir (getenv "HOME"))
	   (linux-paths
	    `(,(concat home-dir "/bin")
	      ,(concat home-dir "/.guix-profile/bin"))))
      (setenv "PATH" (concat (mapconcat 'identity linux-paths ":")
			     ":"
			     (getenv "PATH")))
      (setq exec-path (append linux-paths exec-path))))
#+end_src

Setting paths correctly depending on whether or not I'm on a
Mac. Mostly these days, I'm on +a Mac :/+ linux!! :)
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (prefer-coding-system 'utf-8)
    (setq file-precious-flag t)
    (let* ((home-dir (getenv "HOME"))
	   (mac-paths `("/Applications/Emacs.app/Contents/MacOS/bin"
			,(concat home-dir "/bin")
			,(concat home-dir "/homebrew/bin")
			,(concat home-dir "/.cabal/bin")
			"/opt/local/bin"
			"/usr/local/texlive/2010/bin/x86_64-darwin"
			"/usr/local/bin"
			"/usr/local/sbin"
			"/usr/bin"
			"/usr/sbin"
			"/bin"
			"/sbin")))
      (setenv "PATH" (concat (mapconcat 'identity mac-paths ":")
			     ":"
			     (getenv "PATH")))
      (setq exec-path (append exec-path mac-paths))))
#+end_src

** Emacs load paths
   :PROPERTIES:
   :ID:       746a0b8d-ef35-4cff-81d7-e8d2c3d49d8c
   :END:
Get my site-lisp set up. Got rid of ye old pkg-init!
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/site-lisp")
#+end_src
Also, load sub directories underneath site-lisp. This lets me copy
random tar balls of elisp without having to worry how it's all
formatted.

Special thanks to benny, who started me down this epic emacs journey
who provided this original functionality for me.
#+begin_src emacs-lisp
  (defun dirs-inside-directory (parent)
    (let (foo)
      (dolist (file (directory-files parent t))
	(when (and (not (member (file-name-nondirectory file)
				'("." "..")))
		   (file-directory-p file))
	  (setq foo (cons file foo))))
      foo))

  ;; Automagically load all folders in site-lisp as well! Thank you benny!
  (defvar cm/lisp-dirs '("~/.emacs.d/site-lisp"
	 	         "~/.emacs.d/site-lisp/xelb"
		         "~/.emacs.d/site-lisp/org-contrib"
		         "~/.emacs.d/site-lisp/org-contrib/lisp"
		         "~/.guix-profile/share/emacs/site-lisp"
		         "~/.guix-profile/share/emacs/site-lisp/guix.d")
    "List of directories to load from lisp.")
  (mapc (lambda (x) (when (file-directory-p x)
		      (mapc (lambda (y)
			      (add-to-list 'load-path y))
			    (dirs-inside-directory x))))
	cm/lisp-dirs)
#+end_src

*** Guix Support
    :PROPERTIES:
    :ID:       3b701aeb-81ae-4f4a-ab79-1f4633c9ebf5
    :END:
This adds the load path of the guix profile of the current user. I'm
currently using guix to manage packages for my local users.

This probably works better in GuixSD - but the systemd / dmd crap and
the icecat / firefox crap keeps me using arch as my base system.
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.guix-profile/share/emacs/site-lisp")
#+end_src
** Yes or no, let's do y/p
   :PROPERTIES:
   :ID:       8a6a8bc1-7cd0-4016-9381-a04bca6592cf
   :END:
Oh my freaking god, just take my damn answer.
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src
** Async Shell Command
   :PROPERTIES:
   :ID:       8e9761de-a184-4c69-9143-610d16291567
   :END:
This makes sure that we pick a new buffer and just run with it,
instead of checking if another process is running.

#+begin_src emacs-lisp
  (setq async-shell-command-buffer 'rename-buffer)
#+end_src
** Convenient global keys
   :PROPERTIES:
   :ID:       b3d4ed04-e17a-45f4-a21e-e51071f1f505
   :END:
God I love backword-kill-word. Also some bookmarks
#+begin_src emacs-lisp
  (global-set-key "\C-w" 'backward-kill-word)
  (global-set-key "\C-x\C-k" 'kill-region)

  ;; not really using this..
  ;(global-set-key [f5] 'bookmark-bmenu-list)
  ;(global-set-key [f6] 'bookmark-set)
  ;(global-set-key [f7] 'bookmark-jump)

  (defun cm/backward-kill (killwordf &optional arg)
      "Replacement for the backward-kill-word command
  If the region is active, then invoke kill-region.  Otherwise, use
  the following custom backward-kill-word procedure.
  If the previous word is on the same line, then kill the previous
  word.  Otherwise, if the previous word is on a prior line, then kill
  to the beginning of the line.  If point is already at the beginning
  of the line, then kill to the end of the previous line.

  With argument ARG and region inactive, do this that many times."
    (interactive "p")
    (if (use-region-p)
	(kill-region (mark) (point))
      (dotimes (_count arg)
	(if (bolp)
	    (delete-char -1)
	  (kill-region (max (save-excursion
			      (funcall killwordf arg)
			      (point))
			    (line-beginning-position))
		       (point))))))

  ;; handle subword / superword modes as well!
  (defun cm/backward-kill-subword (&optional arg)
    (interactive "p")
    (cm/backward-kill 'subword-backward-kill arg))

  ; I don't think this is necessary, but we'll see
  ;(defun cm/backward-kill-superword (&optional arg)
  ;  (interactive "p")
  ;  (cm/backward-kill 'superword-backward-kill arg))

  (defun cm/backward-kill-word (&optional arg)
    (interactive "p")
    (cm/backward-kill 'backward-kill-word arg))

  (define-key (current-global-map)
    [remap backward-kill-word] 'cm/backward-kill-word)

  ;; get subword's map
  (require 'subword)
  (define-key subword-mode-map
    [remap backward-kill-word] 'cm/backward-kill-subword)
#+end_src
** Narrow regions
   :PROPERTIES:
   :ID:       69621834-2ad9-460e-b2f2-e698bee359a8
   :END:
#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+end_src
** kill with linum
   :PROPERTIES:
   :ID:       debaee9f-a2d7-4545-b366-bc583870c1da
   :END:
Really useful for source code copying.. This is from [[http://stackoverflow.com/questions/12165205/how-to-copy-paste-a-region-from-emacs-buffer-with-line-file-reference][stack overflow]].

#+begin_src emacs-lisp
  (defun kill-with-linenum (beg end)
    (interactive "r")
    (save-excursion
      (goto-char end)
      (skip-chars-backward "\n \t")
      (setq end (point))
      (let* ((chunk (buffer-substring beg end))
             (chunk (concat
                     (format "╭──────── #%-d ─ %s ──\n│ "
                             (line-number-at-pos beg)
                             (or (buffer-file-name) (buffer-name)))
                     (replace-regexp-in-string "\n" "\n│ " chunk)
                     (format "\n╰──────── #%-d ─" 
                             (line-number-at-pos end)))))
        (kill-new chunk)))
    (deactivate-mark))
#+end_src

** goto-line should work on first M-g
   :PROPERTIES:
   :ID:       66fbcae2-109f-4a0d-9d68-7474fb30c92a
   :END:
taken from http://blog.akinori.org/2013/05/27/m-g-vs-goto-line/

#+begin_src emacs-lisp
  (defun cm/goto-line-number ()
    (interactive)
    (goto-char (point-min))
    (forward-line (1- (string-to-number
		       (read-from-minibuffer
			"Goto line: "
			(char-to-string last-command-event))))))

  (cl-loop for n from 1 to 9 do
	(global-set-key (format "\M-g%d" n) 'cm/goto-line-number))
  (global-set-key "\M-g?" 'describe-prefix-bindings)
#+end_src

** Use dired instead of the directory view.
   :PROPERTIES:
   :ID:       6ed4dffb-c6ce-46b1-90b8-76c735285063
   :END:
I never expect it, and when I get it it means I meant dired
anyways. This means that how I hold down the control button doesn't
matter.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-d") 'dired)
#+end_src

** Windowing Management
:PROPERTIES:
:ID:       dc04bcc3-4632-48de-863b-25964a7de4dc
:END:
*** Toggle Layout
:PROPERTIES:
:ID:       eee4070d-06a2-4c78-9581-5951f10acff3
:END:
#+begin_src emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+end_src
*** Rotate currently viewed windows
:PROPERTIES:
:ID:       8cfa2f90-d8db-4b16-aee7-13fbe314aeb6
:END:
From: https://www.emacswiki.org/emacs/TransposeWindows on [2019-01-17 Thu]

 Yet another window-altering function by Robert Bost slightly based on
Steve Yegge’s swap-windows and further modified by Collin Doering and
others. This one will handle > 1 windows. It also accepts a prefix
argument which rotates the other direction. Additionally given a
numeric prefix argument n, it will rotate the windows n times; if the
numeric argument is negative rotates |n| times in the other direction.

#+begin_src elisp
  (defun rotate-windows (arg)
    "Rotate your windows; use the prefix argument to rotate the other direction"
    (interactive "P")
    (if (not (> (count-windows) 1))
	(message "You can't rotate a single window!")
      (let* ((rotate-times (prefix-numeric-value arg))
	     (direction (if (or (< rotate-times 0) (equal arg '(4)))
			    'reverse 'identity)))
	(dotimes (_ (abs rotate-times))
	  (dotimes (i (- (count-windows) 1))
	    (let* ((w1 (elt (funcall direction (window-list)) i))
		   (w2 (elt (funcall direction (window-list)) (+ i 1)))
		   (b1 (window-buffer w1))
		   (b2 (window-buffer w2))
		   (s1 (window-start w1))
		   (s2 (window-start w2))
		   (p1 (window-point w1))
		   (p2 (window-point w2)))
	      (set-window-buffer-start-and-point w1 b2 s2 p2)
	      (set-window-buffer-start-and-point w2 b1 s1 p1)))))))

  (define-key ctl-x-4-map (kbd "t") 'rotate-windows)
#+end_src
** Use rc escaping
   :PROPERTIES:
   :ID:       e039c4cd-5660-419a-80ca-c9fbb80be5d6
   :END:
I've now set my login shell as rc, which means that now all kinds of
arbitrary things break.

Luckily, the =shell-quote-argument= function is really easy to write,
because it really just is string replacement on the single quote. And
unquoting isn't even a thing because rc doesn't fucking suck at life,
it just passes on arguments. It's wonderful!
#+begin_src emacs-lisp
  (defvar cm/using-rc t
    "Set to true when I'm using rc as my main shell")

  (defun cm/advise-shell-quote-argument (fun &rest args)
    (if (and cm/using-rc
	     (not (file-remote-p default-directory)))
	(concat "'" (replace-regexp-in-string "'" "''" (if (listp args) (car args) args) t t) "'")
      (apply fun args)))

  (advice-add #'shell-quote-argument :around #'cm/advise-shell-quote-argument)

#+end_src
*** Support for rgrep as well
    :PROPERTIES:
    :ID:       27803a70-fbb5-491f-a962-e183b14af385
    :END:
This changes the =grep-find-template= so that quoting is used around
the brackets that rc parses.
#+begin_src emacs-lisp
  (eval-after-load "grep"
    (lambda ()
      (grep-apply-setting 'grep-find-template "find . <X> -type f <F> -exec grep <C> -nH -e <R> '{}' '+'")))
#+end_src
** Performance improvement of vertical window scroll
:PROPERTIES:
:ID:       c1415bc7-3497-42c4-bc97-8167271b040d
:END:

https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746

This just removes some of the window scroll calculus, which improves
=C-n= speed. This should really not be something I have to set
however.

#+begin_src emacs-lisp
  (setq auto-window-vscroll nil)
#+end_src
** defun-local
:PROPERTIES:
:ID:       8e9a2892-9e68-482b-a3a5-ecddce3c572c
:END:
This uses two macros, that make it easier for me to define commands
(like =org-agenda=, =notmuch-search=, etc) that shouldn't regularly
depend on TRAMP. If they do, make sure it's not because of the current
buffer.

This may mess up org-agenda if I'm doing crazier agenda stuff later.
#+begin_src emacs-lisp
  (defmacro cm/defun-local (funcname args &rest body)
    "Create a function that always operates without tramp on the local system."
    `(defun ,funcname ,args
       (interactive)
       (with-current-buffer (get-buffer-create "*scratch*")
	 ,@body)))

  (defmacro cm/defun-local-wrap (funcname towrap)
    "Create a function that always operates without tramp on the local system."
    `(cm/defun-local ,funcname () (,towrap)))

#+end_src
** Delete surrounding whitespace
:PROPERTIES:
:ID:       89e301ee-280c-4334-b518-ea4629f22ac2
:END:
Super useful when killing and pasting lines, as selecting regions in
emacs is not my forte.
#+begin_src emacs-lisp
  (defun cm/delete-surrounding-whitespace ()
    (interactive)
    (let ((skip-chars "\n\r\t "))
      (skip-chars-backward skip-chars)
      (let* ((start (point))
	     (num (progn
		    (skip-chars-forward skip-chars)
		    (point))))
	(delete-region start num))))

  (global-set-key (kbd "C-<delete>") 'cm/delete-surrounding-whitespace)
#+end_src
** Org File Location
:PROPERTIES:
:ID:       fa39e5f7-7a63-4379-8d53-cbb2ad4decbd
:END:
#+begin_src emacs-lisp
  (defvar cm/org-directory "~/org")
  ;; Use dropbox when available. Yes making this conditional is awkward,
  ;; but it helps me avoid the IT security dragon if I'm on a work
  ;; computer.
  (when (file-exists-p "~/Dropbox/org/gtd.org")
    (setq cm/org-directory "~/Dropbox/org"))
  (defun cm/org-dir (&rest args)
    (if (< (length args) 1)
	cm/org-directory
      (concat cm/org-directory
	      (if (string-prefix-p "/" (car args))
		  ""
		"/")
	      (car args))))
#+end_src
* ELPA
  :PROPERTIES:
  :ID:       75916850-2b29-435f-8f66-2d17704fe83d
  :END:
I organize my packages use with the amazing https://github.com/jwiegley/use-package
#+begin_src emacs-lisp
  (require 'use-package)
  (require 'use-package-diminish)
  (require 'bind-key)
#+end_src
* Color theme
  :PROPERTIES:
  :ID:       884f8d9a-73d2-422d-9344-4b752eb1e352
  :END:
Yup, zenburn.

If zenburn isn't available, we should use wombat. So how do we detect
that?

#+begin_src emacs-lisp
  (defadvice load-theme (before theme-dont-propagate activate)
    "Disable theme before loading new one."
    (mapc #'disable-theme custom-enabled-themes))

  (defvar cm/theme-style 'dark
    "What style of preferred theme I'm using")

  (defvar cm/theme-before-hook '()
    "Hooks to run before setting a theme")

  (defvar cm/theme-after-hook '()
    "Hooks to run after setting a theme")

  (defvar cm/configured-theme-styles '(dark light author)
    "Which styles are currently configured for use")

  (defun cm/set-theme (theme)
    (interactive "Theme to swap to: ")
    (run-hooks 'cm/theme-before-hook)
    (pcase theme
      ('dark
       (progn (setq cm/theme-style 'dark)
	      (load-theme 'wombat t)))
      ('light
       (progn (setq cm/theme-style 'light)
	      (load-theme 'adwaita t)))
      ('author
       (progn (setq cm/theme-style 'author)
	      (load-theme 'poet t))))
    (run-hooks 'cm/theme-after-hook))

  (defun cm/swap-theme ()
    (interactive)
    (pcase cm/theme-style
      ('dark (cm/set-theme 'light))
      ('light (cm/set-theme 'dark))))

  (cm/set-theme 'dark)
#+end_src

For now we just check that the name is valid.
* Builtin Fetaures/Modes
  :PROPERTIES:
  :ID:       7fc227dc-419d-435a-bbe3-3ca707d2c234
  :END:
** Disabled Functions
   :PROPERTIES:
   :ID:       eef4557b-bf86-4d40-bd7a-a7860f7d2777
   :END:
#+begin_src emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src
** Backups
:PROPERTIES:
:ID:       ddff75a7-49ff-4a59-93a3-cf159b5036ed
:END:

This enables file backups to N versions of saves, as opposed to only
backing up the very first save. I don't re-launch emacs that often so
this is necessary to get useful backups.

#+begin_src emacs-lisp
  (setq vc-make-backup-files t
	version-control t
	kept-new-versions 10
	kept-old-versions 0
	delete-old-versions t
	backup-by-copying t
	backup-directory-alist `(("." . ,(concat (getenv "HOME")"/.emacs-backup"))))

  (defun cm/force-backup-of-buffer ()
    (let ((buffer-backed-up nil))
      (backup-buffer)))

  (add-hook 'before-save-hook 'cm/force-backup-of-buffer)
#+end_src

** Open files with root
   :PROPERTIES:
   :ID:       0e0b7076-92fc-45a0-a89d-e1051988c44d
   :END:
#+begin_src emacs-lisp
  (defun cm/rename-tramp-buffer ()
    (when (file-remote-p (buffer-file-name))
      (rename-buffer
       (format "%s:%s"
	       (file-remote-p (buffer-file-name) 'method)
	       (buffer-name)))))

  ;;(add-hook 'find-file-hook
  ;;          'cm/rename-tramp-buffer)

  (defadvice find-file (around th-find-file activate)
    "Open FILENAME using tramp's sudo method if it's read-only."
    (let ((thefile (ad-get-arg 0)))
      (if (or (string-prefix-p "/etc" thefile)
	      (string-prefix-p "/boot" thefile))
	  (if (and (not (file-writable-p thefile))
		   (y-or-n-p (concat "File "
				     thefile
				     " is read-only.  Open it as root? ")))
	      (cm/find-file-sudo thefile))))
    ad-do-it)

  (defun cm/find-file-sudo (file)
    "Opens FILE with root privileges."
    (interactive "F")
    (set-buffer (find-file (concat "/sudo::" file))))
#+end_src
** Doc View
:PROPERTIES:
:ID:       b356fbe9-80e3-4807-98af-97c47591c95b
:END:
Increase the DPI to a factor of most screen DPI's.
#+begin_src emacs-lisp
  (setq doc-view-resolution 288)
#+end_src
** Occur, isearch, and all
   :PROPERTIES:
   :ID:       7e4874a8-093c-4ac3-9441-5f8dd8103b39
   :END:
I like to launch occur from an isearch query. It's great when your
muscle memory searches for a word, THEN you realize you want to see it
all in one buffer. Rock the =C-c C-e= in occur mode and you can edit
everything! heck yes!

This used to be mostly taken from [[http://www.emacswiki.org/emacs/OccurFromIsearch][the emacs wiki]], but now it's a
function in emacs!
#+begin_src emacs-lisp
  (define-key isearch-mode-map (kbd "C-o") 'isearch-occur)
#+end_src
** Ediff
   :PROPERTIES:
   :ID:       90322ca4-3bef-4beb-92fb-036d3792660e
   :END:
Split the Ediff window depending on the orientation/size of the emacs
frame. I've found this very convenient.
#+begin_src emacs-lisp
  (require 'ediff)
  (setq ediff-split-window-function (lambda (&optional arg)
				      (if (> (frame-width) 150)
					  (split-window-horizontally arg)
					(split-window-vertically arg))))
#+end_src
*** Single frame ediff
:PROPERTIES:
:ID:       9457fa41-5d00-4311-9148-c83b79d54856
:END:
Keep the diff in a single window, easier on tiling window managers to
handle diff sessions.
#+begin_src emacs-lisp
  (setq ediff-window-setup-function #'ediff-setup-windows-plain)
#+end_src
*** Combine both in clashing diff
:PROPERTIES:
:ID:       9bc29176-f743-4ff3-bb93-5fa52060021d
:END:
Stolen from https://stackoverflow.com/questions/9656311/conflict-resolution-with-emacs-ediff-how-can-i-take-the-changes-of-both-version/29757750#29757750

#+begin_src emacs-lisp
  (defun cm/ediff-copy-both-to-C ()
    (interactive)
    (ediff-copy-diff
     ediff-current-difference
     nil 'C nil
     (concat
      (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
      (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
  (defun cm/add-d-to-ediff-mode-map ()
    (define-key ediff-mode-map "B" 'cm/ediff-copy-both-to-C))

  (add-hook 'ediff-keymap-setup-hook 'cm/add-d-to-ediff-mode-map)
#+end_src

** Useful window functions
   :PROPERTIES:
   :ID:       6fdd1fc3-0b07-4d30-b351-289529bfa72c
   :END:
from :
http://www.emacswiki.org/emacs/Rick_Bielawski
#+begin_src emacs-lisp
  ;; Idea and starter code from Benjamin Rutt (rutt.4+news@osu.edu) on comp.emacs
  (defun window-horizontal-to-vertical ()
    "Switches from a horizontal split to a vertical split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-horizontally)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))

  ;; complement of above created by rgb 11/2004
  (defun window-vertical-to-horizontal ()
    "Switches from a vertical split to a horizontal split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-vertically)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))
#+end_src
** Private stuff
   :PROPERTIES:
   :ID:       e0b91792-b154-44f6-837c-25e8bf526f72
   :END:
Just an easy way to put passwords, and other sensitive data outside of
this emacs config! Ideally I'll document all variables missing, this
may or may not be always true though.
#+begin_src emacs-lisp
  ;; irc
  (defvar cm/freenode-password "nope" "The nickserv password for freenode.")
  (defvar cm/oftc-password "nope" "The nickserv password for oftc.")
  (defvar cm/what-password "nope" "The nickserv password for what.")
  (defvar cm/rizon-password "nope" "The nickserv password for rizon.")
  (defvar cm/bitlbee-password "nope" "The password for bitlbee!")
  (defvar cm/slack-password "nope" "The password for PureStorage IRC integration")
  (defvar cm/rcirc-channel-alist '(("freenode" "#archlinux" "#emacs")
                                 ("oftc" "#ikiwiki"))
    "The channel list..")
  (defvar cm/identica-username "nope" "The password for bitlbee!")
  (defvar cm/identica-password "nope" "The password for bitlbee!")
  (defvar cm/erc-keywords "nope" "The password for bitlbee!")
  (defvar cm/erc-autojoin-channels-alist '("#emacs") "the default list for erc chan.")
  (defvar cm/rcirc-server-alist '() "The password for bitlbee!")
  (defvar cm/ironport-p4port "" "p4port")
  (defvar cm/mu4e-refile-folder (lambda (_) '()) "refile!")
  (defvar cm/erc-track-exclude "" "track exclude")


  (let ((private-file "~/.emacs-priv.el"))
    (when (file-exists-p private-file)
      (load-file private-file)))
#+end_src
** Printing
   :PROPERTIES:
   :ID:       bad1e0c5-424a-40d2-839b-c2efb24e66af
   :END:
#+begin_src emacs-lisp
  ;(require 'lpr)
  (setq lpr-command "gtklp")
#+end_src
** Sticky buffer
   :PROPERTIES:
   :ID:       6c124562-896f-460c-bc65-a8dbea21f347
   :END:
Inspired by [[http://www.reddit.com/r/emacs/comments/gjqki/is_there_any_way_to_tell_emacs_to_not/c1o26uk][a reddit comment]].
#+begin_src emacs-lisp
  ;;  (defadvice pop-to-buffer (before cancel-other-window first)
  ;;    (ad-set-arg 1 nil))

  ;;  (ad-activate 'pop-to-buffer)

  ;; Toggle window dedication
  (defun toggle-window-dedicated ()
    "Toggle whether the current active window is dedicated or not"
    (interactive)
    (message
     (if (let ((window (get-buffer-window (current-buffer))))
	   (set-window-dedicated-p window
				   (not (window-dedicated-p window))))
	 "Window '%s' is dedicated"
       "Window '%s' is normal")
     (current-buffer)))

  ;; Press [pause] key in each window you want to "freeze"
  (global-set-key [f11] 'toggle-window-dedicated)
#+end_src
** Narrow to indirect buffer
   :PROPERTIES:
   :ID:       4636f0d8-0f7c-4e5b-b146-6b9c13a1422c
   :END:
There was a [[http://demonastery.org/2013/04/emacs-narrow-to-region-indirect/][blog post]] on [[http://www.reddit.com/r/emacs/comments/1clte0/narrowtoregionindirect_for_emacs/][reddit]] about this, and It's too good to not
use. I haven't decided what the key binding should really be yet. Al
#+begin_src emacs-lisp
  (defun cm/narrow-to-region-indirect (start end)
    "Restrict editing in this buffer to the current region, indirectly."
    (interactive "r")
    (when (fboundp 'evil-exit-visual-state) ; There's probably a nicer way to do this
      (evil-exit-visual-state))
    (let ((buf (clone-indirect-buffer nil nil)))
      (with-current-buffer buf
        (narrow-to-region start end))
      (switch-to-buffer buf)))

  (global-set-key (kbd "C-x n i") 'cm/narrow-to-region-indirect)
#+end_src
** Revert
   :PROPERTIES:
   :ID:       7d79056d-8843-4cc0-a6c2-3628609e8c19
   :END:
To revert a buffer easily, put the char back where I had it.
#+begin_src emacs-lisp
  (defun cm/revert-buffer ()
    "save the current position to tmp, revert buffer, go back to tmp"
    (interactive)
    (cm/revert-specific-buffer (current-buffer)))

  (defun cm/revert-specific-buffer (buf)
    "save the current position to tmp, revert buffer, go back to tmp"
    (interactive "bBuffer: ")
    (with-current-buffer buf
      (let ((tmp (point)))
        (revert-buffer t)
        (goto-char tmp))))

  (global-set-key [f8] 'cm/revert-buffer)
#+end_src
** Windmove
   :PROPERTIES:
   :ID:       a4484933-7915-4419-bef5-2aed3e288ab8
   :END:
Easy navigation around lots of splits. C-x o isn't that geographical.
#+begin_src emacs-lisp
  (global-set-key (kbd "s-<left>") 'windmove-left)
  (global-set-key (kbd "s-<right>") 'windmove-right)
  (global-set-key (kbd "s-<up>") 'windmove-up)
  (global-set-key (kbd "s-<down>") 'windmove-down)
#+end_src
** Dired
   :PROPERTIES:
   :ID:       5ad3253d-9cd5-4b61-b2fb-e6c788e63751
   :END:
This is what is sent to ls. I'm usually on a *nix-like userspace, so
ls usually exists. On windows emacs uses some ls elisp, I'm not sure
if these settings work for that.
#+begin_src emacs-lisp
  (setq dired-listing-switches "-ahlF")
#+end_src
On Mac OS X, ls -F prints an @ symbol when printing symlinks. This
setting lets dired know that this is the case.
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq dired-ls-F-marks-symlinks t))
#+end_src
*** Disabled: set dired to reuse buffers
    :PROPERTIES:
    :ID:       d5fddb2a-1cfc-423b-960a-eeb2d14894d0
    :END:
Every time you hit enter, instead of opening a new buffer, it'll reuse
the buffer. I've found I don't like using this, but it was very useful
when I first started using emacs, less so later.

Have =^= and =Enter= open the next directory in the same buffer.  I
don't think there is a situation where I don't want this to happen, so
we'll roll with this.
#+begin_src emacs-lisp
  ;; reenable!
  (put 'dired-find-alternate-file 'disabled nil)
  ;; (add-hook 'dired-mode-hook
  ;;  (lambda ()
  ;;   (define-key dired-mode-map (kbd "<return>")
  ;;     'dired-find-alternate-file) ; was dired-advertised-find-file
  ;;   (define-key dired-mode-map (kbd "a")
  ;;     'dired-advertised-find-file) ; was dired-find-alternate-file
  ;;   ; was dired-up-directory
  ;;   (define-key dired-mode-map (kbd "^")
  ;;     (lambda () (interactive) (find-alternate-file "..")))))
#+end_src
*** Insert subdirectory while folding the parent directory
:PROPERTIES:
:ID:       9d3f981e-9b94-4cde-bfac-f9fca96b60a7
:END:
Useful when navigating down through a hierachy that you may care about
later, but aren't sure.

#+begin_src emacs-lisp
  (defun cm/insert-n-hide-dired ()
    (interactive)
    (let ((fn (dired-get-filename)))
      (dired-hide-subdir 1)
      (dired-maybe-insert-subdir fn)))

  (require 'dired)
  (define-key dired-mode-map "I" 'cm/insert-n-hide-dired)
#+end_src
*** Attach a file to org-mode
:PROPERTIES:
:ID:       70838fe2-3577-4ea7-9c40-c1c67e7ebee1
:END:
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook
	    (lambda ()
	      (define-key dired-mode-map
		(kbd "C-c C-x a")
		#'org-attach-dired-to-subtree)))
#+end_src
** Image Mode
:PROPERTIES:
:ID:       e51cfa08-015a-44e2-af4f-2e9cab6645bd
:END:
Set an image to fit the current window
#+begin_src emacs-lisp
  (require 'image-mode)

  (defun cm/image-transform-fit-to-window ()
    (interactive)
    (let* ((wh (image-display-size (image-get-display-property) t))
	   (width (car wh))
	   (height (cdr wh))
	   (ratio (/ (float height) (float width)))
	   (edges (window-inside-pixel-edges (get-buffer-window (current-buffer))))
	   (window-width (- (nth 2 edges) (nth 0 edges)))
	   (window-height (- (nth 3 edges) (nth 1 edges)))
	   (window-ratio (/ (float window-height) (float window-width))))

      (if (> window-ratio ratio)
	  (image-transform-fit-to-width)
	(image-transform-fit-to-height))))

  (define-key image-mode-map (kbd "=") 'cm/image-transform-fit-to-window)
#+end_src
** Info
   :PROPERTIES:
   :ID:       cee7c2a5-33d5-43cb-abf3-de5174e78f95
   :END:
Mac fix for info installation location!
#+begin_src emacs-lisp
  (require 'info)
  (when (eq system-type 'darwin)
    (setq Info-directory-list
          (cons
           (expand-file-name "/opt/local/share/info/")
           Info-directory-list)))
#+end_src
** Pcomplete
   :PROPERTIES:
   :ID:       0e0b04db-4a10-473d-9a12-a19190b1878e
   :END:
#+begin_src emacs-lisp
;  (require 'pcmpl-git)
#+end_src
** Shell (using rakitzis' rc)
   :PROPERTIES:
   :ID:       bf047787-944d-4eff-a8c1-dfef5f1ac63a
   :END:
*** Shell Session Management
    :PROPERTIES:
    :ID:       6d275e25-9de3-4c12-8765-fd96be7d209c
    :END:
I need to tie this into projectile, but for now have a way to create a
"main" buffer and then name other ones with =shell-new=.
#+begin_src emacs-lisp
  ;; give shell advice to load dir-locals

  (defun cm/advise-shell (&rest _)
    (hack-dir-local-variables-non-file-buffer))

  (advice-add #'shell :before #'cm/advise-shell)

  (defun cm/shell-new-emacs-shell (name)
    "Create a shell buffer named NAME."
    (interactive "sShell Name: ")
    (let* ((bn (concat "*shell:" name "*"))
	   (eb (get-buffer bn)))
      (if (and eb (get-buffer-process eb))
	  (switch-to-buffer eb)
	(shell bn))))

  (when (eq system-type 'gnu/linux)
    (use-package vterm
      :config
      (defun cm/vterm-mode-hook ()
	(setq-local global-hl-line-mode nil))    
      (add-hook 'vterm-mode-hook #'cm/vterm-mode-hook)
      (defun cm/shell-new-vterm (name)
	"Create a vterm buffer named NAME."
	(interactive "sShell Name: ")
	(let* ((bn (concat "*shell:" name "*"))
	       (eb (get-buffer bn)))
	  (if (and eb (get-buffer-process eb))
	      (switch-to-buffer eb)
	    (vterm bn))))))

  (defun cm/shell-new (name)
    "Create a shell buffer named NAME."
    (interactive "sShell Name: ")
    ;; Problems with vterm were odd and indegestible. I think I will use
    ;; vterm directly if I need it. Extremely useful to have around.
    ;; (cm/shell-new-vterm name)
    (cm/shell-new-emacs-shell name))

  (defun cm/current-shells ()
    (require 'subr-x)
    (delq nil
	  (mapcar
	   (lambda (x)
	     (if (string-prefix-p "*shell:" (buffer-name x))
		 `(,(string-remove-prefix "*shell:" (string-remove-suffix "*" (buffer-name x))) ,x)))
	   (buffer-list))))

  (defun cm/shell-find-or-new ()
    "Find or create a shell with the given name"
    (interactive)
    (let ((selected-shell (completing-read
			   "Shell Name: "
			   (cm/current-shells))))
      (cm/shell-new selected-shell)))

  (defun cm/shell-main ()
    (interactive)
    (cm/shell-new "main"))

  (defun cm/shell-projectile ()
    (interactive)
    (projectile-with-default-dir (projectile-project-root)
      (cm/shell-new (projectile-project-name))))

  (global-set-key (kbd "<f2>") 'cm/shell-find-or-new)
  (global-set-key (kbd "<f7>") 'cm/shell-main)
#+end_src
**** Remote Shells
:PROPERTIES:
:ID:       787a4137-6ad4-4e72-97fa-2c40416ce0c9
:END:
This is to manage remote shells. I hope for this to get a *lot* more
sophisticated, as ideally you'd be able to restore scrollback as
well. Ideally dtach would actually have support for replaying
scrollback, but not sure how it would handle it given it doesn't
really interpret anything.

#+begin_src emacs-lisp
  (require 'shell)

  (defvar explicit-dtach-args '()
    "List of explicit arguments to dtach.")

  (defvar cm/machines '()
    "List of machines to think about.")

  (defun cm/ssh-dtach-list-sessions (host)
    (map 'list (lambda (x) (string-remove-prefix ".dtach.emacs." x))
	 (directory-files (concat "/ssh:" host ":/tmp/") nil "^\\.dtach\\.emacs\\.." t)))

  (defun cm/ssh-dtach (host session)
    "Open SSH connection to HOST with SESSION and start dtach session."
    (interactive
     (let* ((host (completing-read "Host: " cm/machines nil 'confirm))
	    (session  (completing-read "Session: " (cm/ssh-dtach-list-sessions host) nil 'confirm)))
       (list host session)))
    (let ((explicit-shell-file-name "dtach")
	  (explicit-dtach-args `("-A" ,(concat "/tmp/.dtach.emacs." session) "-z"
				 "/usr/bin/rc" "-l"))
	  (default-directory (concat "/ssh:" host ":/")))
      (shell (format "*shell:%s-%s*" host session))))
#+end_src
*** Use a login shell 
    :PROPERTIES:
    :ID:       1f6334ef-51f3-417d-acc6-c578c2a9223b
    :END:
#+begin_src emacs-lisp
  (set-default 'explicit-shell-file-name (concat (getenv "HOME") "/bin/rc"))
  (defvar explicit-rc-args '("-l")
    "List of explicit arguments to rc.")

  (when (string-equal (system-name) "jmickey-glaptop0")
    (set-default 'explicit-shell-file-name (concat (getenv "HOME") "/.guix-profile/bin/rc"))
    (setq explicit-rc-args nil))

  (defun cm/darwin-shell-settings ()
    (setq comint-process-echoes t))

  (when (string-equal (system-name) "jmickey-mbp")
    (set-default 'explicit-shell-file-name (concat (getenv "HOME") "/bin/rc"))
    (add-hook 'shell-mode-hook 'cm/darwin-shell-settings))
#+end_src
*** Track the directory of the shell process
    :PROPERTIES:
    :ID:       7ffc7964-0afc-4ca1-8b1d-7f1b0da0b35d
    :END:
#+begin_src emacs-lisp
  (defun shell-procfs-dirtrack (str)
    (prog1 str
      (if (stringp str)
          (let ((directory (file-symlink-p
                        (format "/proc/%s/cwd"
                                (process-id
                                 (get-buffer-process
                                  (current-buffer)))))))
            (if directory
                (when (file-directory-p directory)
                  (cd directory)))))))

  (define-minor-mode shell-procfs-dirtrack-mode
    "Track shell directory by inspecting procfs."
    nil nil nil
    (cond (shell-procfs-dirtrack-mode
           (when (bound-and-true-p shell-dirtrack-mode)
             (shell-dirtrack-mode 0))
           (when (bound-and-true-p dirtrack-mode)
             (dirtrack-mode 0))
           (add-hook 'comint-preoutput-filter-functions
                     'shell-procfs-dirtrack nil t))
          (t
           (remove-hook 'comint-preoutput-filter-functions
                        'shell-procfs-dirtrack t))))
#+end_src

#+begin_src emacs-lisp
  (require 'tramp)

  (setq comint-scroll-to-bottom-on-input t    ; always insert at the bottom
        comint-scroll-to-bottom-on-output nil ; always add output at the bottom
        comint-scroll-show-maximum-output t   ; scroll to show max possible output
        comint-input-ignoredups t             ; no duplicates in command history
        comint-completion-addsuffix t         ; insert space/slash after file completion
        comint-buffer-maximum-size 40000      ; max length of the buffer in lines
        comint-prompt-read-only t             ; if this is t, it breaks shell-command (we'll see about that)
        comint-get-old-input (lambda () "")   ; what to run when i press enter on a
                                              ; line above the current prompt
        comint-input-ring-size 5000           ; max shell history size
        protect-buffer-bury-p nil)

  ;; make sure that comint in shell mode doesn't try to quote file
  ;; names! this is annoying as fuck!
  (setq shell-file-name-quote-list nil)
  (setenv "PAGER" "cat")
  (setenv "MANPAGER" "cat")

  ;; truncate buffers continuously
  (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)

  ;; interpret and use ansi color codes in shell output windows is the
  ;; default. If you want to filter out there existence, then do the
  ;; following:
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-filter)
  ;;
  ;; instead, I'm going to have it do nothing!
  ;;(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-off)

  (defun set-scroll-conservatively ()
    "Add to shell-mode-hook to prevent jump-scrolling on newlines in shell buffers."
    (set (make-local-variable 'scroll-conservatively) 10))
  (add-hook 'shell-mode-hook 'set-scroll-conservatively t)
  (add-hook 'shell-mode-hook 'shell-procfs-dirtrack-mode t)
  (add-hook 'shell-mode-hook (lambda () (font-lock-mode -1)))

#+end_src

*** Use a better async-shell-command 
:PROPERTIES:
:ID:       fb5fdaa3-3287-495c-b047-e7c8c5533271
:END:
The =*Async Shell Command*= buffer naming is bullshit. Here is
something much better, it names each buffer =*shell:<cmd>*= so my
above shell searching functions also find these buffers. Eventually
I'd like something where these are launched automatically from any
command run in shell mode, but we'll see.

#+begin_src emacs-lisp
  (defun cm/exec-shell (oldfun scmd)
    (interactive "sShell Command: ")
    (let* ((shell-to-exec (or (locate-file "rc" exec-path) "/bin/sh"))
           (base-name (replace-regexp-in-string "[^a-z]+" "-" (downcase scmd)))
           (short-name (if (> (length base-name) 15) (substring base-name 0 15) base-name))
           (unique-name (concat "*shell:" short-name "*"))
           (name-idx 0))

      (while (get-buffer unique-name)
        (setq name-idx (+ name-idx 1))
        (setq unique-name (concat "*shell:" short-name ":" (number-to-string name-idx) "*")))

      (funcall oldfun scmd (get-buffer-create unique-name) nil)))

  (advice-add #'async-shell-command :around #'cm/exec-shell)
#+end_src
** Eshell
   :PROPERTIES:
   :ID:       494935b4-92ef-4ed1-899e-bbc3ec474ba2
   :END:
#+begin_src emacs-lisp
  (autoload 'eshell "eshell" "")

  (defun cm/eshell-prompt ()
    (concat user-login-name "@" (system-name) ":"
            ((lambda (p-lst)
               (if (> (length p-lst) 4)
                   (concat
                    (mapconcat (lambda (elm) (if (string< "" elm)
                                                 (substring elm 0 1)
                                               ""))
                               (butlast p-lst (- (length p-lst) 3))
                               "/")
                    "/"
                    (mapconcat (lambda (elm) elm)
                               (last p-lst (- (length p-lst) 3))
                               "/"))
                 (mapconcat (lambda (elm) elm)
                            p-lst
                            "/")))
             (split-string (abbreviate-file-name (eshell/pwd)) "/"))
            " % "))

  (defun eshell-new (name)
    "Create a shell buffer named NAME."
    (interactive "sEshell Name: ")
    (let* ((bn (concat "*eshell:" name "*"))
           (eb (get-buffer bn)))
      (if eb
          (switch-to-buffer eb)
        (eshell)
        (rename-buffer bn))))

  (defun eshell-main ()
    (interactive)
    (eshell-new "main"))
  ; thanks byron, now using rc
  ;(global-set-key (kbd "<f7>") 'eshell-main)

  (defalias 'enew 'eshell-new)

  (put 'eshell 'disabled "Use eshell-new instead!\n")
  (autoload 'ansi-color "ansi-color" t nil)

  ;(defun cm/eshell-handle-ansi-color ()
  ;  (ansi-color-apply-on-region eshell-last-output-start
  ;                              eshell-last-output-end))

  (setq eshell-directory-name "~/.emacs.d/eshell")
  (setq eshell-prompt-function 'cm/eshell-prompt)
  (setq eshell-prompt-regexp "^[^%#$\n]+ [%#$] ")
  (setenv "EDITOR" "emacsclient")
  (setenv "P4USER" "jmickey")
  (setenv "P4PORT" cm/ironport-p4port)
  (setenv "P4CONFIG" "P4ENV")

  ;(defun eshell/mm (&rest args)
  ;  "A better version of my mm alias"
  ;  (interactive)
  ;  (eshell-parse-command "ssh marsarch \"cd $PWD\; " (eshell-flatten-list (append "\"" args))))
  (defun unbind-symbol (symbol)
    "Totally unbind SYMBOL.

  This includes unbinding its function binding, its variable binding and its
  property list."
    (interactive "SSymbol: ")
    (fmakunbound symbol)
    (makunbound symbol)
    (setf (symbol-plist symbol) nil))

  (defun eshell/asc (cmd &rest args)
    "Eshell async shell command, to get rid of double quotes"
    (interactive)

    (let* ((asc-buffer-name (concat "*asc:" cmd "*"))
           (buffer (get-buffer-create (generate-new-buffer-name asc-buffer-name)))
           (directory default-directory))
      ;; If will kill a process, query first.
      (setq proc (get-buffer-process buffer))
      (if proc
          (if (yes-or-no-p "A command is running.  Kill it? ")
              (kill-process proc)
            (error "Shell command in progress")))
      (with-current-buffer buffer
        (setq buffer-read-only nil)
        ;; Setting buffer-read-only to nil doesn't suffice
        ;; if some text has a non-nil read-only property,
        ;; which comint sometimes adds for prompts.
        (let ((inhibit-read-only t))
          (erase-buffer))
        (display-buffer buffer)
        (setq default-directory directory)
        (setq proc (start-file-process-shell-command 
                    asc-buffer-name 
                    buffer cmd 
                    (eshell-flatten-and-stringify args)))
        (setq mode-line-process '(":%s"))
        (require 'shell) (shell-mode)
        (set-process-sentinel proc 'shell-command-sentinel)
        ;; Use the comint filter for proper handling of carriage motion
        ;; (see `comint-inhibit-carriage-motion'),.
        (set-process-filter proc 'comint-output-filter))))


  ;; Stolen from http://www.emacswiki.org/cgi-bin/wiki.pl/EshellEnhancedLS
  (eval-after-load "em-ls"
    '(progn
       (defun ted-eshell-ls-find-file-at-point (point)
         "RET on Eshell's `ls' output to open files."
         (interactive "d")
         (find-file (buffer-substring-no-properties
                     (previous-single-property-change point 'help-echo)
                     (next-single-property-change point 'help-echo))))

       (defun pat-eshell-ls-find-file-at-mouse-click (event)
         "Middle click on Eshell's `ls' output to open files.
   From Patrick Anderson via the wiki."
         (interactive "e")
         (ted-eshell-ls-find-file-at-point (posn-point (event-end event))))
       
       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "RET")      'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<return>") 'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<mouse-2>") 'pat-eshell-ls-find-file-at-mouse-click)
         (defvar ted-eshell-ls-keymap map))

       (defadvice eshell-ls-decorated-name (after ted-electrify-ls activate)
         "Eshell's `ls' now lets you click or RET on file names to open them."
         (add-text-properties 0 (length ad-return-value)
                              (list 'help-echo "RET, mouse-2: visit this file"
                                    'mouse-face 'highlight
                                    'keymap ted-eshell-ls-keymap)
                              ad-return-value)
         ad-return-value)))

  (add-hook 'eshell-preoutput-filter-functions 'ansi-color-apply)

#+end_src
** list-timers should be enabled
:PROPERTIES:
:ID:       ab03a859-149d-45df-afd5-9d74374e3b1e
:END:
#+begin_src emacs-lisp
  (put 'list-timers 'disabled nil)
#+end_src
** BBDB - Big Brother DataBase
   :PROPERTIES:
   :ID:       47557249-431f-4cca-a9a8-4c78f7d8741f
   :END:
Well integrated into Gnus, eventually just had to start using it!
Borrowed this pretty heavily from somewhere, will document once I know
what all these features really mean.
#+begin_src emacs-lisp
  ;;(require 'bbdb)
  ;; uber failure
  ;;(require 'message)
  ;;(bbdb-initialize 'mail 'message)
  
  (setq 
   bbdb-offer-save 1                        ;; 1 means save-without-asking
   bbdb-use-pop-up t                        ;; allow popups for addresses
   bbdb-electric-p t                        ;; be disposable with SPC
   bbdb-popup-target-lines  1               ;; very small
   bbdb-dwim-net-address-allow-redundancy t ;; always use full name
   bbdb-quiet-about-name-mismatches 2       ;; show name-mismatches 2 secs
   bbdb-always-add-address t                ;; add new addresses to existing...
   ;; ...contacts automatically
   bbdb-canonicalize-redundant-nets-p t     ;; x@foo.bar.cx => x@bar.cx
   bbdb-completion-type nil                 ;; complete on anything
   bbdb-complete-name-allow-cycling t       ;; cycle through matches
   ;; this only works partially
   bbbd-message-caching-enabled t           ;; be fast
   bbdb-use-alternate-names t               ;; use AKA
   bbdb-elided-display t                    ;; single-line addresses
   ;; auto-create addresses from mail
   bbdb/mail-auto-create-p 'bbdb-ignore-some-messages-hook   
   bbdb-ignore-some-messages-alist ;; don't ask about fake addresses
   ;; NOTE: there can be only one entry per header (such as To, From)
   ;; http://flex.ee.uec.ac.jp/texi/bbdb/bbdb_11.html
   '(( "From" . "no.?reply\\|DAEMON\\|daemon\\|facebookmail\\|twitter")))
#+end_src
** MML + org
   :PROPERTIES:
   :ID:       3dda2f51-5402-48ab-9607-b713149fd10d
   :END:
#+begin_src emacs-lisp
  
  (defun cm/org-mime-html-hook ()
    (org-mime-change-element-style
     "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
                   "#E6E1DC" "#232323"))
    (org-mime-change-element-style
     "blockquote" "border-left: 2px solid gray; padding-left: 4px;"))
  
  
  (add-hook 'org-mime-html-hook 'cm/org-mime-html-hook)
  
  (add-hook 'message-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-o" 'org-mime-htmlize)))
  
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-o" 'org-mime-org-buffer-htmlize)))
#+end_src
** Gnus
   :PROPERTIES:
   :ID:       3835aa31-4277-4684-8543-8b98179ff2e6
   :END:
** xdg-open!
   :PROPERTIES:
   :ID:       82df16a5-026b-415d-9aae-c63b16630174
   :END:
#+begin_src emacs-lisp
  (defun cm/advise-browse-url-can-use-xdg-open (fun &rest args)
    (let ((res (apply fun args)))
      (if (not res)
          (and (getenv "DISPLAY")
               (executable-find "xdg-open")
               (executable-find "nohup"))
        res)))

  (advice-add #'browse-url-can-use-xdg-open :around #'cm/advise-browse-url-can-use-xdg-open)
#+end_src
** browse-url with chrome and separate profiles
:PROPERTIES:
:ID:       07a2e6ba-0330-4768-b9f4-61f707a9c630
:END:
#+begin_src emacs-lisp
  (defvar cm/browse-url-work-profile "Default"
    "The profile in chrome to open things for work")

  (defvar cm/browse-url-personal-profile "Profile 1"
    "The profile in chrome to open things for personal use")

  (pcase (system-name)
    ("jmickey-mbp"
     (setq cm/browse-url-work-profile "Default")
     (setq cm/browse-url-personal-profile "Profile 1"))  
    ("nina"
     (setq cm/browse-url-work-profile "Default")
     (setq cm/browse-url-personal-profile "Default")))

  ;; this doesn't work on mac os x :O
  (defun cm/browse-url-chrome (url profile &optional new-window)
    "Internal function for opening the right chrome."
    (interactive "sURL: \nsProfile: ")
    (cond
     ((eq system-type 'gnu/linux)
      (let ((browse-url-chrome-arguments
	     (append browse-url-chrome-arguments
		     (list (concat "--profile-directory\"" profile "\"") url))))))
	(browse-url-chrome url new-window)))
     ((eq system-type 'darwin)
      (start-process (concat "open " url) nil
		     "open" "-b" "com.google.Chrome"
		     "--args" (concat "--profile-directory=\"" profile "\"")
		     url))))


  (defun cm/browse-url-work (url &optional new-window)
    "Ask whether URL should be browsed in a private browsing window."
    (interactive "sURL: ")
    (cm/browse-url-chrome url cm/browse-url-work-profile new-window))

  (defun cm/browse-url-personal (url &optional new-window)
    "Ask whether URL should be browsed in a private browsing window."
    (interactive "sURL: ")
    (cm/browse-url-chrome url cm/browse-url-personal-profile new-window))

  ;; override this in private .emacs-work.el file
  (setq browse-url-browser-function
	'(("^https?://instagram\\.com" . cm/browse-url-personal)
	  ("." . cm/browse-url-personal)))

#+end_src
** Uniquify
   :PROPERTIES:
   :ID:       42385a4e-6d56-4be3-b351-c6a4dacdef32
   :END:
So useful, I think everyone should have this turned on.
#+begin_src emacs-lisp
  (require 'uniquify)
  
  (setq uniquify-buffer-name-style 'post-forward)
  (setq uniquify-after-kill-buffer-p t)
  
  ;; unrelated, but a nice spot for it
  (defun uniquify-all-lines-region (start end)
    "Find duplicate lines in region START to END keeping first occurrence."
    (interactive "*r")
    (save-excursion
      (let ((end (copy-marker end)))
        (while
            (progn
              (goto-char start)
              (re-search-forward "^\\(.*\\)\n\\(\\(.*\n\\)*\\)\\1\n" end t))
          (replace-match "\\1\n\\2")))))
  
  (defun uniquify-all-lines-buffer ()
    "Delete duplicate lines in buffer and keep first occurrence."
    (interactive "*")
    (uniquify-all-lines-region (point-min) (point-max)))
#+end_src
** Unhighlight all by default
:PROPERTIES:
:ID:       197644fe-61db-4f26-a97b-1aa5e5e4dc41
:END:
The keybinding =M-s h u= by default only unhighlights one entry, and
then =C-u M-s h u= unhighlights everything. I'm going to swap these
two keybindings with the following:

#+begin_src emacs-lisp
  (require 'hi-lock)

  (defun cm/unhighlight-regexp-swap (arg)
    (interactive "P")
    (pcase arg
      ('(4)
       (message "found 4, running nil")
       (command-execute #'unhighlight-regexp))
      ('nil
       (message "found nil, running t")
       (unhighlight-regexp t))
      (_
       (message "found other(%s), running arg" arg)
       (unhighlight-regexp arg))))

  (substitute-key-definition 'unhighlight-regexp 'cm/unhighlight-regexp-swap hi-lock-map)
  (substitute-key-definition 'unhighlight-regexp 'cm/unhighlight-regexp-swap search-map)
#+end_src
** Diff Before Save
:PROPERTIES:
:ID:       be447133-7999-437c-a6d9-fa9bbf5142c1
:END:
I find myself often forgetting what I've changed in a file and what I
haven't. Obviously I use git, but I save files multiple times before
committing, and can get a little lost. The challenges around
auto-committing are pretty intense as well, as many intermediate
states are basically completely irrelevant. I need more diligence in
these areas.

Anyways, this just makes sure that I can easily diff the file I'm
currently looking at with the file on disk. It'll help me get back to
sanity in many cases.

- TODO default to current buffer, no =RET= required
- TODO if not a file-based buffer, *then* ask for buffer nome

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c d") #'diff-buffer-with-file)
#+end_src
** Buffer Outlines (via counsel + semantic/imenu)
:PROPERTIES:
:ID:       1480307b-7780-48e3-a8bd-d396cfe6b3d8
:END:
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c i") #'counsel-semantic-or-imenu)
#+end_src
* External
  :PROPERTIES:
  :ID:       d6a73715-3861-4816-9c49-0b3a2e493fa2
  :END:
** Emacs Features
   :PROPERTIES:
   :ID:       2fbe45d4-05c6-4eec-98c4-4569aaacf9f5
   :END:
*** Ivy
:PROPERTIES:
:ID:       db3458cd-db2e-4743-b5e9-47fc4749ae84
:END:
The competitor to Helm. Supposedly simpler.. but I see it more like a
Microsoft vs Linux situation. Luckily both are better than the Lisp vs
C situation (they both chose lisp like adults).

#+begin_src emacs-lisp
  (use-package ivy
    :diminish ivy-mode
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (define-key ivy-minibuffer-map (kbd "S-SPC") nil)
    (setq ivy-count-format ""))
#+end_src
*** Hydra
:PROPERTIES:
:ID:       1eb9bcfd-c759-4b19-b39a-0038c3db2ba0
:END:
Useful for hydras.
#+begin_src emacs-lisp
  (use-package hydra)
#+end_src
*** Undo Tree
:PROPERTIES:
:ID:       6f280c2e-1b7f-4f59-95a3-6b89bdf1899d
:END:
Undo tree is excellent! =C-x u= to browse. Now the larger question is
how it works with browse-kill-ring? I like both modes I guess.
#+begin_src emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :init
    (global-undo-tree-mode))
#+end_src
*** Speedbar
:PROPERTIES:
:ID:       89800dd6-6472-4bc7-8784-17a7178e6daf
:END:
I use sr-speedbar so it's part of the same emacs frame.
#+begin_src emacs-lisp
  (use-package sr-speedbar
    :commands (sr-speedbar-open sr-speedbar-toggle)
    :bind (("<f5>" . sr-speedbar-toggle)))
#+end_src
*** Minimap
    :PROPERTIES:
    :ID:       f41de103-ff8a-4327-9974-9648cec029fe
    :END:
Got jealous, had to have it in emacs. Not so useful after all...
#+begin_src emacs-lisp
  (use-package minimap
    :commands minimap-create)
#+end_src
*** Word count
    :PROPERTIES:
    :ID:       bf701e19-c3b1-4df8-8ea2-3bc377fc9d98
    :END:
NaNoWriMo!
#+begin_src emacs-lisp
  (autoload 'word-count-mode "word-count"
            "Minor mode to count words." t nil)
  (global-set-key "\M-+" 'word-count-mode)
#+end_src
*** IBuffer
    :PROPERTIES:
    :ID:       0ebd6cb6-2216-4b38-9e05-569d1fa85fde
    :END:
Incredibly useful way to browse your buffers.
#+begin_src emacs-lisp
  (require 'ibuffer)

  ;; replace emac's default buffer list with the excellent ibuffer
  (global-set-key (kbd "C-x C-b") 'ibuffer)

  (define-ibuffer-sorter filename-or-dired
    "Sort the buffers by their pathname."
    (:description "filenames plus dired")
    (string-lessp 
     (with-current-buffer (car a)
       (or buffer-file-name
	   (if (eq major-mode 'dired-mode)
	       (expand-file-name dired-directory))
	   ;; so that all non pathnames are at the end
	   "~"))
     (with-current-buffer (car b)
       (or buffer-file-name
	   (if (eq major-mode 'dired-mode)
	       (expand-file-name dired-directory))
	   ;; so that all non pathnames are at the end
	   "~"))))

  ;; Add pathnam sorting, useful after 's m'
  (define-key ibuffer-mode-map (kbd "s p") 'ibuffer-do-sort-by-filename-or-dired)

  ;; we both know this isn't true, but go with it.
  (setq ibuffer-expert t)

  (setq ibuffer-saved-filter-groups
	'(("default"
	   ("Work"
	    (or
	     (filename . "/google/")
	     (filename . "/work/")))
	   ("GTD"
	    (or (filename . "/org/")
		(mode . org-agenda-mode)))
	   ("Mail"
	    (or (mode . mu4e-compose-mode)
		(mode . mu4e-main-mode)
		(mode . mu4e-headers-mode)
		(mode . mu4e-org-mode)
		(mode . mu4e-view-mode)
		(mode . notmuch-search-mode)
		(mode . notmuch-show-mode)
		(mode . message-mode)
		(mode . notmuch-message-mode)
		(name . "bbdb")))
	   ("Emacs"
	    (or (name . "*Messages*")
		(name . "*scratch*")
		(name . "*GNU Emacs*")
		(name . "*Occur*")
		(name . "*Backtrace*")
		(name . "*Help*")
		(name . "tramp/ssh")
		(name . "tramp/sudo")
		(name . "*Calculator*")
		(name . "*Calc Trail*")
		(name . "*Diff*"))))))

  (setq ibuffer-formats
	'((mark modified read-only " "
		(name 50 50 :left :elide)
		" "
		(size 9 -1 :right)
		" "
		(mode 16 16 :left :elide)
		" " filename-and-process)
	  (mark " "
		(name 30 -1)
		" " filename)))

  (add-hook 'ibuffer-mode-hook
	    (lambda ()
	      (ibuffer-switch-to-saved-filter-groups "default")))

#+end_src
*** Browse Kill Ring
    :PROPERTIES:
    :ID:       6287094b-d31c-42d9-b125-870943a9e90d
    :END:
Navigate visually through the entire kill ring.
#+begin_src emacs-lisp
  (defun cm/kill-ring-insert ()
    (interactive)
    (let ((result (completing-read
		   "Yank: "
		   (cl-delete-duplicates kill-ring :test #'equal))))
      (when (and result (region-active-p))
	;; the currently highlighted section is to be replaced by the yank
	(delete-region (region-beginning) (region-end)))
      (insert result)))

  (global-set-key (kbd "M-y") 'cm/kill-ring-insert)


#+end_src

*** Expand region
    :PROPERTIES:
    :ID:       4cc35189-c58c-42ef-8e80-aae7f2ac00e6
    :END:
If you have a region selected, typing =C-== will expand the selection
out semantically.
#+begin_src emacs-lisp
  (autoload 'expand-region "expand-region" "")
  (global-set-key (kbd "C-=") 'er/expand-region)
#+end_src

*** Clipetty
:PROPERTIES:
:ID:       52679c8e-bd09-46b9-ba35-4a48c5137911
:END:
Let's =emacs -nw= interact with the system clipboard across all kinds of things!

#+begin_src emacs-lisp
  (use-package clipetty
    :bind ("C-c c" . clipetty-kill-ring-save))
#+end_src

*** Ace Jump
    :PROPERTIES:
    :ID:       c32057a8-724c-479d-8f20-d3c7b7e2ea7e
    :END:
#+begin_src emacs-lisp
  (use-package ace-jump-mode
   :bind ("C-." . ace-jump-mode))
#+end_src
*** Hilight line
    :PROPERTIES:
    :ID:       f7ae60f6-a98c-4bd2-9453-45a5a4f96fa2
    :END:
#+begin_src emacs-lisp
  ;; Default hl
  (global-hl-line-mode t)
  (make-variable-buffer-local 'global-hl-line-mode)

  ;; wombat and others set underlines. they are assholes.
  (defun cm/hl-line-theme-hook ()
    (set-face-underline hl-line-face nil)
    (set-face-foreground 'highlight nil)
    (if (eq cm/theme-style 'light)
	(set-face-background 'highlight "#CFCFCF")
      (set-face-background 'highlight "#303030")))

  (cm/hl-line-theme-hook)

  (add-hook 'cm/theme-after-hook 'cm/hl-line-theme-hook)
#+end_src
*** Projectile
    :PROPERTIES:
    :ID:       b8c6fcd8-02a8-4e74-9a7d-f55ced1f2e2a
    :END:
#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :bind-keymap ("C-c p" . projectile-command-map)
    :init
    (put 'projectile-project-name 'safe-local-variable 'stringp)
    (put 'projectile-project-compilation-cmd 'safe-local-variable 'stringp)
    (put 'projectile-use-git-grep 'safe-local-variable 'booleanp)
    :config
    (projectile-mode 1)
    (setq projectile-completion-system 'ivy)
    ;; seting the remote file exists cache to an hour, I'd rather things
    ;; error out weirdly than slow down all find-files!
    (setq projectile-file-exists-remote-cache-expire (* 60 60))

    ;; use my handy dandy shell hook
    (define-key projectile-command-map (kbd "$") 'cm/shell-projectile)

    ;; I use alien because native is slow. I think I used to use native
    ;; for reasons that escape me now.
    (setq projectile-indexing-method 'alien)
    (setq projectile-enable-caching t)

    ;; this replaces the old `projectile-compile-project' to use the
    ;; project name in the compilation buffer. Let's me run all ze
    ;; compilations!
    (defun cm/projectile-compile-project (arg &optional dir)
      "Run project compilation command, using the project name

  Normally you'll be prompted for a compilation command, unless
  variable `compilation-read-command'.  You can force the prompt
  with a prefix ARG."
      (interactive "P")
      (let* ((project-root (if dir
			       dir
			     (projectile-project-root)))
	     (default-directory project-root)
	     (default-cmd (projectile-compilation-command project-root))
	     (compilation-cmd (if (or compilation-read-command arg)
				  (projectile-read-command "Compile command: "
							   default-cmd)
				default-cmd)))
	(puthash project-root compilation-cmd projectile-compilation-cmd-map)
	(save-some-buffers (not compilation-ask-about-save)
			   (lambda ()
			     (projectile-project-buffer-p (current-buffer)
							  project-root)))
	(with-current-buffer
	    (compilation-start compilation-cmd nil '(lambda (x) (concat "*compilation:" (projectile-project-name) "*")))
	  (setq-local projectile-project-name (projectile-project-name))))))

  ;  (advice-remove 'projectile-compile-project #'cm/projectile-compile-project))
#+end_src
*** Multiple Cursors
:PROPERTIES:
:ID:       9faeb01e-fc08-4df7-8a73-d7d45886fece
:END:
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind (("C->" . mc/mark-next-like-this)
	   ("C-<" . mc/mark-previous-like-this)
	   ("C-c C->" . mc/mark-all-like-this)
	   ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+end_src
*** fill column indicator (fci)
:PROPERTIES:
:ID:       c073fcaa-93fc-452c-a2eb-ffaa33115d6f
:END:
This draws a vertical line at the fill column. Nice for languages
without things like =gofmt=.

#+begin_src emacs-lisp
  (use-package fill-column-indicator
    :commands (fci-mode))
#+end_src

*** Mixed Pitch
:PROPERTIES:
:ID:       7e1289bf-13e6-4b0a-9862-fd0a8df989b8
:END:

This makes things just a tad nicer to read in org-mode. Currently only
enabled there.

#+begin_src emacs-lisp
  (use-package mixed-pitch
    :commands mixed-pitch-mode
    :diminish mixed-pitch-mode
    :hook (org-mode . mixed-pitch-mode)
    :config
    (defun cm/set-face-attribute-mixed (face)
      (set-face-attribute
       face nil
       :family (face-attribute 'variable-pitch :family)
       :height (face-attribute 'variable-pitch :height nil 'default)))

    (defun cm/org-level-face-height (ratio)
      (truncate (* (face-attribute 'variable-pitch :height nil 'default) ratio)))

    (defun cm/org-level-set-face-height (part)
      (set-face-attribute (car part) nil :height (cm/org-level-face-height (cdr part))))

    (defvar cm/org-level-height-alist
      '((org-level-1 . 1)
	(org-level-2 . 1)
	(org-level-3 . 1)
	(org-level-4 . 1)
	(org-level-5 . 1)
	(org-level-6 . 1)
	(org-level-7 . 1)
	(org-level-8 . 1)
	(org-document-title . 1.5))
      "List of org-level faces to ratio of default variable height")

    (mapc #'cm/set-face-attribute-mixed org-level-faces)
    (mapc #'cm/org-level-set-face-height cm/org-level-height-alist)

    (setq mixed-pitch-variable-pitch-cursor nil
	  mixed-pitch-set-height t)

    (add-to-list 'mixed-pitch-fixed-pitch-faces 'org-date)
    (add-to-list 'mixed-pitch-fixed-pitch-faces 'org-done)
    (add-to-list 'mixed-pitch-fixed-pitch-faces 'org-drawer)
    (add-to-list 'mixed-pitch-fixed-pitch-faces 'org-formula)
    (add-to-list 'mixed-pitch-fixed-pitch-faces 'org-tag)
    (add-to-list 'mixed-pitch-fixed-pitch-faces 'org-todo))
#+end_src

** Major Modes
   :PROPERTIES:
   :ID:       04fe1433-561d-453a-a3c7-3ec248df0175
   :END:
   
*** Markdown
    :PROPERTIES:
    :ID:       577a0ae4-15dc-4f23-8010-4a2c884afe73
    :END:
#+begin_src emacs-lisp
  (use-package
   markdown-mode
   :mode "\\.\\(md\\|markdown\\|mdwn\\)$")
#+end_src
*** Evil
    :PROPERTIES:
    :ID:       b85dc1f9-cbe3-40ff-b9a4-17b84e98cb18
    :END:
**** Activate Evil!
     :PROPERTIES:
     :ID:       0323ddc8-4107-4bef-868b-8636fbf95fcb
     :END:
     I have become one of them :/
#+begin_src emacs-lisp
  ;(require 'evil)
  ;
  ;(evil-mode 1)
#+end_src
**** Evil Ace Jump
     :PROPERTIES:
     :ID:       8b7dc631-4a6c-497f-ae58-6879fac697b2
     :END:
Let's me use ace jump e'erywhere
#+begin_src emacs-lisp
  ;(define-key evil-motion-state-map (kbd "SPC") #'evil-ace-jump-word-mode)
  ;(define-key evil-motion-state-map (kbd "C-SPC") #'evil-ace-jump-char-mode)
  ; 
  ;(define-key evil-operator-state-map (kbd "SPC") #'evil-ace-jump-word-mode) ; similar to f
  ;(define-key evil-operator-state-map (kbd "C-SPC") #'evil-ace-jump-char-mode) ; similar to t
  ;(define-key evil-operator-state-map (kbd "M-SPC") #'evil-ace-jump-char-to-mode)
  ; 
  ;;; different jumps for different visual modes
  ;(defadvice evil-visual-line (before spc-for-line-jump activate)
  ;(define-key evil-motion-state-map (kbd "SPC") #'evil-ace-jump-word-mode))
  ; 
  ;(defadvice evil-visual-char (before spc-for-char-jump activate)
  ;(define-key evil-motion-state-map (kbd "SPC") #'evil-ace-jump-word-mode))
  ; 
  ;(defadvice evil-visual-block (before spc-for-char-jump activate)
  ;(define-key evil-motion-state-map (kbd "SPC") #'evil-ace-jump-word-mode))

  ;(evil-set-initial-state 'shell-mode 'emacs)
  ;(evil-set-initial-state 'org-mode 'emacs)
#+end_src
For some reason that does not include evil-local-mode.
#+begin_src emacs-lisp
  (unless (boundp 'evil-local-mode)
    (autoload 'evil-local-mode "evil" "Toggle evil in single buffer" t))
#+end_src
*** Valgrind
    :PROPERTIES:
    :ID:       1a583879-2d47-4e92-88d8-b47ecaf28dd1
    :END:
#+begin_src emacs-lisp
  ; Based on compile.el included with Emacs
  ; and ideas from http://tromey.com/blog/?p=342
  ; compile.el is GPL, so this is too.
  
  (require 'compile "compile")
  
  (defgroup valgrind nil
    "Run valgrind as inferior of Emacs, parse error messages."
    :group 'tools
    :group 'processes)
  
  
  (defcustom valgrind-command "valgrind --leak-check=full "
    "*Last shell command used to run valgrind; default for next valgrind run.
  
  Sometimes it is useful for files to supply local values for this variable.
  You might also use mode hooks to specify it in certain modes, like this:
  
      (add-hook 'c-mode-hook
         (lambda ()
           (unless (or (file-exists-p \"makefile\")
                       (file-exists-p \"Makefile\"))
             (set (make-local-variable 'valgrind-command)
                  (concat \"make -k \"
                          (file-name-sans-extension buffer-file-name))))))"
    :type 'string
    :group 'valgrind)
  
  ;; History of compile commands.
  (defvar valgrind-history nil)
  
  
  (defun valgrind (command)
    "Run valgrind.
  Runs COMMAND, a shell command, in a separate process asynchronously
  with output going to the buffer `*valgrind*'.
  
  You can then use the command \\[next-error] to find the next error message
  and move to the source code that caused it."
    (interactive
     (if (or compilation-read-command current-prefix-arg)
         (list (read-from-minibuffer "Valgrind command: "
                                   (eval valgrind-command) nil nil
                                   '(valgrind-history . 1)))
       (list (eval valgrind-command))))
    (unless (equal command (eval valgrind-command))
      (setq valgrind-command command))
    (compilation-start command t))
#+end_src
*** PlantUML
    :PROPERTIES:
    :ID:       5c8d9180-9215-438c-8d91-c4348e01c7f4
    :END:
Get the jarfile in the correct place...
#+begin_src emacs-lisp
  (defvar cm/plantuml-paths
    (list
     (concat (getenv "HOME") "/bin/plantuml.jar")
     "/usr/share/plantuml/plantuml.jar")
    "PlantUML paths.")

  (defvar plantuml-jar-path
    (cl-reduce
     (lambda (x y) (if (and x (file-exists-p x)) x y))
     cm/plantuml-paths)
    "Default plantuml-jar-path.")

  (setenv "GRAPHVIZ_DOT" "/usr/bin/dot")
#+end_src
*** Paredit
:PROPERTIES:
:ID:       f2621984-6644-4efc-8154-0c2ab06b5bb8
:END:

[[http://emacswiki.org/emacs/ParEdit][Paredit]] is an amazing minor mode for editing lisp, but it is a bit
complex. I turn it on for scheme and cl, but not elisp as usually when
I'm hacking on elisp I want the lowest barrier to entry.

#+begin_src emacs-lisp
  (use-package paredit
    :init
    (add-hook 'scheme-mode-hook
	      '(lambda ()
		 (paredit-mode 1)))
    (add-hook 'lisp-mode-hook '(lambda () (paredit-mode 1))))
#+end_src
*** Markdown
    :PROPERTIES:
    :ID:       8e52bfd7-4fd2-4076-8a03-faddfa0941b3
    :END:
#+begin_src emacs-lisp
  (autoload 'markdown-mode "markdown-mode.el"
    "Major mode for editing Markdown files" t)
  (add-hook 'markdown-mode-hook '(lambda ()
                                   (flyspell-mode 1)
                                   (auto-fill-mode 1)))
  
  ;; autoload
  (add-to-list 'auto-mode-alist '("\\.mdwn$" . markdown-mode))
#+end_src
*** Haskell
    :PROPERTIES:
    :ID:       c7b6733c-7939-4988-a533-1be0b7d68c06
    :END:
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
  (setq haskell-hoogle-program "hoogle")
#+end_src
*** Go
    :PROPERTIES:
    :ID:       b10a04b5-9b60-4a6f-97d8-ad7ad6394dbb
    :END:
**** Fuck GOPATH and everything in it
     :PROPERTIES:
     :ID:       c441d182-f0d9-4f8b-a938-1c6ebf45e20a
     :END:
So emacs doesn't handle project specific *environment
variables*. Which sucks horribly, and I don't blame any of the project
tools for not addressing it, as there are no great answers.

The fact that the golang project has made it a prerequisite that so
many are set, and that there are rarely cli overrides for them is
really a fault of their own.
#+begin_src emacs-lisp
  (use-package go-mode
    :mode "\\.go$"
    :config
    (add-hook 'go-mode-hook 'cm/go-mode-hook))

  (defun cm/go-mode-hook ()
    (interactive)
    (require 'go-oracle)
    (setq go-oracle-command (concat (getenv "HOME") "/bin/oracle"))
    (go-oracle-mode)
    (subword-mode 1)
    (diminish 'subword-mode)
    (setq fill-column 80)
    (fci-mode)
    (diminish 'go-oracle-mode)
    (setq imenu-generic-expression
          '(("type" "^type *\\([^ \t\n\r\f]*\\)" 1)
            ("func" "^func *\\(.*\\) {" 1)))
    (imenu-add-to-menubar "Index")
    (font-lock-mode 1)
    (add-hook 'before-save-hook #'gofmt-before-save))
#+end_src

*** Ruby
    :PROPERTIES:
    :ID:       0d05cf49-73f2-40f2-b607-45795c1a9650
    :END:
Lisp has kind of taken over from Ruby. Whether that's Scheme or Common
Lisp seems to be the current mental debate.
#+begin_src emacs-lisp
  (autoload 'ruby-mode "ruby-mode"
    "Mode for editing ruby source files")

  (add-hook 'ruby-mode-hook 'turn-on-font-lock)
  
  (add-to-list 'interpreter-mode-alist '("ruby" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
#+end_src
*** C
    :PROPERTIES:
    :ID:       4d420720-231b-491a-848f-d384b6cdc2cd
    :END:
My C settings.
#+begin_src emacs-lisp
  (require 'compile)

  (defun cm/make-c++-header ()
    (interactive)
    (c++-mode)
    (add-file-local-variable-prop-line 'mode 'c++))

  (c-add-style "mars" '("linux"))

  (defconst iridium-c++-style
    '((c-basic-offset . 4)
      (c-comment-only-line-offset . 4)
      (c-hanging-braces-alist . ((substatement-open before)
				 (brace-list-open before)))
      (c-hanging-colons-alist . ((member-init-intro after)
				 (inher-intro after)
				 (case-label after)
				 (label after)
				 (access-label after)))
      (c-offsets-alist        . ((defun-open . 0)
				 (defun-block-intro . 4)
				 (label . 0)
				 (inclass . +)
				 (case-label . +)
				 (access-label . 0)
				 (brace-list-intro . 4)
				 (substatement-open . 0)
				 (member-init-intro . 8)
				 (statement-case-open . 0)
				 (statement-block-intro . 4)
				 (class-open . 0)
				 (inline-open . 0)
				 (innamespace . 4)
				 (namespace-open . 0)
				 (comment-intro . 0)
				 (c . 1)
				 (inher-intro 8)
				 (class-close . 0)
				 (namespace-close . 0)
				 (func-decl-cont . 8))))
      "Iridium style")

    (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))


  (defun cm/iridium-c-hook ()
    (interactive)
    (c-add-style "iridium-c++" iridium-c++-style t)
    (setq indent-tabs-mode nil)
    (setq comment-multi-line t)
    (local-set-key (kbd "C-c o") 'ff-find-other-file)
    ;(helm-gtags-mode)
    (setq fill-column 90))

  (defun cm/goog-c-hook ()
    (setq indent-tabs-mode nil)
    (setq comment-multi-line t)
    (setq fill-column 80)
    (local-set-key (kbd "C-c o") 'ff-find-other-file))

  (defun cm/work-c-hook ()
    (cm/goog-c-hook))

  (add-hook 'c++-mode-hook 'cm/work-c-hook)
  (add-hook 'cc-mode-hook 'cm/work-c-hook)
  (add-hook 'c-mode-hook 'cm/work-c-hook)

  (defun mars-c-hook ()
    (interactive)
    (c-set-style "mars")
    (require 'auto-complete)
    (setq tab-width 8)
    (setq indent-tabs-mode t)
    (setq tab-stop-list
	  '(8 16 24 32 40 48 56 64 72 80 88 96 104 112 120))
    (setq fill-column 80)
    (setq-default c-basic-offset 8)
    (setq show-trailing-whitespace t)
    (setq c-tab-always-indent t)
    (linum-mode 1)
    (setq comment-multi-line t)
    (local-set-key (kbd "C-c o") 'ff-find-other-file)
    ;; (gtags-mode 1) ; no more! going to helm!
    ;; (helm-gtags-mode)
    (set (make-local-variable 'compilation-directory-matcher)
	 '("\\(?:\\(?:Entering\\|Leavin\\(g\\)\\) directory
    `\\(.+\\)'$\\)\\|\\(?:[^]^[]*\\][[:space:]]*\\(\\(?:[[:alnum:]]*/\\)+\\)\\)\\|\\(?:^\\(\\[\\)\\)"
	   (2 . 1) (3 . 9) (4 . 4)))
    (set (make-local-variable 'compile-command) "~/bin/emacs-mars-compile")
    (add-to-list 'ac-sources '(ac-source-gtags
			       ac-source-semantic
			       ac-source-words-in-buffer))
    (auto-complete-mode -1))

#+end_src
*** GNU Plot
    :PROPERTIES:
    :ID:       c8bff85d-6ad0-4580-a461-49eb7910b574
    :END:
Get some fancy graphs going. I mostly use R, but this is nice when /other/ people use gnuplot.
#+begin_src emacs-lisp
  (autoload 'gnuplot-mode "gnuplot" "gnuplot major mode" t)
  (autoload 'gnuplot-make-buffer "gnuplot" "open a buffer in gnuplot mode" t)
  (add-to-list 'auto-mode-alist '("\\.gp$" . gnuplot-mode))
#+end_src
*** Magit
    :PROPERTIES:
    :ID:       84c9b972-5967-4c5e-b096-b00511a56dc2
    :END:
Because I switched to Magit! Works well, and is fairly canonical at
this point. I don't understand vc-mode that well yet, so I really just
use magit-status and magit-log.

magit-log is missing the commiter annotation, I need to fix that.
#+begin_src emacs-lisp
  (use-package magit
    :init
    ;; super incredibly slow thing that would be good in theory but
    ;; implementation is not there.
    (setq magit-revert-buffers nil)
    (setq magit-push-always-verify nil))
#+end_src
**** Custom Commit Message Formatting
     :PROPERTIES:
     :ID:       ea200f52-b363-4450-82c9-4f970a4c4254
     :END:
Sort files by spelling. I figure the internal ordering of each
paragraph should be fine. I'm still working on a cm/gnu-fill-paragraph
that works on these commit message regions.

This regex finds the first line that begins with an asterix.
#+begin_src emacs-lisp
  (defvar cm/gnu-line-start "^\* .*$")
#+end_src
=sort-subr= expects two functions to help it find the boundaries of
records. =nextrec= finds the beginning of the next record, unless
there are no more records and then it should be pointing at the end of
the buffer (=eobp=).
#+begin_src emacs-lisp
  (defun cm/gnu-line-next ()
    (if (not (eobp))
        (forward-line 1))
    (while (and (not (eobp)) (not (looking-at cm/gnu-line-start)))
      (forward-line 1))
    (end-of-line)
    (if (not (eobp))
        (beginning-of-line)))
#+end_src
=endrec= finds the end of the *current* record. In the commit message
case this means finding the next line that starts with an asterix,
then going back to the previous line's end. This handles commit
messages that have multiple functions/lines describing a file's
changes.
#+begin_src emacs-lisp
  (defun cm/gnu-line-end ()
    (if (not (eobp))
        (forward-line 1))
    (while (and (not (eobp)) (not (looking-at cm/gnu-line-start)))
      (forward-line 1))
    (if (not (eobp)) (forward-line -1))
    (end-of-line))
#+end_src
Finally, we get to the part where we actually call sort-subr. Pretty
standard implementation, and mostly lifted from =sort-paragraphs= in
=sort.el.gz=.
#+begin_src emacs-lisp    
  (defun cm/sort-gnu-lines (reverse beg end)
    (interactive "P\nr")
    (save-excursion
      (save-restriction
        (narrow-to-region beg end)
        (goto-char (point-min))
        (sort-subr reverse 'cm/gnu-line-next 'cm/gnu-line-end))))
#+end_src
***** TODO Fix up the idea of "creating" gnu lines
      :PROPERTIES:
      :ID:       b803e11d-489a-40e5-a495-faee9a5cf4a0
      :END:
#+begin_src emacs-lisp
  ; this works well with my git-commit after save hook and rebasing
  ;(defun cm/create-gnu-lines (reverse beg end)
  ;  (interactive "P\nr")
  ;  (save-excursion
  ;    (save-restriction
  ;      (narrow-to-region beg end)
  ;      (goto-char (point-min))
  ;      (
  (fset 'cm/create-gnu-lines
     "* \C-a\C-n\C-k\C-k\C-k\C-k")
#+end_src
I don't have a good keybinding for this yet, but I will figure
something out :P
*** Esperanto
    :PROPERTIES:
    :ID:       5ff50b28-b29e-41f1-858c-3481b8a7c07d
    :END:
This is heavily borrowed from the spanish mode, works wonders.
#+begin_src emacs-lisp
  (load-library "esperanto")
#+end_src
*** Mode Compile
    :PROPERTIES:
    :ID:       7008c9ba-111a-46fb-afb7-d8b2750a6616
    :END:
Friendlier compilation support, tries to guess what the compilation
command should be. I haven't found this to be incredibly helpful
unless you are using the default build systems (make, pdflatex, etc).

Update 2020-03-14 I rarely call compile without doing something else,
using a "work" hydra I set up.
#+begin_src emacs-lisp
;  (global-set-key "\C-cc" 'compile)
#+end_src

*** YAML
    :PROPERTIES:
    :ID:       b37acdb0-1ecd-43e5-a92a-5380a5553263
    :END:
More ruby days.
#+begin_src emacs-lisp
  (autoload 'yaml-mode "yaml-mode" "Yaml editing mode" t)
  
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.yaml$" . yaml-mode))
#+end_src

*** HAML
    :PROPERTIES:
    :ID:       25c5fc08-8ed9-4c8e-9c9a-374e3e705d5a
    :END:
No seriously, I wrote lots of Ruby.
#+begin_src emacs-lisp
  (autoload 'haml-mode "haml-mode" "" t)
  (add-hook 'haml-mode-hook '(lambda ()
                               (setq indent-tabs-mode nil)))
  
  (add-to-list 'auto-mode-alist '("\\.haml$" . haml-mode))
  (add-to-list 'auto-mode-alist '("\\.sass$" . sass-mode))
#+end_src
*** Tramp
    :PROPERTIES:
    :ID:       e8416c36-fe80-4ec2-831b-69134111cc35
    :END:
#+begin_src emacs-lisp
  (require 'tramp-loaddefs)
  (require 'tramp)
  (eval-after-load 'tramp
    (progn
      (setq tramp-histfile-override nil)
      (setq tramp-use-ssh-controlmaster-options nil) ;; use ssh config
      (setq tramp-verbose 6)))
#+end_src
*** GNU Global
    :PROPERTIES:
    :ID:       17fec222-08cc-4942-bd94-f9d4fb788c25
    :END:
Thank you Britt.
#+begin_src emacs-lisp
;  (require 'gtags-autoloads)
  
  (defun my-gtags-settings ()
    "Settings for gtags."
  
    ;; Key bindings.
    (define-prefix-command 'gtags-keymap)
    (define-key global-map (kbd "C-c g") 'gtags-keymap)
  
    (define-key gtags-mode-map (kbd "C->") 'gtags-find-tag-from-here)
    (define-key gtags-mode-map (kbd "C-<") 'gtags-pop-stack)
    (define-key gtags-mode-map (kbd "C-c g s") 'gtags-find-symbol)
    (define-key gtags-mode-map (kbd "C-c g t") 'gtags-find-tag)
    (define-key gtags-mode-map (kbd "C-c g r") 'gtags-find-rtag)
    (define-key gtags-mode-map (kbd "C-c g p") 'my-gtags-find-file)
    (define-key gtags-mode-map (kbd "C-c g v") 'gtags-visit-rootdir)
    (define-key gtags-mode-map [mouse-2] 'gtags-find-tag-by-event)
    (define-key gtags-mode-map [mouse-3] 'gtags-pop-stack)
  
    (define-key gtags-select-mode-map (kbd "n") 'next-line)
    (define-key gtags-select-mode-map (kbd "p") 'previous-line)
    (define-key gtags-select-mode-map (kbd "RET") 'gtags-select-tag)
    (define-key gtags-select-mode-map (kbd "C-<") 'gtags-pop-stack)
    (define-key gtags-select-mode-map (kbd "C->") 'gtags-select-tag)
    (define-key gtags-select-mode-map (kbd "q") 'gtags-pop-stack)
    (define-key gtags-select-mode-map [mouse-2] 'gtags-select-tag-by-event)
    (define-key gtags-select-mode-map [mouse-3] 'gtags-pop-stack)
  
    ;; Highlight gtags item line.
    (add-hook 'gtags-select-mode-hook '(lambda () (hl-line-mode 1)))
  
    ;; Update gtags data after save file.
    (defun gtags-update ()
      "Update gtags data."
      (interactive)
      (start-process "gtags-update" nil "global" "-u"))
    ; (add-hook 'after-save-hook 'gtags-update) ;ahh, no
  
    ;; visit current file under cursor.
    (defun my-gtags-find-file ()
      "Gtags find file, and jump to last exit position."
      (interactive)
      (gtags-find-file)
      (pop-global-mark))
  
    ;; find current header file under cursor.
    (defun my-gtags-find-this-file ()
      "Gtags find current header file under cursor."
      (interactive)
      (let (tagname)
        (setq tagname (concat (current-word) ".h"))
        (gtags-push-context)
        (gtags-goto-tag tagname "Po"))
      (pop-global-mark))
    (define-key gtags-mode-map [M-mouse-2] 'my-gtags-find-this-file)
  )
  
 ; (eval-after-load "gtags"
  ;  '(my-gtags-settings))
#+end_src
*** Android
    :PROPERTIES:
    :ID:       acc7d0e7-3f18-40f2-9b60-28389ee05743
    :END:
#+begin_src emacs-lisp
  (autoload 'android-mode "android-mode.el" "Android minor mode" t)
  (autoload 'android "/opt/android-sdk/tools/lib/android.el" "Google provided android emacs" t)
#+end_src
*** Python
    :PROPERTIES:
    :ID:       19ef428e-9397-4ebe-9f0a-d2c75bdb4c13
    :END:
#+begin_src emacs-lisp
  (add-hook 'python-mode-hook
            '(lambda ()
               (setq show-trailing-whitespace t)))
#+end_src
*** Racket
:PROPERTIES:
:ID:       95d466d7-8e49-4cb6-b1cf-d934f73fc21e
:END:
#+begin_src emacs-lisp
  (use-package racket-mode
    :mode "\\.rkt$")
#+end_src

*** simple httpd
    :PROPERTIES:
    :ID:       4f1c60ce-0986-45bd-b5dc-4dc596675e68
    :END:
This is a mode that provides a full http server in elisp. It does
default to serving =~/public_html=, so I turn that off here.

#+begin_src emacs-lisp
  (use-package
   simple-httpd
   :commands (httpd-start httpd-serve-directory)
   :config
   (setq httpd-root "")
   (setq httpd-serve-files nil))
#+end_src
*** PDF Tools
:PROPERTIES:
:ID:       e8c52e29-ce3e-4703-a23f-59819fc41abc
:END:
This adds much better support for pdfs in emacs.
#+begin_src emacs-lisp
  ;; (when (eq system-type 'gnu/linux)
  ;;   (use-package pdf-tools
  ;;   :pin manual
  ;;   :config
  ;;   (pdf-tools-install)))
#+end_src
** Programs
   :PROPERTIES:
   :ID:       cb65de78-396a-4243-8bd8-4132d982e360
   :END:
*** Chronos
:PROPERTIES:
:ID:       0e18b5f0-0e1b-4299-9364-9616e274280b
:END:
A set of timers
#+begin_src emacs-lisp
  (use-package chronos
    :bind ("C-c t" . chronos-add-timer)
    :config
    (add-hook 'chronos-expiry-functions 'chronos-desktop-notifications-notify)
    (add-hook 'chronos-expiry-functions 'chronos-message-notify))
#+end_src
*** Elfeed
:PROPERTIES:
:ID:       0efb46e1-0eed-401a-b817-ca6804305790
:END:
[[https://github.com/skeeto/elfeed][elfeed]] is a great RSS reader in the style of notmuch. Super useful.
#+begin_src emacs-lisp
  ;; (use-package elfeed-org
  ;;   :config
  ;;   (elfeed-org)
  ;;   (setq rmh-elfeed-org-files (list (cm/org-dir "_notes/rss.org")))

  ;; (defun cm/elfeed-update ()
  ;;   (interactive)
  ;;   (elfeed-update)
  ;;   (elfeed-search-update--force))

  ;; (use-package elfeed
  ;;   :commands elfeed
  ;;   :bind (("C-c e" . elfeed)
  ;; 	 :map elfeed-search-mode-map
  ;; 	 ("G" . cm/elfeed-update)))
#+end_src
*** EMMS - Emacs MultiMedia System
    :PROPERTIES:
    :ID:       0e42f65c-aca2-4cbb-9633-1d8cedaefaa8
    :END:
Now w/mopidy
#+begin_src emacs-lisp
  (require 'emms-setup)
  (emms-all)
  (require 'emms-browser)
  (require 'emms-player-mpd)
  (add-to-list 'emms-info-functions 'emms-info-mpd)
  (add-to-list 'emms-player-list 'emms-player-mpd)

  (require 'emms-volume)
  (setq emms-volume-change-function 'emms-volume-mpd-change)

  (setq emms-info-asynchronosly t)
  (add-hook 'emms-player-started-hook 'emms-show)
  (setq emms-show-format "NP: %s")
  (setq emms-mode-line-icon-before-format ""
        emms-mode-line-format " %s"
        emms-mode-line-icon-color "blue")

  (if (executable-find "find")
      (setq emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find))

  ;; reserve a key namespace for emms
  (global-set-key (kbd "C-c m p") 'emms-pause)
  (global-set-key (kbd "C-c m m") 'emms-smart-browse)
#+end_src
*** ERC
    :PROPERTIES:
    :ID:       5ba53dbe-b88d-44e9-8121-462325ca2422
    :END:
What I generally end up using for irc, but weechat always tends to win
me over.
#+begin_src emacs-lisp
  (require 'erc)
#+end_src

#+begin_src emacs-lisp
  (setq erc-user-full-name "codemac")
  (setq erc-email-userid "j@codemac.net")
  (setq erc-nick "codemac")
  (setq erc-prompt-for-password nil)
  ;; ERC Time stamps
  (setq erc-timestamp-only-if-changed-flag t)
  (setq erc-timestamp-format "[%H:%M:%S] ")
  (setq erc-insert-timestamp-function 'erc-insert-timestamp-left)

  ;; Auto-fill (static size so log files look decent)
  (setq erc-fill-column 80)
  (setq erc-fill-function 'erc-fill-static)
  (setq erc-fill-static-center 15)
  (setq erc-join-buffer 'bury)

  (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT"))

  ;; Auto join the given channels
  (erc-autojoin-mode t)
  (setq erc-autojoin-channels-alist cm/erc-autojoin-channels-alist)

  (setq erc-server-auto-reconnect t)
  (setq erc-server-reconnect-attempts 5)
  (setq erc-server-reconnect-timeout 5)
  ;; Some other settings
  (setq erc-max-buffer-size 20000)
  (setq erc-track-showcount t)
  (setq erc-auto-query 'bury)             ; Private messages go to a hidden buffer
  (setq erc-autojoin-timing 'ident) ; wait for the delay (or ident resolution)
  (setq erc-autojoin-delay 15)

    ;; Setup ERC buffers
  (defun cm/erc-hook ()
    "Correctly configure ERC buffers"
    (auto-fill-mode 0)
    (setq truncate-lines nil)

    (add-to-list 'erc-modules 'scrolltobottom)
    (add-to-list 'erc-modules 'truncate)
    (add-to-list 'erc-modules 'hl-nicks)
    (add-to-list 'erc-modules 'image)
    (erc-update-modules))

  (defun cm/erc-begin-bitlbee ()
    (interactive)
    (erc :server "localhost" :port 6667))

  (defun cm/erc-begin-freenode ()
    (interactive)
    (erc-ssl :server "chat.freenode.net" :port 6697
             :nick "codemac" :password cm/freenode-password))

  (add-hook 'erc-mode-hook 'cm/erc-hook)
  (add-hook 'erc-join-hook 'bitlbee-netrc-identify)

  ;; set up keys for erc

#+end_src
**** Bitlbee Support
     :PROPERTIES:
     :ID:       65b67613-38e8-418f-9abc-9a93e86e441e
     :END:
#+begin_src emacs-lisp
  (defun bitlbee-netrc-identify ()
    "Auto-identify for Bitlbee channels using authinfo or netrc.
    
     The entries that we look for in netrc or authinfo files have
     their 'port' set to 'bitlbee', their 'login' or 'user' set to
     the current nickname and 'server' set to the current IRC
     server's name.  A sample value that works for authenticating
     as user 'keramida' on server 'localhost' is:
    
     machine localhost port bitlbee login keramida password supersecret"
    (interactive)
    (when (string= (buffer-name) "&bitlbee")
      (let* ((secret (plist-get (nth 0 (auth-source-search :max 1
                                                           :host erc-server
                                                           :user (erc-current-nick)
                                                           :port "bitlbee"))
                                :secret))
             (password (if (functionp secret)
                           (funcall secret)
                         secret)))
        (erc-message "PRIVMSG" (concat (erc-default-target) " " "identify" " " password) nil))))

  ;; Enable the netrc authentication function for &biblbee channels.
  ;(add-hook 'erc-join-hook 'bitlbee-netrc-identify)
#+end_src
*** EXWM - Emacs as X window manager
:PROPERTIES:
:ID:       df0f8ed9-65ea-483a-98f8-896e46b4fe66
:END:

#+begin_src emacs-lisp
  ;; (use-package exwm
  ;;   :disabled
  ;;   ;;    :demand t
  ;;   :config
  ;;   (require 'exwm-config)
  ;;   (require 'exwm-randr)
  
  ;;   ;; not using this - single monitor lyfe.
  ;;   ;; (setq exwm-randr-workspace-monitor-plist '(0 "eDP1" 1 "HDMI2"))
  ;;   (exwm-randr-enable)
  
  ;;   ;; I swap C-t and C-x, so this is a very useful thing to also have
  ;;   ;; as a prefix
  ;;   (add-to-list 'exwm-input-prefix-keys ?\C-t)
  
  ;;   (add-hook 'exwm-update-class-hook
  ;; 	    (lambda ()
  ;; 	      (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
  ;; 			  (string= "gimp" exwm-instance-name))
  ;; 		(exwm-workspace-rename-buffer exwm-class-name))))
  ;;   (add-hook 'exwm-update-title-hook
  ;; 	    (lambda ()
  ;; 	      (when (or (not exwm-instance-name)
  ;; 			(string-prefix-p "sun-awt-X11-" exwm-instance-name)
  ;; 			(string= "gimp" exwm-instance-name))
  ;; 		(exwm-workspace-rename-buffer exwm-title))))
  
  ;;   (setq cm/exwm-workspace-starting-number 1)
  
  ;;   (defun cm/exwm-workspace-next ()
  ;;     (interactive)
  ;;     (exwm-workspace-switch (mod (+ 1 exwm-workspace-current-index) (exwm-workspace--count))))
  
  ;;   (defun cm/exwm-workspace-previous ()
  ;;     (interactive)
  ;;     (exwm-workspace-switch (mod (- exwm-workspace-current-index 1) (exwm-workspace--count))))
  
  ;;   (defun cm/async-shell-no-output (cmd)
  ;;     (interactive)
  ;;     (call-process-shell-command (concat cmd " &")))
  
  ;;   (defun cm/exwm-lock ()
  ;;     (interactive)
  ;;     (cm/async-shell-no-output "notion-lock"))
  
  ;;   (defun cm/launch-term ()
  ;;     (interactive)
  ;;     (cm/async-shell-no-output "term"))
  
  ;;   (defun cm/launch-org-capture ()
  ;;     (interactive)
  ;;     (cm/async-shell-no-output "org-capture"))
  
  ;;   ;; Find all binaries in exec-path / (exec-path)
  ;;   (defun cm/all-binaries ()
  ;;     (let* ((path-dirs
  ;; 	    ;; Ignore `exec-directory', the last entry in `exec-path'.
  ;; 	    (append (cdr (reverse (if (fboundp 'exec-path) (exec-path) exec-path)))
  ;; 		    (if (and (memq system-type '(windows-nt ms-dos))
  ;; 			     (not (file-remote-p default-directory)))
  ;; 			'("."))))
  ;; 	   (completions '()))
  
  ;;       ;; Go thru each dir in the search path, finding completions.
  ;;       (while path-dirs
  ;; 	(setq dir (file-name-as-directory (comint-directory (or (car path-dirs) ".")))
  ;; 	      comps-in-dir (and (file-accessible-directory-p dir)
  ;; 				(directory-files dir nil nil 'nosort)))
  ;; 	;; Go thru each completion found, to see whether it should be used.
  ;; 	(while comps-in-dir
  ;; 	  (setq file (car comps-in-dir)
  ;; 		abs-file-name (concat dir file))
  ;; 	  (if (and (not (member file completions))
  ;; 		   (not (file-directory-p abs-file-name))
  ;; 		   (or (null shell-completion-execonly)
  ;; 		       (file-executable-p abs-file-name)))
  ;; 	      (setq completions (cons file completions)))
  ;; 	  (setq comps-in-dir (cdr comps-in-dir)))
  ;; 	(setq path-dirs (cdr path-dirs)))
  ;;       completions))
  
  ;;   (defun cm/launch-shell-cmd (cmd)
  ;;     (interactive
  ;;      (list
  ;;       (completing-read "Command: " (cm/all-binaries))))
  ;;     (cm/async-shell-no-output cmd))
  
  ;;   (exwm-input-set-key (kbd "s-<f2>") #'cm/launch-term)
  ;;   (exwm-input-set-key (kbd "s-<f3>") #'cm/launch-shell-cmd)
  
  ;;   (exwm-input-set-key (kbd "s-<return>") #'exwm-layout-toggle-fullscreen)
  ;;   (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  ;;   (exwm-input-set-key (kbd "s-c") #'cm/launch-org-capture)
  ;;   (exwm-input-set-key (kbd "s-n") #'cm/exwm-workspace-next)
  ;;   (exwm-input-set-key (kbd "s-p") #'cm/exwm-workspace-previous)
  ;;   (exwm-input-set-key (kbd "s-l") #'cm/exwm-lock) 
  
  ;;   (setq async-shell-command-display-buffer nil)
  ;;   (setq exwm-workspace-show-all-buffers t)
  ;;   (setq exwm-layout-show-all-buffers t)
  
  ;;   ;; set none for now
  ;;   ;; (exwm-input-set-simulation-keys
  ;;   ;;  '(([?\C-b] . left)
  ;;   ;;    ([?\C-f] . right)
  ;;   ;;    ([?\C-p] . up)
  ;;   ;;    ([?\C-n] . down)
  ;;   ;;    ([?\C-a] . home)
  ;;   ;;    ([?\C-e] . end)
  ;;   ;;    ([?\M-v] . prior)
  ;;   ;;    ([?\C-v] . next)
  ;;   ;;    ([?\C-d] . delete)
  ;;   ;;    ([?\C-k] . (S-end delete))))
  
  ;;   (dotimes (i cm/exwm-workspace-starting-number)
  ;;     (exwm-input-set-key (kbd (format "s-%d" i))
  ;; 			`(lambda ()
  ;; 			   (interactive)
  ;; 			   (exwm-workspace-switch-create ,i))))
  
  ;;   ;; enable systemtray
  ;;   (require 'exwm-systemtray)
  ;;   (exwm-systemtray-enable)
  
  ;;   ;; exwm-enable should be called from -f, we do not call it in our init.
  ;;   )
#+end_src

*** Flymake
    :PROPERTIES:
    :ID:       b379d31d-a542-496b-ad6b-31817952e93d
    :END:
#+begin_src emacs-lisp
  ;; stolen from http://www.reddit.com/r/emacs/comments/i05v3/emacs_and_pylint/c1ztm6x (user kanak on /r/emacs)
  (require 'flymake)
  
  (setq *cm/flychecker-directory* "~/.emacs.d/flycheck")
  
  (defmacro def-flymake-init (mode checker-file)
    "Writes a function called flymake-MODE-init which contains the usual boilerplate for a default flymake initialization."
    `(defun ,(intern (format "flymake-%s-init" mode)) () 
        (let* ((temp-file (flymake-init-create-temp-buffer-copy 
                     'flymake-create-temp-inplace)) 
         (local-file (file-relative-name 
                      temp-file 
                      (file-name-directory buffer-file-name)))) 
    (list (expand-file-name ,checker-file *cm/flychecker-directory*) (list local-file)))))
  
  (defmacro def-flymake-cleanup (mode extlist)
    "Writes a function called flymake-MODE-cleanup which removes files with specified extensions in current directory."
    `(defun ,(intern (format "flymake-%s-cleanup" mode)) ()
   (when flymake-temp-source-file-name
     (let* ((temp-files
             (mapcar (lambda (ext)
                       (concat 
                        (file-name-sans-extension flymake-temp-source-file-name) ext))
                     ,extlist)))
       (dolist (f temp-files)
         (when (file-exists-p f)
           (flymake-safe-delete-file f)))))
   (flymake-simple-cleanup)))
  
  (def-flymake-init "python" "~/.emacs.d/flycheckbin/pychecker.sh")
  (add-to-list 'flymake-allowed-file-name-masks '("\\.py\\'" flymake-python-init)) 
  
  ;; flyspell
  (setq ispell-program-name "aspell")
  (setq ispell-list-command "list")
  (setq ispell-extra-args '("--sug-mode=ultra"))
#+end_src
*** Geiser
    :PROPERTIES:
    :ID:       10f9438e-5499-4cac-8d6f-6fe2ceec10d2
    :END:
Let's get our scheme on!
#+begin_src emacs-lisp
  (require 'geiser-install nil t)

  (setq geiser-active-implementations '(guile))
  (setq geiser-default-implementation 'guile)
#+end_src
*** Muse
    :PROPERTIES:
    :ID:       33123e64-e792-45bc-8260-9ea8a40ca039
    :END:
Good for person wikis, however I pretty much exclusively use =org-blog=/=org-export= now.
#+begin_src emacs-lisp
  (add-hook 'muse-mode-hook '(lambda ()
                               (footnote-mode 1)
                               (flyspell-mode 1)
                               (auto-fill-mode 1)))
  ;; My wiki's!
  ;;(setq muse-project-alist
  ;;      '(("Personal Miki" ("~/miki/src" :default "index")
  ;;         (:base "html" :path "~/miki/html"))))
#+end_src

*** Org
    :PROPERTIES:
    :ID:       2a2bc3dc-a714-4bd9-adb1-c262ffcd5f62
    :END:
Holy god. Let it begin.

**** Install org mode correctly
:PROPERTIES:
:ID:       2bcb2ab2-ee9a-4588-bdea-116f3a9757c4
:END:
I install the stable version of org from ELPA and then I manually
install org-contrib because the org packages are not layed out sanely.

As of [2019-01-28 Mon 10:44] they have an org package and an
org-plus-contrib package. A lot of packages directly require the org
package, so you end up installing both. What happens then is
org-plus-contrib is not provided at a stable version number
(reasonable for the contrib part) but then the org part get's updated
to an unstable version as well. I don't want to deal with that every
time.

So, I install org, and then manually copy contrib.

#+begin_src sh :results none
  cd $HOME/config/emacs.d/site-lisp

  git clone https://code.orgmode.org/bzg/org-mode.git tmp.org-mode
  cd tmp.org-mode

  org_vers=`{ls -d ../../elpa/* | egrep '/org-[0-9\.]+$' | sed -r 's#.*/org-([0-9\.]+)$#\1#'} #`
  git checkout release_$org_vers
  rm -r ../org-contrib
  cp -r contrib ../org-contrib
  cd ..
  rm -rf tmp.org-mode
#+end_src

**** Initialize org mode
     :PROPERTIES:
     :ID:       9c315d7c-fa8f-4e3c-843c-a9c37b06486f
     :END:
I add a =*.org= regex to the =auto-mode-alist=, start up org-protocol
so I can use my Firefox bookmark and emacsclient integration, and
org-mouse in case I already have a pointing device. I imagine
=org-mouse= will be more useful when I try and run emacs on a tablet.
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))

  (require 'org-loaddefs)
  (require 'org)
  (require 'org-protocol)
  (require 'org-mouse)
  (require 'org-attach)
#+end_src
**** Org Agenda
     :PROPERTIES:
     :ID:       9fdf73e8-52bf-4c3a-b0da-86280d3929fe
     :END:

***** Receipt Agenda
     :PROPERTIES:
     :ID:       86b9b44b-96cd-47c3-8fd5-3086cb77c05b
     :END:
#+begin_src emacs-lisp
  (defun org-receipt-agenda (match)
    (setq org-agenda-include-all-todo nil
          org-agenda-span 7
          org-agenda-show-all-dates t)
    (org-agenda-list))
#+end_src

***** Custom agendas
     :PROPERTIES:
     :ID:       16aafc16-4240-4a4a-98f6-92186bc07d14
     :END:
Set up the styling. These are headers and footers that make it nicer
to see my review adgendas, and easier on the eyes to follow.
#+begin_src emacs-lisp
  (setq cm/org-sort-style '((org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
			    (org-agenda-sorting-strategy
			     '((agenda habit-down time-up priority-down category-keep)
			       (todo tsia-up)
			       (tags tsia-up)
			       (search tsia-up)))))

  (defun cm/review-section (title)
    `((org-agenda-overriding-header ,(concat "########## " title " ##################################################"))))
  (defun cm/review-header (title)
    `((org-agenda-overriding-header ,(concat "     " title))))
  ;; this dynamic title sizing doesn't work because the org-agenda
  ;; buffer is created when org-agenda is called. :/
    ;; (let* ((basewidth (/ (- (window-body-width) (+ (length title) 6)) 4.0))
    ;;        (leftside (make-string (floor basewidth) ?+))
    ;;        (rightside (make-string (ceiling basewidth) ?+)))
    ;;   `((org-agenda-overriding-header ,(concat leftside " " title " " rightside)))))

  (defun cm/org-ctx-agenda (key ctx title)
    (let ((ctxlist (if (listp ctx) ctx (list ctx))))
      `(,(concat "c" key) ,title
	((tags-todo ,(mapconcat #'(lambda (x) (concat x "-TODO=\"PROJECT\"-TODO=\"WAITING\"")) ctxlist "|")))
	(,@cm/org-sort-style
	 (org-agenda-overriding-header ,title)))))
#+end_src

The org agenda. It's mostly for gtd usage, so I have the following views:

- =d= :: "Day" view, useful for use throughout the day when I've
         scheduled most things and marked tasks as "NEXT"
- =i= :: inbox (anything without a tag, usually from orgmobile)
- =n= :: "next" agenda (Rarely used as this is also covered in the day
         view, just super flagged items I need to look into)
- =r= :: Review commands, currently there is 'r d' for review a day
         and 'r w' for review a week. These hopefully will get much
         more sophisticated as part of my review process.
- =p= :: Projects list. The projects list in GTD is one of the most
         important lists, so keeping this up to date and reviewed is
         very important. I'd love to add something like 'levels of
         focus' agendas for each, but it's just not a practical way to
         review things that are done so infrequently.
- =c= :: Context commands, there are several, but the highlights are
         they use the *same* keys as the relevant tagging short keys
         for filing, so my brain uses them easily. I can finally move
         =INTERNET= from =v= to =i= with this change, but the muscle
         memory is already set, so we'll have to wait and see on that
         one.
- =x= :: Checklist agenda, these are largely for pre-flight checklists
         that I maintain. Not sure how to integrate them into my whole
         emacs / org-mode flow just yet.
- =g= :: gtd lists, a grouping for things that are GTD related, that I
         check less frequently. Some of the above may move into here just so
          we don't end up conflicting over time.
#+begin_src emacs-lisp
  (defun cm/day-agendas ()
    `(("d" "Full Day Agenda"
       ((agenda "Today" ((org-agenda-span 1)))
	(todo "NEXT"))
       ((org-agenda-start-with-log-mode t)))
      ("i" "Inbox"
       ((tags-todo "-{.*}-TODO=\"PROJECT\"-TODO=\"WAITING\""))
       ((org-agenda-overriding-header "Inbox")))
      ("n" "Next agenda"
       ((todo "NEXT")
	(todo "TODO"))
       ((org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
	(org-agenda-sorting-strategy
	 '((todo tag-up tsia-up)
	   (search tsia-up)))))))
  
  (defun cm/context-agendas ()
    `(("p" "Project Agenda"
       ((stuck "")
	(todo "PROJECT"))
       ,cm/org-sort-style)
      ,(cm/org-ctx-agenda "h" '("INTERNET" "COMPUTER" "HOME" "ERRAND" "PHONE")  "Home Agenda")
      ,(cm/org-ctx-agenda "w" '("INTERNET" "COMPUTER" "WORK" "PHONE")  "Work Agenda")
      ,(cm/org-ctx-agenda "b" '("INTERNET" "COMPUTER" "PHONE")  "Bus Agenda")
      ,(cm/org-ctx-agenda "t" '("COMPUTER" "PHONE")  "Train Agenda")
      ,(cm/org-ctx-agenda "p" '("PHONE")  "Phone Agenda")
      ,(cm/org-ctx-agenda "m" '("INTERNET" "ERRAND" "PHONE")  "Mobile Agenda")
      ("ca" "People Agenda"
       ((tags-todo "AGENDA-TODO=\"PROJECT\"-TODO=\"WAITING\"|TODO=\"WAITING\""))
       ((org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
	(org-agenda-sorting-strategy
	 '((agenda habit-down time-up priority-down category-keep)
	   (tags alpha-down)))))
      ("ct" "Tickler Agenda"
       ((tags-todo "-TODO=\"PROJECT\"-TODO=\"WAITING\"")
	(todo "PROJECT"))
       ((org-agenda-skip-function '(org-agenda-skip-entry-if 'notscheduled))
       (org-agenda-sorting-strategy '(tsia-up))))))
  
  (defun cm/gtd-agendas ()
    `(("gh" "Higher Horizons"
       ((tags "50K" ,(cm/review-header "Life Purpose & Principles"))
	(tags "40K" ,(cm/review-header "Life Vision (5 years)"))
	(tags "30K" ,(cm/review-header "Goals and Objectives (12-24)"))
	(tags "20K" ,(cm/review-header "Areas of Focus and Responsibility"))
	(todo "PROJECT" ,(cm/review-header "Projects and Alignment")))
       ((org-agenda-entry-text-maxlines 10000)
	(org-agenda-entry-text-mode 1)))))
  
  (defun cm/review-agendas ()
    `(("rd" "Daily Review"
       ((agenda)
	(todo "DONE|NVM"))
       ((org-agenda-span 3)
	(org-agenda-start-day "-1d")))
      ("rs" "Weekly Snippet Review"
       ((agenda))
       ((org-agenda-span 7)
	(org-agenda-start-on-weekday 1)
	(org-agenda-start-with-log-mode t)
	(org-agenda-archives-mode t)))
      ("rw" "Weekly Review Agenda"
       (;; GET CLEAR
	(tags-todo "noop" ,(cm/review-section "Get Clear!"))
	(tags-todo "noop" ,(cm/review-header "Collect Loose Papers and Materials"))
	(tags-todo "-{.*}-TODO=\"PROJECT\"-TODO=\"WAITING\""
		   ,(cm/review-header
		     (concat
		      "Get IN to ZERO\n"
		      "Digital Inboxes:\n"
		      "- [[https://keep.google.com][Google Keep]]\n"
		      "- [[https://fastmail.com][Personal Inbox]]\n"
		      "- [[https://www.google.com/maps/timeline][Location History]]\n"
		      "- [[https://photos.google.com][Recent photos]]\n"
		      "- [[file:~/downloads][Recent downloads]]\n"
		      "- Unarchived phone messages\n"
		      "- [[file:~][Loose home files]]\n"
		      "- Inbox headings from org: \n")))
	(tags-todo "noop" ,(cm/review-header "Empty Your Head!"))
  
	;; GET CURRENT
	(tags-todo "noop" ,(cm/review-section "Get Current!"))
	(tags-todo "-TODO=\"PROJECT\"-TODO=\"WAITING\""
		   (,@(cm/review-header "Review Actions Lists:\n- Mark things that are invalid/done from the past week\n- Ensure all next actions are physically described")
		    (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))))
	(todo "DONE|NVM")
	(tags-todo "-TODO=\"PROJECT\"-TODO=\"WAITING\""
		   (,@(cm/review-header "Review Scheduled Actions Lists")
		    (org-agenda-skip-function '(org-agenda-skip-entry-if 'notscheduled))))
	(agenda "" (,@(cm/review-header "Review Previous Week Calendar Data")
		    (org-agenda-skip-function nil)
		    (org-agenda-span 14)
		    (org-agenda-start-day ,(concat "-" (number-to-string (+ 14 (cm/days-back-to-monday))) "d"))))
	(agenda "" (,@(cm/review-header "Review Current Week Calendar Data")
		    (org-agenda-skip-function nil)
		    (org-agenda-span 7)
		    (org-agenda-start-day ,(concat "-" (number-to-string (cm/days-back-to-monday)) "d"))))
  
	(agenda "" (,@(cm/review-header "Review Next Week Calendar Data")
		    (org-agenda-skip-function nil)
		    (org-agenda-span 14)
		    (org-agenda-start-day ,(concat "+" (number-to-string (- 7 (cm/days-back-to-monday))) "d"))))
	(todo "WAITING" ,(cm/review-header "Review Waiting For List: Mark things as done, add things you're waiting for"))
	(stuck "" ,(cm/review-header "Review Stuck Projects: Someday/Maybe or Next Actions!"))
	(todo "PROJECT" ,(cm/review-header "Review Projects and Larger Outcomes: Add missing next actions, make sure each is naturally planned"))
	(tags "CHECKLIST" ,(cm/review-header "Review Relevant Checklists: Any missing? Any new ones that could be added?"))
  
	;; GET CREATIVE
	(tags-todo "noop" ,(cm/review-section "Get Creative!"))
	(tags "SOMEDAY" ,(cm/review-header "Review Someday/Maybe List"))
	(tags-todo "noop" ,(cm/review-header "Empty Your Head!")))
       ((org-agenda-span 22)
	(org-agenda-start-on-weekday 1)
	(org-agenda-start-day ,(concat "-" (number-to-string (cm/days-back-to-monday)) "d"))))
      ("rq" "Quarterly Review Agenda"
       (;; GET CLEAR
	(tags-todo "noop" ,(cm/review-section "Get Clear!"))
	(tags-todo "noop" ,(cm/review-header "Empty Your Head!"))
  
	;; GET CURRENT
	(tags-todo "noop" ,(cm/review-section "Get Current!"))
	(tags "50K" ,(cm/review-header "Read and Review Life Purpose"))
	(tags "40K" ,(cm/review-header "Read and Review Visions"))
	(tags "30K" ,(cm/review-header "Read and Review Goals and Objectives"))
	(tags "20K" ,(cm/review-header "Read and Review Areas of Focus and Responsibility"))
	(todo "PROJECT" ,(cm/review-header "Read and Review Projects and Alignment"))
  
	;; GET CREATIVE
	(tags-todo "noop" ,(cm/review-section "Get Creative!"))
	(tags-todo "noop" ,(cm/review-header "What Went Well This Quarter, and Why?"))
	(tags-todo "noop" ,(cm/review-header "What Went Poorly This Quarter, and Why?"))
	(tags-todo "noop" ,(cm/review-header "Am I Headed the Right Direction?"))
	(tags-todo "noop" ,(cm/review-header "Empty Your Head!")))
       ((org-agenda-entry-text-maxlines 1000)
	(org-agenda-entry-text-mode 1)))))
  
  (defun cm/checklist-agendas ()
    '(("x" "All Checklists"
       ((tags "CHECKLIST"))
       ((org-agenda-entry-text-maxlines 100)
	(org-agenda-entry-text-mode 1)))))
  
  (defun cm/org-set-agenda ()
    (interactive)
    (setq org-agenda-custom-commands
	  (append
	   (cm/day-agendas)
	   (cm/context-agendas)
	   (cm/review-agendas)
	   (cm/checklist-agendas)
	   (cm/gtd-agendas)
	   '(("Z" "Receipt Agenda"
	      ((org-receipt-agenda)))))))
#+end_src
Dynamism! So a big part of what makes these nice is that they compute
what the right numbers of days on either side (via ndays) so I can see
weeks surrounding reviews. Unfortunately, these are the parts that
require the =cm/org-load-agenda= function as opposed to just being
able to set =org-agenda-custom-commands=
#+begin_src emacs-lisp
  (defun cm/days-back-to-monday ()
    (mod (+ (calendar-day-of-week (calendar-gregorian-from-absolute (org-today))) 6) 7))

  (defun cm/days-to-next-saturday ()
    (- 21 (cm/days-back-to-monday)))

  (defun cm/org-load-agenda ()
    (interactive)
    (with-current-buffer
	(if (cl-equalp major-mode 'org-mode)
	    (current-buffer)
          (get-buffer-create (cm/org-dir "gtd.org")))
      (cm/org-set-agenda)
      (org-agenda)))
#+end_src
Also, set it the first time on startup so org commands work as
expected.
#+begin_src emacs-lisp
  (cm/org-set-agenda)
#+end_src
print agendas
#+begin_src emacs-lisp
  (setq org-agenda-exporter-settings
	'((ps-print-color-p 'black-white)
	  (ps-landscape-mode t)
	  (htmlize-output-type 'css)))
#+end_src
***** Agenda todo/done capture commands
:PROPERTIES:
:ID:       857aa550-7986-4911-ad38-ef1d28ac67e0
:END:
This is really useful for Projects and others where I want to create
sub-tasks / references quickly from the agenda view. Thanks yet again
to Sacha Chua.
#+begin_src emacs-lisp
  (require 'org-agenda)
  (defun cm/org-agenda-done (&optional arg)
    "Mark current TODO as done.
  This changes the line at point, all other lines in the agenda referring to
  the same tree node, and the headline of the tree node in the Org-mode file."
    (interactive "P")
    (org-agenda-todo "DONE"))

  (defun cm/org-agenda-mark-done-and-add-followup ()
      "Mark the current TODO as done and add another task after it.
  Creates it at the same level as the previous task, so it's better to use
  this with to-do items than with projects or headings."
      (interactive)
      (org-agenda-todo "DONE")
      (org-agenda-switch-to)
      (org-capture 0 "t"))

  (defun cm/org-agenda-new ()
    "Create a new note or task at the current agenda item.
  Creates it at the same level as the previous task, so it's better to use
  this with to-do items than with projects or headings."
    (interactive)
    (org-agenda-switch-to)
    (org-capture 0))

  (defun cm/org-agenda-new-project-todo ()
    "Create a new note or task at the current project's level."
    (interactive)
    (org-agenda-switch-to)
    (if (not (cl-equalp (nth 2 (org-heading-components)) "PROJECT"))
	(error (format "%s %s" (org-heading-components)
		       ": Not a project tagged element! Cannot add dependent action"))
      (org-capture nil "b")))

  (defun cm/org-agenda-search-references ()
    (interactive)
    ;; get current agenda item's ID
    (org-agenda-check-no-diary)
    (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
			 (org-agenda-error)))
	   (buffer (marker-buffer hdmarker))
	   (pos (marker-position hdmarker))
	   entry-id)
      (org-with-remote-undo buffer
	(with-current-buffer buffer
	  (widen)
	  (goto-char pos)
	  (org-show-context 'agenda)
	  (setq entry-id (org-id-get nil t nil))
	  (message "Figured out entry-id: %s" entry-id)))
      ;; search for all headings that refer to that ID
      (org-tags-view t (concat "REFERENCE_ID=\"" entry-id "\""))))

  (defun cm/org-agenda-capture-references ()
    (interactive)
    (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
			 (org-agenda-error)))
	   (buffer (marker-buffer hdmarker))
	   (pos (marker-position hdmarker))
	   entry-id)
      (org-with-remote-undo buffer
	(with-current-buffer buffer
	  (widen)
	  (goto-char pos)
	  (org-show-context 'agenda)
	  (setq entry-id (org-id-get nil t nil))
	  (message "Figured out entry-id: %s" entry-id)))
      (org-capture)
      (org-set-property "REFERENCE_ID" entry-id)))

  ;; save position of current entry
  ;; first, see if this is currently a PROJECT, keep position.
  ;; second, see if this is a sub elmnt of a PROJECT, save pos of project
  ;; third, narrow to this subtree
  (defun cm/org-agenda-indirect-narrow-project ()
    (interactive)
    (let* ((marker (or (org-get-at-bol 'org-marker)
		       (org-agenda-error)))
	   (buffer (marker-buffer marker))
	   (pos (marker-position marker)))
      (save-excursion
	(with-current-buffer buffer
	  (outline-show-all)
	  (goto-char pos)
	  (dotimes (i (- (org-current-level) 1))
	    (ignore-errors (outline-up-heading 1 t))
	    (if (string-equal "PROJECT"
			      (nth 2 (org-heading-components)))
		(setq pos (point))
	      pos))))
      (with-current-buffer buffer
	(goto-char pos)
	(org-tree-to-indirect-buffer))))

  (defhydra cm/org-agenda-actions-hydra (org-agenda-mode-map "x" :exit t)
    "Custom agenda actions"
    ("d" (org-agenda-todo "DONE") "Mark DONE" :column "State")
    ("f" cm/org-agenda-mark-done-and-add-followup "Mark done & add follow-up task")
    ("n" cm/org-agenda-new "Capture at agenda item heading level" :column "Capture")
    ("k" cm/org-agenda-new-project-todo "Capture under project's heading")
    ("r" cm/org-agenda-search-references "Search for references to current item" :column "References")
    ("x" cm/org-agenda-capture-references "Capture reference for current item")
    ("o" cm/org-agenda-indirect-narrow-project "Open narrowed task, with relevant project"))


  (define-key org-agenda-mode-map "x" #'cm/org-agenda-actions-hydra/body)
#+end_src
***** Agenda block "now" line highlighting
:PROPERTIES:
:ID:       5de95678-a4db-4188-8d89-da210bb232ce
:END:
The usual line showing the current time in org-mode is too hard to
differentiate between it and the timegrid as of
[2020-07-10 Fri 14:44]. I'm going to change the face to something
easier to see given my wombat color scheme and how my scheduled TODO
lines are usually much longer.

#+begin_src emacs-lisp
  (set-face-attribute 'org-agenda-current-time nil :foreground "red")
#+end_src
**** Org Clock
     :PROPERTIES:
     :ID:       fbb22f25-0f77-44c8-ab44-47187909d25a
     :END:
This adds automatic task clocking. It's incredibly useful to figure
out how long tasks took that you start and stop.
#+begin_src emacs-lisp  
  (defun org-clock-in-if-starting ()
    "Clock in when the task is marked STARTED."
    (when (and (string= org-state "STARTED")
	       (not (string= org-last-state org-state)))
      (org-clock-in)))

  (defun org-clock-out-if-waiting ()
    "Clock in when the task is marked STARTED."
    (when (and (string= org-state "WAITING")
	       (not (string= org-last-state org-state))
	       (org-clocking-p))
      (org-clock-out)))

  (defun org-clock-out-if-started-todo ()
    (when (and (or (string= org-state "TODO")
		   (string= org-state "NEXT"))
	       (string= org-last-state "STARTED")
	       (org-clocking-p))
      (org-clock-out)))

  (add-hook 'org-after-todo-state-change-hook 'org-clock-in-if-starting)
  (add-hook 'org-after-todo-state-change-hook 'org-clock-out-if-waiting)
  (add-hook 'org-after-todo-state-change-hook 'org-clock-out-if-started-todo)
#+end_src

#+begin_src emacs-lisp
  (defun cm/org-currently-scheduled ()
    "Find what is currently scheduled for right now."
    (interactive)
    (message "Not implemented."))


  (defun cm/org-currently-doing ()
    "Find what is currently clocked as STARTED.

  Looks over the `org-agenda-files' and finds all headings that are
  tagged STARTED."
    (interactive)
    (setq files (org-agenda-files nil 'ifmode)
	  allitems nil)
    (while (setq file (pop files))
      (catch 'nextfile
	(org-check-agenda-file file)
	(setq rtn (org-agenda-get-day-entries file (calendar-gregorian-from-absolute (org-today)) :todo))
	(setq allitems (append allitems rtn))))
    (org-agenda-propertize-selected-todo-keywords "STARTED")
    (org-agenda-finalize-entries allitems 'todo))
#+end_src
***** Clocking hydra
:PROPERTIES:
:ID:       32c1b109-95ec-4a83-862c-2ba44704a445
:END:
This add some commands for managing and clocking my time in a hydra.
#+begin_src emacs-lisp
  (require 'counsel)

  (defun cm/org-clock-switch-to-name ()
    (when (string= "" cm/org-clock-switch-to-last-name)
      (error "Bad cm/org-clock-switch-to-last-name"))
    cm/org-clock-switch-to-last-name)

  (defvar cm/org-clock-switch-to-last-name ""
    "The last thing we saw as the switch to name.")

  ;; currently cant' take raw in
  (defun cm/org-clock-switch-to-action (selection)
    "Swich org clock to selection, either creating heading or selecting it."
    ;; a new heading instead!
    (if (stringp selection)
	(save-window-excursion
	  (save-excursion
	    ;; how to non-interactively capture??
	    (setq cm/org-clock-switch-to-last-name selection)
	    (org-capture nil "xc")
	    (org-goto-marker-or-bmk nil "org-capture-last-stored")
	    (org-clock-in)
	    (setq cm/org-clock-switch-to-last-name "")))
      (save-window-excursion
	(save-excursion
	  (org-goto-marker-or-bmk (cdr selection))
	  (org-clock-in)))))

  (defun cm/org-clock-filter-done-archived-headings (headings)
    (cl-remove-if (lambda (x) (or (string-match-p "/DONE " (car x))
			       (string-match-p "/Archive/" (car x))))
	       headings))

  ;; similar to counsel's org-goto, but we filter out DONE headings, and anything under /Archive/
  (defun cm/org-clock-switch-to ()
    (interactive)
    (let ((counsel-org-headline-display-todo t))
      (let (entries)
	(dolist (b (buffer-list))
	  (when (org-agenda-file-p (buffer-file-name b))
	    (with-current-buffer b
	      (when (derived-mode-p 'org-mode)
		(setq entries
		      (nconc entries
			     (cm/org-clock-filter-done-archived-headings
			      (counsel-outline-candidates
			       (cdr (assq 'org-mode counsel-outline-settings))
			       (counsel-org-goto-all--outline-path-prefix)))))))))
	(ivy-read "Clock switch to (or type new): " entries
		  :history 'cm/org-clock-switch-to-history
		  :action #'cm/org-clock-switch-to-action))))

  (defhydra hydra-org-clock (global-map "C-c x" :exit t :columns 2)
    "Navigate your clocking"
    ("g" (call-interactively #'org-clock-goto)
     "goto last clocked-in task")
    ("G" (let ((current-prefix-arg '(4)))
	   (call-interactively #'org-clock-goto))
     "goto recent clocked-in tasks")
    ("c" org-clock-in
     "in: current task")
    ("d" (let ((current-prefix-arg '(16)))
	   (call-interactively #'org-clock-in)
	   (org-save-all-org-buffers))
     "in: current and set as default")
    ("l" (let ((current-prefix-arg '(64)))
	     (call-interactively #'org-clock-in)
	     (org-save-all-org-buffers))
     "in: current at last clock-out time")
    ("o" org-clock-out "out: current task")
    ("x" cm/org-clock-switch-to "switch: to any or new task")
    ("q" nil "quit"))
  (global-set-key (kbd "C-c x") 'hydra-org-clock/body)
#+end_src

**** Useful setq's
     :PROPERTIES:
     :ID:       8bb80482-a3c3-4e9b-bc23-27fdfdf4d14c
     :END:
#+begin_src emacs-lisp  
  (setq org-stuck-projects
	    '("TODO=\"PROJECT\"" ("TODO" "NEXT" "WAITING") () ""))

  (add-to-list 'auto-mode-alist '("\\.org'$" . org-mode))
  (global-set-key (kbd "C-c l") 'org-store-link)
  (cm/defun-local-wrap cm/org-load-agenda-wrapped cm/org-load-agenda)
  (global-set-key (kbd "C-c a") 'cm/org-load-agenda-wrapped)
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)

  ;; need to set this manually as I load org so early.
  (setq org-x11idle-exists-p t) 
  (setq org-clock-x11idle-program-name "xprintidle")
  (setq org-clock-idle-time 10)

  (setq org-agenda-files (list (cm/org-dir)))

  ;; we also strip calendars.org from here
  (defun cm/org-buffer-files ()
    (cl-remove-if #'(lambda (x) (or
			      (string-suffix-p "calendars.org" x)
			      (string-suffix-p "_old" x)))
	       (mapcar #'buffer-file-name (org-buffer-list 'files))))

  (setq org-refile-targets `((nil
			      :maxlevel . 5)
			     (cm/org-buffer-files
			      :maxlevel . 5)
			     ((,(cm/org-dir "gtd.org")
			       ,(cm/org-dir "work.org"))
			      :maxlevel . 5)))

  ;; my dimmed face isn't that dim
  (face-spec-set
   'org-agenda-dimmed-todo-face
   '((((background light)) (:foreground "dark orange"))
     (((background dark)) (:foreground "light goldenrod")))
   'face-defface-spec)

  (setq org-src-fontify-natively t)
  (setq org-fontify-done-headline t)
  (setq calendar-mark-diary-entries-flag t)
  (setq org-adapt-indentation nil)
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-agenda-include-all-todo t)
  (setq org-agenda-include-diary t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown 'not-today)
  (setq org-agenda-span 'week)
  (setq org-agenda-tags-column -90)
  (setq org-agenda-use-tag-inheritance nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-attach-archive-delete 'query)
  (setq org-attach-id-dir (cm/org-dir "_attachments/"))
  (setq org-attach-method 'mv)
  (setq org-enforce-todo-dependencies t)
  (setq org-export-with-sub-superscripts nil)
  (setq org-startup-folded nil)
  (setq org-file-apps '((auto-mode . emacs)
			("\\.mm\\'" . default)
			("\\.x?html?\\'" . default)
			;; firefox no longer supports mhtml :(
			("\\.mhtml\\'" . "google-chrome %s")
			("\\.pdf\\'" . default)))
  (setq org-hide-leading-stars t)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-pretty-entities-include-sub-superscripts nil)
#+end_src

Using the "ABCDE" method of prioritization.

- A :: very important, something you must do. There are serious negative consequences if not done.
- B :: important, something you should do. There are only minor negative consequences if not done.
- C :: nice to do. There are no negative consequences if not done.
- D :: delegate. You should not do this, but someone else can.
- E :: eliminate, whenever possible.

#+begin_src emacs-lisp
  (setq org-priority-highest ?A)
  (setq org-priority-lowest ?E)
  (setq org-priority-default ?C)
#+end_src

#+begin_src emacs-lisp
  (setq org-refile-use-outline-path 'file)
  (setq org-return-follows-link nil)
  (setq org-reverse-note-order nil)
  (setq org-special-ctrl-a/e t)
  (setq org-special-ctrl-k t)
  (setq org-start-on-weekday nil)
  (setq org-tags-column -90)
  (setq org-use-speed-commands t)
  (setq org-use-sub-superscripts '{})
  (setq org-use-tag-inheritance nil)
  (setq org-pretty-entities t)
  (setq org-agenda-prefix-format
	'((agenda . " %i %-16:c%?-12t% s")
	  (todo . " %i %-16:c")
	  (tags . " %i %-16:c")
	  (search . " %i %-16:c")))

  (setq org-cycle-separator-lines 0)
  (setq org-catch-invisible-edits 'show-and-error)

  ;(setq org-completion-use-ido t)
  ;; disable dumb-ass git crap for now
  (advice-add 'org-attach-commit :override #'list)
  ;; less file local settings!
  ;; actually - let's do more file-local settings. Remove these asap.
  (setq org-global-properties '(("Effort_ALL" . "0:10 0:20 0:30 0:40 0:50 1:00 2:00 3:00 4:00 5:00 6:00 7:00 8:00 9:00 10:00 11:00 12:00")))
  (setq org-columns-default-format "%TODO %50ITEM(Task) %17Effort(Estimated Effort){:} %CLOCKSUM")
  (setq org-imenu-depth 99)

  (global-set-key (kbd "<f6>") 'org-clock-goto)

  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

#+end_src
**** Org Contacts
:PROPERTIES:
:ID:       573ec609-b59e-4453-9825-57abffc6ea9e
:END:
This is part of org-contrib, thus is not a "package" for use-package to use.
#+begin_src emacs-lisp
  (require 'org-contacts (concat (getenv "HOME") "/.emacs.d/site-lisp/org-contrib/lisp/org-contacts.el"))
  (setq org-contacts-files (list (cm/org-dir "_notes/contacts.org")))
#+end_src
**** Archiving
:PROPERTIES:
:ID:       25218533-957e-4791-8870-e3b5637716e2
:END:

These little functions do something super interesting for my GTD
workflow. When I go to archive a task, I generally want to move it
into these =_archive= folders I keep. However, if I'm working on a
long project, a lot of the time I like to keep notes or other
information that I've completed much closer to the project. So
whenever I press archive, I search to the parent heading using
outline-mode, and then get the tags from org. If the tags include
=:PROJECT:=, then I archive it to an =* Archive= subtree. If it's
parent is not a project, then I assume it's a bare todo, and archive
it the normal way.

#+begin_src emacs-lisp
  (setq org-archive-location "_archive/%s_old::")

  (defun cm/parent-tags ()
    (interactive)
    (save-excursion
      (with-current-buffer (current-buffer)
	(outline-show-all)
	(outline-up-heading 1 t)
	(nth 5 (org-heading-components)))))

  (defun cm/dependent-project-todo-p ()
    (interactive)
    (save-excursion
      (with-current-buffer (current-buffer)
	(outline-show-all)
	(let ((toret nil))
	  (dotimes (i (- (org-current-level) 1) toret)
	    ;; handle errors when levels are not uniform, we may go "up"
	    ;; too many times.
	    (ignore-errors (outline-up-heading 1 t))
	    (setq toret
		  (or toret
		      (string-equal "PROJECT"
				    (nth 2 (org-heading-components))))))))))

  (defun cm/gtd-archiver ()
    (interactive)
    (if (cm/dependent-project-todo-p)
	  (org-archive-to-archive-sibling)
	(org-archive-subtree)))

  (setq org-archive-default-command #'cm/gtd-archiver)
#+end_src
**** Tags and todo keywords
     :PROPERTIES:
     :ID:       49034a34-2766-4962-bd53-676f2d108704
     :END:
#+begin_src emacs-lisp
  (setq org-tag-alist '((:startgroup)
			("AGENDA"    . ?a)
			("COMPUTER" . ?c)
			("ERRAND" . ?e)
			("HOME"   . ?h)
			("INTERNET"  . ?i)
			("PHONE"     . ?p)
			("WORK"   . ?w)
			(:endgroup)
			("CHECKLIST" . ?x)))

  (setq org-log-done 'time)
  (setq org-log-into-drawer t) ; record state changes into LOGBOOK
  (setq org-todo-keywords
	'((sequence "TODO(t@)" "NEXT(n!)" "WAITING(w@)" "PROJECT(p)" "|" "DONE(d@)" "NVM(v@)")))
  (setq org-tags-exclude-from-inheritance '("CHECKLIST"))
#+end_src
**** org export
     :PROPERTIES:
     :ID:       8eedeae4-7a30-4dfe-94ff-93827481d847
     :END:
#+begin_src emacs-lisp
  (require 'pandoc-mode)
  ;; mediawiki + pandoc hack
  (setq pandoc-binary "/Users/jmickey/bin/pandoc")
  
  (defun cm/org-export-as-pandoc ()
    (interactive)
    (org-export-as-html 3 nil "*Org HTML Export*" t nil)
    (with-current-buffer "*Org HTML Export*"
      (pandoc-mode 1)
      (pandoc-set-write "mediawiki")
      (pandoc-run-pandoc nil)
      (pandoc-view-output)))
  
  ;(org-babel-load-file (expand-file-name
  ;                      "org-docco.org"
  ;                      (expand-file-name
  ;                       "scripts"
  ;                       (expand-file-name
  ;                        "contrib"
  ;                        (expand-file-name
  ;                         "org-src"
  ;                         dotfiles-dir)))))
#+end_src
**** org babel & export
     :PROPERTIES:
     :ID:       f6ce34e2-98fe-4916-aead-07bd1e3d1a1f
     :END:
#+begin_src emacs-lisp  
  (if cm/using-rc
      (setq org-babel-default-header-args:ditaa '((:results . "file")
						  (:exports . "results")
						  (:java . "'-Dfile.encoding=UTF-8'"))))
  (setq cm/ditaa-paths
	(list
	 (concat (getenv "HOME") "/bin/ditaa.jar")
	 "/usr/share/ditaa/ditaa.jar"
	 "/usr/share/java/ditaa/ditaa-0_9.jar"))

  (setq org-ditaa-jar-path
	(cl-reduce
	 (lambda (x y) (if (and x (file-exists-p x)) x y))
	 cm/ditaa-paths))

  (setq org-plantuml-jar-path plantuml-jar-path)
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)

  (org-babel-do-load-languages 
   'org-babel-load-languages
   '((emacs-lisp . t)
     (C . t)
     (R . t)
     (awk . t)
     (clojure . t)
     (ditaa . t)
     (dot . t)
     (gnuplot . t)
     (haskell . t)
     (latex . t)
     (ledger . t)
     (lisp . t)
     (org . t)
     (perl . t)
     (plantuml . t)
     (python . t)
     (ruby . t)
     (scheme . t)
     (shell . t)
     (sql .t)))
  (setq org-confirm-babel-evaluate t)  ; nah, let's be safe

  (setq org-babel-shell-names (cons "rc" org-babel-shell-names))
  (org-babel-shell-initialize)
  (autoload 'org-mime-org-buffer-htmlize "org-mime" "org-mime-org-buffer-htmlize" t nil)
  (defun cm/org-mime-send-buffer-hook ()
    (defun org-export-grab-title-from-buffer ()
      ""
      "!! replace me !!"))

  (add-hook 'org-mime-send-buffer-hook 'cm/org-mime-send-buffer-hook)
#+end_src
**** Publishing
     :PROPERTIES:
     :ID:       338bb160-77e1-4a63-ab6c-c80aab220da8
     :END:
How I deploy my personal website.
#+begin_src emacs-lisp
  ;; Inline images in HTML instead of producting links to the image
  (setq org-export-html-inline-images t)

  ;; Do not generate internal css formatting for HTML exports
  (setq org-export-htmlize-output-type nil)

  ;; Export with LaTeX fragments
  (setq org-export-with-LaTeX-fragments t)

  (require 'ox-tufte)

  ;; add advice around org-html-headline to not generate the <div> at
  ;; all, just the <section> wrapper.

  (defun cm/org-html-headline (headline contents info)
    "Transcode a HEADLINE element from Org to HTML.
  CONTENTS holds the contents of the headline.  INFO is a plist
  holding contextual information."
    (unless (org-element-property :footnote-section-p headline)
      (let* ((numberedp (org-export-numbered-headline-p headline info))
	     (numbers (org-export-get-headline-number headline info))
	     (level (+ (org-export-get-relative-level headline info)
		       (1- (plist-get info :html-toplevel-hlevel))))
	     (todo (and (plist-get info :with-todo-keywords)
			(let ((todo (org-element-property :todo-keyword headline)))
			  (and todo (org-export-data todo info)))))
	     (todo-type (and todo (org-element-property :todo-type headline)))
	     (priority (and (plist-get info :with-priority)
			    (org-element-property :priority headline)))
	     (text (org-export-data (org-element-property :title headline) info))
	     (tags (and (plist-get info :with-tags)
			(org-export-get-tags headline info)))
	     (full-text (funcall (plist-get info :html-format-headline-function)
				 todo todo-type priority text tags info))
	     (contents (or contents ""))
	     (id (or (org-element-property :CUSTOM_ID headline)
		     (org-export-get-reference headline info))))
	(if (org-export-low-level-p headline info)
	    ;; This is a deep sub-tree: export it as a list item.
	    (let* ((html-type (if numberedp "ol" "ul")))
	      (concat
	       (and (org-export-first-sibling-p headline info)
		    (apply #'format "<%s class=\"org-%s\">\n"
			   (make-list 2 html-type)))
	       (org-html-format-list-item
		contents (if numberedp 'ordered 'unordered)
		nil info nil
		(concat (org-html--anchor id nil nil info) full-text)) "\n"
	       (and (org-export-last-sibling-p headline info)
		    (format "</%s>\n" html-type))))
	  ;; Standard headline.  Export it as a section.
	  (let ((extra-class (org-element-property :HTML_CONTAINER_CLASS headline))
		(first-content (car (org-element-contents headline))))

	    (format "%s%s%s%s\n"
		    (pcase level
		      ('1 "")
		      ('2 "<section>")
		      (_ ""))
		    (format "\n<h%d id=\"%s\">%s</h%d>\n"
			    level
			    id
			    (concat
			     (and numberedp
				  (format
				   "<span class=\"section-number-%d\">%s</span> "
				   level
				   (mapconcat #'number-to-string numbers ".")))
			     full-text)
			    level)
		    ;; When there is no section, pretend there is an
		    ;; empty one to get the correct <div
		    ;; class="outline-...> which is needed by
		    ;; `org-info.js'.
		    (if (eq (org-element-type first-content) 'section) contents
		      (concat (org-html-section first-content "" info) contents))
		    (pcase level
		      ('1 "")
		      ('2 "</section>")
		      (_ ""))))))))

  (defun cm/org-html-section (section contents info)
    "Transcode a SECTION element from Org to HTML.
  CONTENTS holds the contents of the section.  INFO is a plist
  holding contextual information."
    (let ((parent (org-export-get-parent-headline section)))
      ;; Before first headline: no container, just return CONTENTS.
      (if (not parent) contents
	;; Get div's class and id references.
	(let* ((class-num (+ (org-export-get-relative-level parent info)
			     (1- (plist-get info :html-toplevel-hlevel))))
	       (section-number
		(and (org-export-numbered-headline-p parent info)
		     (mapconcat
		      #'number-to-string
		      (org-export-get-headline-number parent info) "-"))))
	  ;; Build return value.
	  (format "%s\n" (or contents ""))))))

  (advice-add #'org-html-headline :override #'cm/org-html-headline)
  (advice-add #'org-html-section :override #'cm/org-html-section)



  ;; List of projects
  ;; - codemac.net -- My personal website
  ;; - org-doc -- export all org documents
  (setq org-publish-project-alist
	`(("codemac-org"
	   :base-directory ,(cm/org-dir "_www/codemac.net")
	   :publishing-directory "~/tmp/codemac.net"
	   :recursive t
	   :base-extension "org"
	   :publishing-function org-html-publish-to-tufte-html
	   :exclude-tags ("noexport" "todo")
	   :html-head-extra "<link rel=\"stylesheet\" href=\"tufte.css\" type=\"text/css\" />"
	   :html-head-include-default-style nil
	   :html-head-include-scripts nil

	   ;; These are for tufte.css. It seems ox-tufte is very out of
	   ;; date.
	   :html-html5-fancy t
	   :html-container "section"
	   :html-divs ((preamble "div" "preamble")
		       (content "article" "content")
		       (postamble "div" "postamble"))
	   :html-doctype "xhtml5"
	   :section-numbers nil
	   :html-validation-link nil
	   :with-toc nil
	   :with-smart-quotes t
	   :auto-sitemap t)
	  ("codemac-static"
	   :base-directory ,(cm/org-dir "_www/codemac.net")
	   :publishing-directory "~/tmp/codemac.net"
	   :base-extension "css\\|pdf\\|png\\|jpg\\|gif\\|js\\|txt\\|mp3\\|ogg\\|swf\\|svg\\|woff\\|eot\\|ttf\\|html"
	   :publishing-function org-publish-attachment
	   :recursive t)
	  ("codemac" :components ("codemac-org" "codemac-static"))
	  ("org-doc-org"
	   :base-directory ,(cm/org-dir)
	   :publishing-directory "~/tmp/published-org"
	   :recursive t
	   :section-numbers nil
	   :table-of-contents nil
	   :base-extension "org"
	   :publishing-function (org-html-publish-to-html org-org-publish-to-org)
	   :plain-source t
	   :htmlized-source t
	   :style-include-default nil
	   :style "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
	   :auto-sitemap t
	   :sitemap-filename "index.html"
	   :sitemap-title "Test Publishing Area"
	   :sitemap-style "tree"
	   :author-info nil
	   :creator-info nil)
	  ("org-doc-static"
	   :base-directory ,(cm/org-dir)
	   :publishing-directory "~/tmp/published-org"
	   :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
	   :publishing-function org-publish-attachment
	   :recursive t
	   :author nil)
	  ("org-doc" :components ("org-doc-org" "org-doc-static"))))

  (defun org-save-then-publish ()
    (interactive)
    (save-buffer)
    (org-save-all-org-buffers)
    (org-publish-current-project))

  (defun cm/org-publish-codemac-net ()
    (interactive)
    (org-save-all-org-buffers)
    ;; delete everything in ~/tmp/codemac.net
    (delete-directory "~/tmp/codemac.net" 'recursive)
    (org-publish-project "codemac" 'force)
    (if (yes-or-no-p "Upload to public bucket? ")
	(async-shell-command "cd /home/jmickey/tmp/codemac.net && /home/jmickey/opt/google-cloud-sdk/bin/gsutil -m rsync -r -d . gs://codemac.net")))

#+end_src
**** Misc Funcs
     :PROPERTIES:
     :ID:       ef5ab78f-e0b9-4e28-b1b1-256a1253ec39
     :END:
#+begin_src emacs-lisp
  (defun cm/org-delete-link ()
    "Replace an org link of the format [[LINK][DESCRIPTION]] with DESCRIPTION.
  If the link is of the format [[LINK]], delete the whole org link.

  In both the cases, save the LINK to the kill-ring.

  Execute this command while the point is on or after the hyper-linked org link."
    (interactive)
    (when (derived-mode-p 'org-mode)
      (let ((search-invisible t) start end)
        (save-excursion
          (when (re-search-backward "\\[\\[" nil :noerror)
            (when (re-search-forward "\\[\\[\\(.*?\\)\\(\\]\\[.*?\\)*\\]\\]" nil :noerror)
              (setq start (match-beginning 0))
              (setq end   (match-end 0))
              (kill-new (match-string-no-properties 1)) ; Save the link to kill-ring
              (replace-regexp "\\[\\[.*?\\(\\]\\[\\(.*?\\)\\)*\\]\\]" "\\2" nil start end)))))))
#+end_src
**** Daily Journal file
:PROPERTIES:
:ID:       07ca6496-cb41-4479-a3bf-ed18b902af9b
:END:
#+begin_src emacs-lisp
  (setq cm/org-today-filefmt (cm/org-dir "_notes/%Y-%m-%d.org"))

  (setq cm/org-today-headerfmt "#+title: Daily Notes: %Y-%m-%d: %A\n#+filetags: :daily:\n#+date: <%Y-%m-%d>\n\n")

  (defun cm/org-today-header ()
    (interactive)
    (format-time-string cm/org-today-headerfmt))

  (defun cm/org-today-file ()
    (interactive)
    (file-truename (expand-file-name (format-time-string cm/org-today-filefmt))))

  (defun cm/org-today-open ()
    (interactive)
    (let ((todayfile (cm/org-today-file)))
      (if (file-exists-p todayfile)
	  (find-file todayfile)
	(find-file todayfile)
	(goto-char (point-min))
	(insert (cm/org-today-header)))))

  (global-set-key (kbd "C-c j") 'cm/org-today-open)
#+end_src
**** Checklist Creation
:PROPERTIES:
:ID:       800d3b1b-c043-466b-93f6-5ec5045c0f7b
:END:
This generates a set of TODOs based on a heading and a checklist. This
allows me to create checklist templates per-project.
#+begin_src emacs-lisp
  (defun cm/org-convert-checklist-to-todos (beg end)
    "Converts a list in the format:
  ,* Checklist Name :CHECKLIST:

  - [ ] one
  - [ ] two

  Into a list that looks like:

  ,* PROJECT Checklist name
  ,** TODO one
  ,** TODO two

  With ID's regenerated and CREATED timestamps included."
    (interactive (list
		  (save-excursion (org-back-to-heading t) (point))
		  (save-excursion (org-end-of-subtree t t) (point))))
    (goto-char end)
    (let ((template (buffer-substring beg end)))
      ;; Prepare clone.
      (with-temp-buffer
	(insert template)
	(org-mode)
	(goto-char (point-min))
	(org-show-subtree)
	(re-search-forward "^[[:space:]]*- ")
	(move-beginning-of-line nil)
	(push-mark (point-max) t t)
	(org-toggle-heading)
	(pop-mark)

	;; Add "PROJECT" todo state to parent heading
	(goto-char (point-min))
	(org-todo "PROJECT")
	(org-set-tags-to nil)

	;; loop over children, adding ID and CREATED timestamps
	(goto-char (point-max))
	(while (outline-previous-heading)
	  (org-id-get-create t)
	  (org-set-property "CREATED" (with-temp-buffer
					(org-mode)
					(org-time-stamp-inactive '(16))
					(buffer-string))))
	(goto-char (point-max))
	(insert "\n")
	(mark-whole-buffer)
	(let* ((inboxloc (org-id-find "492952f0-e1cf-41e8-a66d-cf1808f91619"))
	       (refileloc (list "Inbox" (car inboxloc) nil (cdr inboxloc))))
	  (org-refile nil nil refileloc nil)))))
#+end_src
**** Link Types
     :PROPERTIES:
     :ID:       dab4061f-b05e-4689-ba82-82ab90ce1d69
     :END:
#+begin_src emacs-lisp
  ;; org links!
  (org-add-link-type "man" 'org-man-open)
  (add-hook 'org-store-link-functions 'org-man-store-link)

  (defcustom org-man-command 'man
    "The Emacs command to be used to display a man page."
    :group 'org-link
    :type '(choice (const man) (const woman)))

  (defun org-man-open (path)
    "Visit the manpage on PATH.
       PATH should be a topic that can be thrown at the man command."
    (funcall org-man-command path))

  (defun org-man-store-link ()
    "Store a link to a manpage."
	 (when (memq major-mode '(Man-mode woman-mode))
	   ;; This is a man page, we do make this link
	   (let* ((page (org-man-get-page-name))
		  (link (concat "man:" page))
		  (description (format "Manpage for %s" page)))
	     (org-store-link-props
	      :type "man"
	      :link link
	      :description description))))

  (defun org-man-get-page-name ()
    "Extract the page name from the buffer name."
    ;; This works for both `Man-mode' and `woman-mode'.
    (if (string-match " \\(\\S-+\\)\\*" (buffer-name))
	(match-string 1 (buffer-name))
      (error "Cannot create link to this man page")))

  (defun cm/org-link-tel-open (number)
    (browse-url-firefox (concat "http://hangouts.google.com/?action=chat&pn=" number)))
  (org-add-link-type "tel" 'cm/org-link-tel-open)
#+end_src

**** Org Capture in new frames
:PROPERTIES:
:ID:       45c958f5-e821-4d8b-bf5c-1661c22c5cc4
:END:

#+begin_src emacs-lisp
  (defvar cm/org-capture-frame-height 50
    "Height of org-capture frame.")

  (defvar cm/org-capture-frame-width 160
    "Width of org-capture frame.")

  (defun cm/org-capture-other-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    ;; TODO: gather information about current window, assume this is
    ;; being called potentially in the background.

    (make-frame `((name . "Org-Capture")
		  (width . ,cm/org-capture-frame-width)
		  (height . ,cm/org-capture-frame-height)
		  (menu-bar-lines . 0)
		  (tool-bar-lines . 0)
		  (auto-lower . nil)
		  (auto-raise . t)))
    (select-frame-by-name "Org-Capture")
    (if (ignore-errors (progn (org-capture) t))
	(delete-other-windows)
      (cm/org-capture-other-frame-cleanup)))

  (defun cm/org-capture-other-frame-hook (orig-fun &rest args)
    "Hook for org-capture to pop-up a frame instead of embed in emacs."
    (make-frame '((name . "Org-Capture")
		  (width . 120)
		  (height . 40)
		  (menu-bar-lines . 0)
		  (tool-bar-lines . 0)
		  (auto-lower . nil)
		  (auto-raise . t)))
    (select-frame-by-name "Org-Capture")
    (if (condition-case err
	    (progn (apply 'funcall-interactively `(,orig-fun ,@args)) t)
	  ((debug error)
	   (progn
	     (message "org-capture-other-hook: err: %s" err)
	     nil)))
	(delete-other-windows)
      (cm/org-capture-other-frame-cleanup)))

  (defun cm/org-capture-other-frame-cleanup ()
    "Close the Org-Capture frame."
    (if (equal "Org-Capture" (frame-parameter nil 'name))
	(delete-frame)))

  ;;(advice-add 'org-capture :around #'cm/org-capture-other-frame-hook)
  (advice-add 'org-protocol-capture :around #'cm/org-capture-other-frame-hook)
  (add-hook 'org-capture-after-finalize-hook 'cm/org-capture-other-frame-cleanup)
#+end_src

**** Org Capture w/Window Information
:PROPERTIES:
:ID:       60235df2-0fbd-48d1-91ec-77e47e9b1f16
:END:
These functions are called by a script that is written here:
#+begin_src sh
#!/usr/bin/env rc
wm_class=`{xprop -id `{xdotool getwindowfocus} WM_CLASS | sed -r 's/^WM_CLASS\(.*\) = (.*)$/\1/' | sed -r 's/"//g'}
wm_name=`{xprop -id `{xdotool getwindowfocus} WM_NAME | sed -r 's/^WM_NAME\([^ ]+\) = "(.*)"$/\1/' }
exec /usr/bin/emacsclient.google-emacs -e '(cm/org-capture-with-window-other-frame "'$"wm_class'" "'$"wm_name'" )'
#+end_src

***** Org-capture wrappers
:PROPERTIES:
:ID:       5fab78b1-35ba-41fc-9704-c714da9e5c67
:END:
Basic =org-capture= wrappers that pass along the wm_class and wm_name.

#+begin_src emacs-lisp
  (defvar cm/org-capture-appendix-string ""
    "String to append to the next org-capture.")

  (defun cm/org-capture-appendix ()
    (concat cm/org-capture-appendix-string "\n"))

  (defun cm/org-capture-with-window (wm_class wm_name)
    (interactive)
    ;; get content based on class & wm_name
    (setq cm/org-capture-appendix-string (cm/org-capture-create-appendix wm_class wm_name))
    (org-capture)
    (setq cm/org-capture-appendix-string ""))

  (defun cm/org-capture-with-window-other-frame (wm_class wm_name)
    (interactive)
    ;; get content based on class & wm_name, and insert into templates generically??
    (message "Capture called on WM_CLASS: %s WM_NAME: %s" wm_class wm_name)
    (setq cm/org-capture-appendix-string (cm/org-capture-create-appendix wm_class wm_name))
    (cm/org-capture-other-frame)
    (setq cm/org-capture-appendix-string ""))
#+end_src

***** WM_CLASS and WM_NAME information gathering.
:PROPERTIES:
:ID:       ac86dee1-0384-462a-8b4a-014fb31a76c0
:END:
Now we define the switch statement for wm_class & wm_name matching:
#+begin_src emacs-lisp
  (defun cm/org-capture-create-appendix (wm_class wm_name)
    (let ((appendix
	   (pcase wm_class
	     ("Navigator, Firefox-esr" (cm/org-capture-appendix-firefox wm_name))
	     ("google-chrome, Google-chrome" (cm/org-capture-appendix-chrome wm_name)))))
      (message "raw: %s :war" appendix)
      (if appendix (cm/replace-braces appendix) "")))

  (defun cm/org-capture-appendix-chrome (wm_name)
    "Get current focused tab URL from Chrome, and dump them in org
  format into the capture appendix."
    (string-trim (shell-command-to-string "curl -s http://0.0.0.0:9222/json/list | jq -M '[.[] | select(.type == \"page\") | select(.url != \"chrome://newtab/\")]' | jq -M '.[0] | \"[[\" + .url + \"][\" + .title + \"]]\"' | sed -r 's/^\"(.*)\"$/\\1/'")))

  (defun cm/replace-braces (str)
    (let* ((splits (split-string (string-trim str "\\[\\[" "\\]\\]") "\\]\\["))
	   (url (car splits))
	   (remainder (string-join (cdr splits) "][")))
      (concat "[[" url "][" (s-replace "]" "}" (s-replace "[" "{" remainder)) "]]")))

  ;; This assumse you have an extension that adds the url to the title
  ;; of the tab. Makes it much easier to grab the current window. The
  ;; above for chrome is pretty hacky too, considering doing the same
  ;; for chrome.
  (defun cm/org-capture-appendix-firefox (wm_name)
    "Get current focused tab URL from Firefox, and dump them in org
  format into the capture appendix."
    (cm/format-link-in-title wm_name " - Mozilla Firefox$"))

  (defun cm/format-link-in-title (wm_name suffix)
    (let* ((splits (split-string wm_name " :: "))
	   (url (string-trim-right (car (last splits)) suffix))
	   (title (string-join (butlast splits) " :: ")))
      (concat "[[" url "][" title "]]")))
#+end_src

**** EmacSQL - multi platform support
:PROPERTIES:
:ID:       B7E48079-0B51-44F1-AC00-4D0D9BBC6923
:END:

#+begin_src emacs-lisp
  (require 'emacsql-sqlite)
  
  (setq emacsql-sqlite-executable
	(expand-file-name 
	 (concat "sqlite/emacsql-sqlite." (symbol-name system-type))
	 emacsql-sqlite-data-root))
#+end_src

**** Org Roam
:PROPERTIES:
:ID:       ae53497d-e87f-4861-81b2-6b07c28972ed
:END:

Hopefully this replaces my hacked up notes.org, _notes directory, shitty zettl, etc.

#+begin_src emacs-lisp
  (use-package org-roam
    :custom (org-roam-directory (cm/org-dir "_notes"))
    :init
    (setq org-roam-tag-sources '(prop vanilla))
    (setq org-roam-capture-templates
	  '(("d" "default" plain "%?" :target (file+head "%<%Y%m%d%H%M>_${slug}.org" "#+title: ${title}
  ,#+date: <%<%Y-%m-%d %a %H:%M>>
  ") :unnarrowed t)))
    (setq org-roam-v2-ack t)
    :config
    (org-roam-db-autosync-mode))
#+end_src

**** Search through my _notes directory
:PROPERTIES:
:ID:       87aec6ac-bed3-4225-8d5d-53fe6fc0cc70
:END:
I like to record notes about various things in a long lived way via
plain text. However, I haven't actually used them that much because I
forget what I've even recorded!

To help get rid of that, I want to create an emacs interface where I
search through my notes based on headings, content, and possibly tags
of some form as well.

Let's first layout what we want the keymap to be like:

#+begin_src emacs-lisp
  (defhydra hydra-cm-org-notes (global-map "C-c n" :exit t)
    "Use your notes wisely, Luke"
    ("n" deft "search through all notes" :column "searching")
    ("a" cm/org-rifle-agenda "search agenda org files in ~/org")
    ("r" cm/org-notes-capture "new note")
    ("l" org-roam-buffer-toggle "show org-roam links" :column "roaming")
    ("g" org-roam-graph "show roam graph")
    ("f" org-roam-node-find "find note")
    ("i" org-roam-node-insert "insert roam refererce")
    ("q" nil "quit"))

  (global-set-key (kbd "C-c n") 'hydra-cm-org-notes/body)
#+end_src

#+begin_src emacs-lisp
  (use-package deft
    :config
    (setq deft-default-extension "org")
    (setq deft-directory (cm/org-dir "_notes/"))
    (setq deft-archive-directory (cm/org-dir "_attic/"))
    (setq deft-file-naming-rules '((noslash . "-")
				   (nospace . "_")
				   (case-fn . downcase)))
    (setq deft-use-filter-string-for-filename t)
  
    (defun cm/deft-parse-title (file contents)
    "Parse the given FILE and CONTENTS and determine the title.
  If `deft-use-filename-as-title' is nil, the title is taken to
  be the first non-empty line of the FILE.  Else the base name of the FILE is
  used as title."
      (let ((begin (string-match "^#\\+[tT][iI][tT][lL][eE]: .*$" contents)))
	(if begin
	    (string-trim (substring contents begin (match-end 0)) "#\\+[tT][iI][tT][lL][eE]: *" "[\n\t ]+")
	  (deft-base-filename file))))
  
    (advice-add 'deft-parse-title :override #'cm/deft-parse-title)
  
    (setq deft-strip-summary-regexp
	  (concat "\\("
		  "[\n\t]" ;; blank
		  "\\|^#\\+[[:alpha:]_]+:.*$" ;; org-mode metadata
		  "\\|^:PROPERTIES:\n\\(.+\n\\)+:END:\n"
		  "\\)")))
  #+end_src

THIS WAS WAY OVER THE TOP. We can just use =org-search-view= if we
want, though it requires more regex-y stuff and is slower across all
the files.

#+begin_src emacs-lisp
  (defun cm/org-notes-search (arg)
    (interactive "P")
    (let ((org-agenda-files (if arg
				(append org-agenda-files (list (cm/org-dir "_notes/")))
			      (list (cm/org-dir "_notes/"))))
	  (org-agenda-sticky nil))
      (org-search-view)))
#+end_src

***** helm-rifle support functions
:PROPERTIES:
:ID:       7951b6ea-3895-4a30-8d67-121280542ec7
:END:
#+begin_src emacs-lisp
  (defun cm/org-rifle-notes ()
    "search through all notes"
    (interactive)
    (helm-org-rifle-files (list (cm/org-dir "notes.org"))))

  (defun cm/org-rifle-agenda ()
    "search through agenda files"
    (interactive)
    (helm-org-rifle-agenda-files))

  (defun cm/org-rifle-global()
    "search through all org files"
    (interactive)
    (helm-org-rifle-directories (list (cm/org-dir)) t))
#+end_src
***** Deft support functions
:PROPERTIES:
:ID:       c84d8973-d982-426f-816a-f99bdb49cdbb
:END:

#+begin_src emacs-lisp
  (defun cm/deft-new-file-named (slug)
    (interactive "sNew file title (will be converted to filename): ")
    ;; we do this to make sure everything is opened up!
    (deft)
    (let* ((file (deft-absolute-filename slug))
	   (deft-filter-regexp (reverse (split-string slug))))
      (if (file-exists-p file)
	  (message "Aborting, file already exists: %s" file)
	(write-region (concat "#+title: " (deft-whole-filter-regexp)
			      "\n#+date: <" (format-time-string "%Y-%m-%d %a %H:%M") ">\n\n")
		      nil file nil)
	(deft-cache-update-file file)
	(deft-refresh-filter)
	(deft-open-file file)
	(with-current-buffer (get-file-buffer file)
	  (goto-char (point-max))))))
#+end_src

***** Capture support functions
:PROPERTIES:
:ID:       6285b887-2b35-410f-8e2a-8a0e6fc18aae
:END:
#+begin_src emacs-lisp
  (defun cm/org-notes-capture ()
    (interactive)
    (org-capture nil "n"))
#+end_src

**** Org Capture Templates
     :PROPERTIES:
     :ID:       47a9dc31-f51e-4ee3-b06f-44848cbe9a04
     :END:
#+begin_src emacs-lisp
  ;; org capture!
  (defun cm/org-child-location ()
    ;; get id of current location
    (pcase (org-id-find (org-id-get))
      (`(,path . ,position)
       (set-buffer (org-capture-target-buffer path))
       (widen)
       (org-capture-put-target-region-and-position)
       (goto-char position))
      (_ (error "Connot find target ID \"%s\"" id))))

  (setq cm/humble-todo-template (list "* TODO %?\n:PROPERTIES:\n:CREATED:  %U\n:END:\n%i\n\n%(cm/org-capture-appendix)" :prepend nil :empty-lines 1))
  (setq org-directory (cm/org-dir))
  (setq org-default-notes-file (cm/org-dir "gtd.org"))
  (setq org-board-capture-file (cm/org-dir "_notes/www.org"))
  (define-key global-map "\C-cr" 'org-capture)
  (setq org-capture-templates
	`(("t" "Todo" entry (file+headline ,(cm/org-dir "gtd.org") "Inbox")
	   ,@cm/humble-todo-template)
	  ("p" "Project" entry (id "a262e411-ff66-43fc-9124-341694564dda")
	   "* PROJECT %?\n:PROPERTIES:\n:CATEGORY:\n:CREATED:  %U\n:END:\n\n** Archive :ARCHIVE:\n\n" :empty-lines 1)
	  ("j" "Journal" entry (file ,(cm/org-dir "_editorial/journal.org"))
	   "* %T %?\n\n  %i\n  %a\n\n" :prepend nil :empty-lines 1)
	  ("c" "Add note to currently clocked task" entry (clock)
	   "* %U %?\n%a\n\n%i\n\n" :empty-lines 1)
	  ("a" "Address Book" entry (file ,(cm/org-dir "_notes/contacts.org"))
	   "* %(org-contacts-template-name)\n:PROPERTIES:\n:EMAIL: %(org-contacts-template-email)\n:END:" :empty-lines 1)
	  ("n" "Timed Notes" entry (file ,(cm/org-dir "notes.org"))
	   "* %T %?\n\n  %i\n  %a\n\n" :prepend nil :empty-lines 1)
	  ("d" "Logged distraction entry" entry (file+headline ,(cm/org-dir "gtd.org") "Inbox")
	   ,@cm/humble-todo-template
	   :clock-in t
	   :clock-resume t)
	  ("w" "Work captures")
	  ("wt" "Work Action" entry (file+headline ,(cm/org-dir "work.org") "Actions")
	   ,@cm/humble-todo-template)
	  ("wn" "Work Note" entry (file ,(cm/org-dir "work.org"))
	   "* %U %?\n\n  %i\n  %a\n\n" :prepend nil :empty-lines 1)
	  ("wp" "Work Project" entry (id "76f3a69b-b76a-425c-bc0f-8795cae8e290")
	   "* PROJECT %?\n:PROPERTIES:\n:CATEGORY:\n:CREATED:  %U\n:END:\n\n** Archive :ARCHIVE:\n\n" :empty-lines 1)
	  ("wj" "Work journal entry" plain (file+olp+datetree ,(cm/org-dir "_notes/work.org") "Notes")
	   "\n- %U %?\n\n" :tree-type week :empty-lines 1)
	  ("ws" "Snippet Log" entry (file+headline ,(cm/org-dir "work.org") "Snippets")
	   "* S: %?\n  %T\n\n#+begin_src shell :results raw :shebang \"#!/usr/bin/env rc \"\nsnippets\n#+end_src\n\n" :prepend nil :empty-lines 1)
	  ("r" "Review Captures")
	  ("ry" "Review Entry For The Year" entry (id "256745aa-ece4-4649-a616-52b0194850d0")
	   "* Review for %<%Y>\n:PROPERTIES:\n:CREATED:  %U\n:END:\n\n** Review previous year\n\n- What was completed?\n- What was not completed?\n- What was the best spent time?\n- What was the worst spent time?\n- What is the current financial, physical, emotional, mental, spiritual state?\n\n** Project future year\n\n- What to spend more time on in new year?\n- What to spend less time on in new year?\n- What projects should be started in the next year?\n- What project should be completed in the next year?\n\n" :empty-lines 1)
	  ("b" "Agenda Project" entry (function cm/org-child-location)
	   ,@cm/humble-todo-template)
	  ("f" "Fitness" table-line (file+headline ,(cm/org-dir "_notes/fitness.org") "Fitness")
	   ,(concat (format-time-string "| %Y.%m.%d-%H:%M |") " %^{Weight} | | %^{RHR} |") :table-line-pos "II-1" :empty-lines 1)
	  ("xw" "org-capture reference" entry (file ,(cm/org-dir "_notes/www.org"))
	   "* %U %?%:description\n:PROPERTIES:\n:URL: %:link\n:END:\n\n%:body\n\n" :empty-lines 1)
	  ("xc" "org-capture inbox clock" entry (file+headline ,(cm/org-dir "gtd.org") "Inbox")
	   "* TODO %(cm/org-clock-switch-to-name)\n:PROPERTIES:\n:CREATED:  %U\n:END:\n\n" :empty-lines 1 :immediate-finish t)
	  ("xi" "org-capture inbox" entry (file+headline ,(cm/org-dir "gtd.org") "Inbox")
	   "* TODO %?%:annotation\n:PROPERTIES:\n:CREATED:  %U\n:END:\n\n%:link\n\n%i\n\n" :empty-lines 1)))

  (defun cm/org-board-dl-hook ()
    (when (equal (buffer-name)
		 (concat "CAPTURE-" org-board-capture-file))
      (org-board-archive)))

  (add-hook 'org-capture-before-finalize-hook 'cm/org-board-dl-hook)


  (defun gtd ()
    (interactive)
    (find-file (cm/org-dir "gtd.org")))

  ;; Set up my diary file
  (setq diary-file (cm/org-dir "diary")) ;; deal with the fact that it's in the org folder

  (defun cm/region-html-to-org (start end)
    (interactive "r")
    (shell-command-on-region start end "pandoc -f html -t org '--wrap=none'" nil 'replace))

#+end_src

Also - remember to give everything an id number. This will really help
any of my plans to get org mode todos into easier to consume formats.
#+begin_src emacs-lisp
  (add-hook 'org-capture-prepare-finalize-hook 'org-id-get-create)
#+end_src

**** Merge handling
:PROPERTIES:
:ID:       4fff7702-13e4-4c37-a728-57237f0363e6
:END:
When I open a buffer in SMerge mode, org has everything all folded up,
and it becomes very difficult to see where things went. For ediff,
diff, and smerge modes we should really not have any folding at all.

#+begin_src emacs-lisp
  (add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
  (add-hook 'smerge-mode-hook #'outline-show-all)
  (add-hook 'diff-mode-hook #'outline-show-all)
#+end_src
**** Appt Reminders
     :PROPERTIES:
     :ID:       ac746ebc-a17c-443d-9430-876cd1330c57
     :END:
This creates the appt buffer so we get notifications about
appointments in the org mode calendar. It's not perfect, but it does
help with my forgetfulness.

[2021-08-25] no longer use this, trust my calendar notifications, and
trust that I sync things to my calendar from org mode.
#+begin_src emacs-lisp
;;  (setq appt-display-interval 1
;;	appt-message-warning-time 3)
;;  (appt-activate)
;;  (org-agenda-to-appt)
#+end_src
**** Two pane outline mode
:PROPERTIES:
:ID:       51542ee9-0b25-4227-95db-23ca94ac85dc
:END:
Stolen this from here:

https://emacs.stackexchange.com/questions/9530/how-can-i-get-an-org-mode-outline-in-a-2nd-buffer-as-a-dynamic-table-of-contents/14987#14987

Working on figuring out how to get a basic tree -> content two pane
view on things.
#+begin_src emacs-lisp
  (defun cm/open-tree-view ()
    "Open a clone of the current buffer to the left, resize it to 30 columns, and bind <mouse-1> to jump to the same position in the base buffer."
    (interactive)
    (let ((new-buffer-name (concat "<org-tree>-" (buffer-name))))
      ;; Create tree buffer
      (split-window-right 100)
      (balance-windows)
      (if (get-buffer new-buffer-name)
	  (switch-to-buffer new-buffer-name)  ; Use existing tree buffer
	;; Make new tree buffer
	(progn  (clone-indirect-buffer new-buffer-name nil t)
		(switch-to-buffer new-buffer-name)
		(read-only-mode)
		(hide-body)
		(toggle-truncate-lines)

		;; Do this twice in case the point is in a hidden line
		(dotimes (_ 2 (forward-line 0)))

		;; Map keys
		(use-local-map (copy-keymap outline-mode-map))
		(local-set-key (kbd "TAB") 'org-cycle)
		(local-set-key (kbd "<tab>") 'org-cycle)
		(local-set-key (kbd "q") 'delete-window)
		(mapc (lambda (key) (local-set-key (kbd key) 'cm/jump-to-point-and-show))
		      '("<mouse-1>" "RET"))))))

  (defun cm/jump-to-point-and-show ()
    "Switch to a cloned buffer's base buffer and move point to the cursor position in the clone."
    (interactive)
    (let ((buf (buffer-base-buffer)))
      (unless buf
	(error "You need to be in a cloned buffer!"))
      (let ((pos (point))
	    (win (car (get-buffer-window-list buf))))
	(if win
	    (select-window win)
	  (other-window 1)
	  (switch-to-buffer buf))

	(widen)
	(goto-char pos)
	;; (olivetti-mode 1)
	(org-narrow-to-element)
	(org-show-all)

	(when (invisible-p (point))
	  (show-branches)))))
#+end_src
**** Better Org Goto
:PROPERTIES:
:ID:       fc37c242-76e7-44b1-8e46-07639903f1be
:END:
#+begin_src emacs-lisp
  (defvar cm/org-goto-dirs (list (cm/org-dir "*.org"))
    "Org directories to search with goto")

  (setq counsel-org-goto-all-outline-path-prefix 'file-name)
  (setq counsel-org-goto-display-style 'path)
  (setq counsel-org-goto-separator "/")
  (setq counsel-org-goto-face-style 'org)

  (define-key org-mode-map (kbd "C-c C-j") 'counsel-org-goto-all)
  (define-key global-map (kbd "C-c g") 'counsel-org-goto-all)
#+end_src

**** Face settings for mixed-pitch-mode
:PROPERTIES:
:ID:       ed735a42-36c4-420a-94b0-89d06385f092
:END:
This makes the headings look as pretty as everything else, without
worrying about how the face was inherited.

#+begin_src emacs-lisp
  (defun cm/set-face-attribute-mixed (face)
    (set-face-attribute
     face nil
     :family (face-attribute 'variable-pitch :family)
     :height (face-attribute 'variable-pitch :height)))

  (defun cm/org-level-face-height (ratio)
    (truncate (* (face-attribute 'variable-pitch :height nil 'default) ratio)))

  (defun cm/org-level-set-face-height (part)
    (set-face-attribute (car part) nil :height (cm/org-level-face-height (cdr part))))

  (defvar cm/org-level-height-alist
    '((org-level-1 . 1.2)
      (org-level-2 . 1.1)
      (org-level-3 . 1.05)
      (org-level-4 . 1)
      (org-level-5 . 1)
      (org-level-6 . 1)
      (org-level-7 . 1)
      (org-level-8 . 1))
    "List of org-level faces to ratio of default variable height")

  (defun cm/mixed-pitch-mode ()
    (mapc #'cm/set-face-attribute-mixed org-level-faces)
    (mapc #'cm/org-level-set-face-height cm/org-level-height-alist)
    (mixed-pitch-mode 1))
#+end_src

**** Auto save to real buffer for org files
:PROPERTIES:
:ID:       1c3f9575-fd6f-4383-89c7-79f0da9a6419
:END:

#+begin_src emacs-lisp
  (add-hook 'auto-save-hook 'org-save-all-org-buffers)
#+end_src

**** My GTD-style agenda WAITING hook
:PROPERTIES:
:ID:       e468733c-46a0-470f-996d-9f3993849f56
:END:

This creates an inactive heading in the outline title that shows me when the
task was switched to WAITING. This helps me track how long something has been
waiting. Probably should use something like org-expiry.

#+begin_src emacs-lisp
  (defun cm/org-add-inactive-ts ()
    (interactive)
    (org-edit-headline
     (concat
      (format-time-string "[%Y-%m-%d %H:%M] ")
      (org-get-heading 'notags 'notodo 'nopriority 'nocomment))))

  (defun cm/org-todo-state-change-inactive-ts-waiting-hook ()
    (if (string= org-state "WAITING")
	(cm/org-add-inactive-ts)))

  (add-hook 'org-after-todo-state-change-hook 'cm/org-todo-state-change-inactive-ts-waiting-hook)
#+end_src

**** Zettelkasten & Org References (org-ref)
:PROPERTIES:
:ID:       188be46c-b60e-425b-a595-d49683a74cf7
:END:

Beginning my journey in keeping prodigous references & notes. The
biggest problem I'm going to have is actually maintaing the PDF's in
some reasonable way.

***** Org-ref setup
:PROPERTIES:
:ID:       c09b65ff-d875-47f1-a2fa-0e721fa94458
:END:

Not really using this yet, need to set this up right.

#+begin_src emacs-lisp
  ;; (use-package org-ref
  ;;   :init
  ;;   (setq org-ref-completion-library 'org-ref-ivy-cite)
  ;;   :config
  ;;   (require 'ivy-bibtex)
  ;;   (setq org-ref-bibliography-notes (cm/org-dir "_zettel/reference_notes.org")
  ;; 	org-ref-bibtex-hydra-key-binding "\C-cj"
  ;; 	org-ref-default-bibliography (list (cm/org-dir "_zettel/references.bib"))
  ;; 	org-ref-pdf-directory (cm/org-dir "_zettel/_pdf/")
  ;; 	bibtex-completion-notes-path (cm/org-dir "_zettel/")
  ;; 	reftex-default-bibliography (list (cm/org-dir "_zettel/references.bib")))
  ;;    (require 'org-ref-bibtex)
  ;;   (require 'doi-utils)
  ;;   (require 'org-ref-arxiv)
  ;;   (doi-utils-def-bibtex-type report ("report")
  ;; 			     author title publisher year month doi url))
#+end_src

***** Zettel deft setup
:PROPERTIES:
:ID:       8ee3de07-624f-41d4-8fa5-0cf40de7747f
:END:
Not sure what to do about this just yet, we'll see.

***** DAV syncing for orgzly
:PROPERTIES:
:ID:       9b064c81-bf4c-47ed-9501-295ccfd2f7b3
:END:
Syncthing ended up being very flaky for laptop usage, and conflict
resolution never really worked well. Switching to using DAV syncing
with orgzly.

#+begin_src emacs-lisp
  (setq cm/org-webdav-dir (cm/org-dir ".mobileorg-staging"))

  (defun cm/get-inbox-pos ()
    (save-excursion
      (with-current-buffer (find-buffer-visiting (cm/org-dir "gtd.org"))
	(goto-char (point-min))
	(re-search-forward "^\\* Inbox[        ]*$")
	(move-beginning-of-line nil)
	(point))))

  (defvar cm/org-sync-files-to-skip
    (list "calendars.org")
    "List of files to not sync with webdav.")

  (defun cm/org-sync-finish-pull ()
    (interactive)
    (save-excursion
      (with-temp-buffer
	(shell-command "cd $HOME/org/.mobileorg-staging && cp from-mobile.org ../from-mobile.org" t))
      (if (not (get-file-buffer (cm/org-dir "from-mobile.org")))
	  (find-file (cm/org-dir "from-mobile.org")))
      (with-current-buffer (get-file-buffer (cm/org-dir "from-mobile.org"))
	(revert-buffer t t t)
	(if (cl-equalp (point-max) (point-min))
	    (message "Nothing to move in from-mobile.org.")
	  (goto-char (point-max))
	  (push-mark (point-min) t t)
	  (org-refile nil nil `("gtd.org/Inbox"
				,(buffer-file-name (get-file-buffer (cm/org-dir "gtd.org")))
				""
				,(cm/get-inbox-pos)))
	  (org-save-all-org-buffers))
	(with-temp-buffer
	  (shell-command "cd $HOME/org/.mobileorg-staging && rm *.org.new"))
	(bury-buffer))))

  (defun cm/org-webdav-push ()
    (interactive)
    (save-excursion
      (org-save-all-org-buffers)
      (with-temp-buffer
	(shell-command "cd $HOME/org/.mobileorg-staging && cp $HOME/org/*.org ." t)
	(mapcar
	 (lambda (x) (delete-file
		      (concat (getenv "HOME") "/org/.mobileorg-staging/" x)))
	 cm/org-sync-files-to-skip)
	(shell-command "org-webdav-push" t))))

  ;; (defun cm/org-webdav-pull ()
  ;;   (interactive)
  ;;   (save-excursion
  ;;     (org-save-all-org-buffers)
  ;;     (with-temp-buffer
  ;;       (when (= (length (directory-files (cm/org-dir ".mobileorg-staging") nil ".*\\.org.new")) 0)
  ;; 	(shell-command "org-webdav-pull" t)))
  ;;     ;; loop over every file diff, merging with ediff
  ;;     (mapcar
  ;;      (lambda (newf)
  ;;        (let ((rc-diff-cmd
  ;; 	      (concat
  ;; 	       "emacs -q --debug-init --no-site-file "
  ;; 	       " --eval '(progn (require ''ediff)"
  ;; 	       " (menu-bar-mode -1)"
  ;; 	       " (tool-bar-mode -1)"
  ;; 	       " (scroll-bar-mode -1)"
  ;; 	       " (load-theme ''wombat)"
  ;; 	       " (keyboard-translate ?\\C-x ?\\C-t)"
  ;; 	       " (keyboard-translate ?\\C-t ?\\C-x)"
  ;; 	       " (setq ediff-window-setup-function ''ediff-setup-windows-plain)"
  ;; 	       " (add-hook ''ediff-quit-hook ''save-buffers-kill-emacs)"
  ;; 	       " (add-hook ''ediff-prepare-buffer-hook #''outline-show-all)"
  ;; 	       " (add-hook ''smerge-mode-hook #''outline-show-all)"
  ;; 	       " (add-hook ''diff-mode-hook #''outline-show-all)"
  ;; 	       " (ediff-files (cm/org-dir \".mobileorg-staging\")"
  ;; 	       newf "\" \"~/org/" (string-remove-suffix ".new" newf) "\"))'"))
  ;; 	     (bash-diff-cmd
  ;; 	      (concat
  ;; 	       "emacs -q --debug-init --no-site-file "
  ;; 	       " --eval \"(progn (require 'ediff)"
  ;; 	       " (menu-bar-mode -1)"
  ;; 	       " (tool-bar-mode -1)"
  ;; 	       " (scroll-bar-mode -1)"
  ;; 	       " (load-theme 'wombat)"
  ;; 	       " (keyboard-translate ?\\C-x ?\\C-t)"
  ;; 	       " (keyboard-translate ?\\C-t ?\\C-x)"
  ;; 	       " (setq ediff-window-setup-function 'ediff-setup-windows-plain)"
  ;; 	       " (add-hook 'ediff-quit-hook 'save-buffers-kill-emacs)"
  ;; 	       " (add-hook 'ediff-prepare-buffer-hook #'outline-show-all)"
  ;; 	       " (add-hook 'smerge-mode-hook #'outline-show-all)"
  ;; 	       " (add-hook 'diff-mode-hook #'outline-show-all)"
  ;; 	       " (ediff-files \\\"~/org/.mobileorg-staging/"
  ;; 	       newf "\\\" \\\"~/org/" (string-remove-suffix ".new" newf) "\\\"))\"")))
  ;; 	 (message "rc-cmd: %s" rc-diff-cmd)
  ;; 	 (message "bash-cmd: %s" bash-diff-cmd)
  ;; 	 (shell-command bash-diff-cmd)))
  ;;      (directory-files "~/org/.mobileorg-staging" nil ".*\\.org.new"))
  ;;     (cm/org-sync-finish-pull)))

  ;; (defun cm/org-sync-full ()
  ;;   (interactive)
  ;;   (org-save-all-org-buffers)
  ;;   (cm/org-webdav-pull)
  ;;   (cm/org-webdav-push)
  ;;   (org-save-all-org-buffers)
  ;;   (message "cm/org-sync-full complete"))

  ;; currently only pushes to mobile to ensure no conflicts
  (defun cm/org-sync ()
    (interactive)
    (org-save-all-org-buffers)
    (cm/org-webdav-push)
    (message "cm/org-sync complete"))

  (global-set-key (kbd "<f9>") #'cm/org-sync)

  (defmacro cm/with-network (&rest body)
    `(if (equal 70 (dbus-get-property
		    :system "org.freedesktop.NetworkManager" "/org/freedesktop/NetworkManager"
		    "org.freedesktop.NetworkManager" "State"))
	 (progn
	   ,@body)))

  (defvar cm/org-sync-icon-path
    "/usr/share/icons/gnome/32x32/actions/reload.png"
    "Icon to use for popup notification.")

  (defun cm/org-sync-alert ()
    (message "manually sync! aborting auto sync now")
    (notifications-notify
     :title "org-sync conflict"
     :body "Press <f9> to manually sync your org files"
     :app-icon cm/org-sync-icon-path))

  (defun cm/org-sync-timer ()
    (interactive)
    (save-excursion
      (org-save-all-org-buffers)
      (if (> (length (directory-files (cm/org-dir ".mobileorg-staging") nil ".*\\.org.new")) 0)
	  (cm/org-sync-alert)
	(with-temp-buffer
	  (shell-command "org-webdav-pull" t))
	(if (> (length (directory-files (cm/org-dir ".mobileorg-staging") nil ".*\\.org.new")) 0)
	    (cm/org-sync-alert)
	  (cm/org-sync-finish-pull)
	  (cm/org-webdav-push)
	  (org-save-all-org-buffers)
	  (message "cm/org-sync complete!")))))

  ;(run-with-idle-timer 15 t #'cm/org-sync-timer)

#+end_src

**** Org ID on every save
:PROPERTIES:
:ID:       e4d046a4-7bb9-4256-991e-ab28f1eb0130
:END:
#+begin_src emacs-lisp
  (defun cm/org-add-ids-in-file ()
    "Add ID properties to all headlines in the current file."
    (interactive)
    (org-map-entries 'org-id-get-create))
  
  (add-hook 'org-mode-hook
	    (lambda ()
	      (add-hook 'before-save-hook #'cm/org-add-ids-in-file nil 'local)))
#+end_src

*** RCIRC
    :PROPERTIES:
    :ID:       63cf268e-8426-426f-a6fe-62492899d659
    :END:
#+begin_src emacs-lisp
  ; (eval-after-load 'rcirc '(require 'rcirc-color))
  ; (require 'rcirc)
  ; ;; colors!
  ; 
  ; 
  ; (add-hook 'rcirc-markup-colors 'rcirc-markup-text-functions)
  ; 
  ; (defvar rcirc-color-vector ["black" "red" "green" "yellow" "blue" "magenta" "cyan" "white"]
  ;   "Vector of color names for the numbers 0-7.")
  ; 
  ; (defun rcirc-markup-colors (process sender response channel-buffer)
  ;   (while (re-search-forward "\C-c\\([0-7]\\)\\(.*?\\)\C-c" nil t)
  ;     (rcirc-add-face (match-beginning 0) (match-end 0)
  ;                     (cons 'foreground-color
  ;                           (aref rcirc-color-vector (string-to-number (match-string 1)))))
  ;     ;; start deleting at the end
  ;     (delete-region (1- (match-end 0)) (match-end 0))
  ;     (delete-region (match-beginning 0) (match-end 1))))
  ; 
  ; ;; Turn on logging everything to a special buffer, for debugging.
  ; ;(setq rcirc-debug-flag t)
  ; ;; scroll as little as possible
  ; (add-hook 'rcirc-mode-hook
  ;           (lambda ()
  ;             (set
  ;              (make-local-variable 'scroll-conservatively)
  ;              8192)))
  ; 
  ; ;; add reconnect
  ; (eval-after-load 'rcirc
  ;   '(defun-rcirc-command reconnect (arg)
  ;      "Reconnect the server process."
  ;      (interactive "i")
  ;      (unless process
  ;        (error "There's no process for this target"))
  ;      (let* ((server (car (process-contact process)))
  ;             (port (process-contact process :service))
  ;             (nick (rcirc-nick process))
  ;             channels query-buffers)
  ;        (dolist (buf (buffer-list))
  ;          (with-current-buffer buf
  ;            (when (eq process (rcirc-buffer-process))
  ;              (remove-hook 'change-major-mode-hook
  ;                           'rcirc-change-major-mode-hook)
  ;              (if (rcirc-channel-p rcirc-target)
  ;                  (setq channels (cons rcirc-target channels))
  ;                (setq query-buffers (cons buf query-buffers))))))
  ;        (delete-process process)
  ;        (rcirc-connect server port nick
  ;                       rcirc-default-user-name
  ;                       rcirc-default-full-name
  ;                       channels))))

#+end_src
This means that the format of the join command no longer supports
space separated channels - however - does now support keyed/passworded
channels correctly. The format is: =#channela,#channelb ,passwordb=
#+begin_src emacs-lisp
  ; (eval-after-load 'rcirc
  ;   '(defun-rcirc-command join (channels)
  ;      "Join CHANNELS.
  ; CHANNELS is a comma- or space-separated string of channel names."
  ;      (interactive "sJoin channels: ")
  ;      (let* ((chanpass (split-string channels " " t))
  ;             (split-channels (split-string (car chanpass) "," t))
  ;             (buffers (mapcar (lambda (ch)
  ;                                (rcirc-get-buffer-create process ch))
  ;                              split-channels)))
  ;        (rcirc-send-string process (concat "JOIN " channels))
  ;        (when (not (eq (selected-window) (minibuffer-window)))
  ;          (dolist (b buffers) ;; order the new channel buffers in the buffer list
  ;            (switch-to-buffer b))))))
  ; 
  ; (eval-after-load 'rcirc
  ;   '(defun rcirc (arg)
  ;      "Connect to all servers in `rcirc-server-alist'.
  ; 
  ; Do not connect to a server if it is already connected.
  ; 
  ; If ARG is non-nil, instead prompt for connection parameters."
  ;      (interactive "P")
  ;      (if arg
  ;          (let* ((server (completing-read "IRC Server: "
  ;                                          rcirc-server-alist
  ;                                          nil nil
  ;                                          (caar rcirc-server-alist)
  ;                                          'rcirc-server-name-history))
  ;                 (server-plist (cdr (assoc-string server rcirc-server-alist)))
  ;                 (port (read-string "IRC Port: "
  ;                                    (number-to-string
  ;                                     (or (plist-get server-plist :port)
  ;                                         rcirc-default-port))
  ;                                    'rcirc-server-port-history))
  ;                 (nick (read-string "IRC Nick: "
  ;                                    (or (plist-get server-plist :nick)
  ;                                        rcirc-default-nick)
  ;                                    'rcirc-nick-name-history))
  ;                 (user-name (read-string "IRC Username: "
  ;                                         (or (plist-get server-plist :user-name)
  ;                                             rcirc-default-user-name)
  ;                                         'rcirc-user-name-history))
  ;                 (password (read-passwd "IRC Password: " nil
  ;                                        (plist-get server-plist :password)))
  ;                 (channels (read-string "IRC Channels: "
  ;                                        (plist-get server-plist :channels)))
  ;                 (encryption (rcirc-prompt-for-encryption server-plist)))
  ;            (rcirc-connect server port nick user-name
  ;                        rcirc-default-full-name
  ;                        channels password encryption))
  ;        ;; connect to servers in `rcirc-server-alist'
  ;        (let (connected-servers)
  ;       (dolist (c rcirc-server-alist)
  ;         (let ((server (car c))
  ;               (nick (or (plist-get (cdr c) :nick) rcirc-default-nick))
  ;               (port (or (plist-get (cdr c) :port) rcirc-default-port))
  ;               (user-name (or (plist-get (cdr c) :user-name)
  ;                              rcirc-default-user-name))
  ;               (full-name (or (plist-get (cdr c) :full-name)
  ;                              rcirc-default-full-name))
  ;               (channels (plist-get (cdr c) :channels))
  ;               (password (plist-get (cdr c) :password))
  ;               (encryption (plist-get (cdr c) :encryption))
  ;               contact)
  ;           (when server
  ;             (let (connected)
  ;               (dolist (p (rcirc-process-list))
  ;                 (when (string= server (process-name p))
  ;                   (setq connected p)))
  ;               (if (not connected)
  ;                   (condition-case e
  ;                       (rcirc-connect server port nick user-name
  ;                                      full-name channels password encryption)
  ;                     (quit (message "Quit connecting to %s" server)))
  ;                 (with-current-buffer (process-buffer connected)
  ;                   (setq contact (process-contact
  ;                                  (get-buffer-process (current-buffer)) :host))
  ;                   (setq connected-servers
  ;                         (cons (if (stringp contact) contact server)
  ;                               connected-servers))))))))
  ;       (when connected-servers
  ;         (message "Already connected to %s"
  ;                  (if (cdr connected-servers)
  ;                      (concat (mapconcat 'identity (butlast connected-servers) ", ")
  ;                              ", and "
  ;                              (car (last connected-servers)))
  ;                    (car connected-servers))))))))

#+end_src

#+begin_src emacs-lisp
  ; (setq rcirc-default-nick "codemac")
  ; (setq rcirc-default-user-name "codemac")
  ; (setq rcirc-default-user-full-name "codemac")
  ; 
  ; (setq rcirc-server-alist cm/rcirc-server-alist)
  ; (setq rcirc-authinfo cm/rcirc-authinfo)
  ; (setq rcirc-startup-channels-alist '(("\\.freenode\\.net$" "#emacs")))
  ; 
  ; ;  (setq rcirc-time-format "%H:%M ") ; << that format suckts, nvm.
#+end_src
**** Reconnect
     :PROPERTIES:
     :ID:       3eab2e32-f8ff-4dba-a3c2-fe0c198c21b2
     :END:
#+begin_src emacs-lisp
  ; (defun-rcirc-command reconnect (arg)
  ;   "Reconnect the server process."
  ;   (interactive "i")
  ;   (if (buffer-live-p rcirc-server-buffer)
  ;       (with-current-buffer rcirc-server-buffer
  ;         (let ((reconnect-buffer (current-buffer))
  ;               (server (or rcirc-server rcirc-default-server))
  ;               (port (if (boundp 'rcirc-port) rcirc-port rcirc-default-port))
  ;               (nick (or rcirc-nick rcirc-default-nick))
  ;               channels)
  ;           (dolist (buf (buffer-list))
  ;             (with-current-buffer buf
  ;               (when (equal reconnect-buffer rcirc-server-buffer)
  ;                 (remove-hook 'change-major-mode-hook
  ;                              'rcirc-change-major-mode-hook)
  ;                 (let ((server-plist (cdr (assoc-string server rcirc-server-alist)))) 
  ;                   (when server-plist 
  ;                     (setq channels (plist-get server-plist :channels)))))))
  ;           (if process (delete-process process))
  ;           (rcirc-connect server port nick rcirc-default-user-name rcirc-default-full-name channels)))))
  ; 
  ; ;;; Attempt reconnection at increasing intervals when a connection is
  ; ;;; lost.
  ; 
  ; (defvar rcirc-reconnect-attempts 0)
  ; 
  ; ;;;###autoload
  ; (define-minor-mode rcirc-reconnect-mode
  ;   nil nil " Reconnect" nil
  ;   (if rcirc-reconnect-mode
  ;       (progn
  ;         (make-local-variable 'rcirc-reconnect-attempts)
  ;         (add-hook 'rcirc-sentinel-hooks
  ;                   'rcirc-reconnect-schedule nil t))
  ;     (remove-hook 'rcirc-sentinel-hooks
  ;                  'rcirc-reconnect-schedule t)))
  ; 
  ; (defun rcirc-reconnect-schedule (process &optional sentinel seconds)
  ;   (condition-case err
  ;       (when (and (eq 'closed (process-status process))
  ;                  (buffer-live-p (process-buffer process)))
  ;         (with-rcirc-process-buffer process
  ;           (unless seconds
  ;             (setq seconds (exp (1+ rcirc-reconnect-attempts))))
  ;           (rcirc-print
  ;            process "my-rcirc.el" "ERROR" rcirc-target
  ;            (format "scheduling reconnection attempt in %s second(s)." seconds) t)
  ;           (run-with-timer seconds nil 'rcirc-reconnect-perform-reconnect process)))
  ;     (error (rcirc-print process "RCIRC" "ERROR" nil
  ;                         (format "%S" err) t))))
  ; 
  ; (defun rcirc-reconnect-perform-reconnect (process)
  ;   (when (and (eq 'closed (process-status process))
  ;              (buffer-live-p (process-buffer process)))
  ;     (with-rcirc-process-buffer process
  ;       (when rcirc-reconnect-mode
  ;         (if (get-buffer-process (process-buffer process))
  ;             ;; user reconnected manually
  ;             (setq rcirc-reconnect-attempts 0)
  ;           (let ((msg (format "attempting reconnect to %s..."
  ;                              (process-name process))))
  ;             (rcirc-print process "my-rcirc.el" "ERROR" rcirc-target
  ;                          msg t))
  ;           ;; remove the prompt from buffers
  ;           (condition-case err
  ;               (progn
  ;                 (save-window-excursion
  ;                   (save-excursion
  ;                     (rcirc-cmd-reconnect nil)))
  ;                 (setq rcirc-reconnect-attempts 0))
  ;             ((quit error)
  ;              (incf rcirc-reconnect-attempts)
  ;              (rcirc-print process "my-rcirc.el" "ERROR" rcirc-target
  ;                           (format "reconnection attempt failed: %s" err)  t)
  ;              (rcirc-reconnect-schedule process))))))))
#+end_src
*** SLIME
    :PROPERTIES:
    :ID:       bb361611-de0c-480f-8919-e1ed77b583e0
    :END:
#+begin_src emacs-lisp
  (use-package slime
    :commands slime
    :init
    (setq inferior-lisp-program "sbcl")
    :config
    (slime-setup '(slime-fancy)))
  ;(load (expand-file-name "/home/codemac/.quicklisp/slime-helper.el"))

#+end_src
*** SQL
    :PROPERTIES:
    :ID:       b4967d83-57f9-4cb9-879f-f3a395509419
    :END:
Who needs a command line anyways..
#+begin_src emacs-lisp
  (defun sql-make-smart-buffer-name ()
    "Return a string that can be used to rename a SQLi buffer.
  
  This is used to set `sql-alternate-buffer-name' within
  `sql-interactive-mode'."
    (or (and (boundp 'sql-name) sql-name)
        (concat (if (not(string= "" sql-server))
                    (concat
                     (or (and (string-match "[0-9.]+" sql-server) sql-server)
                         (car (split-string sql-server "\\.")))
                     "/"))
                sql-database)))
  
  (add-hook 'sql-interactive-mode-hook
            (lambda ()
              (setq sql-alternate-buffer-name (sql-make-smart-buffer-name))
              (sql-rename-buffer)))
#+end_src
*** W3M
    :PROPERTIES:
    :ID:       79e3e87f-f769-4325-ac15-450572f79a6a
    :END:
#+begin_src emacs-lisp
  (autoload 'w3m-browse-url "w3m-load" "" t)
#+end_src
*** notmuch
    :PROPERTIES:
    :ID:       705f65b0-cd4f-4c2f-a7da-dc340505dbbc
    :END:
I'm not a fan that this isn't a simple =use-package= thing, but the
notmuch emacs implementation generally has to match the notmuch
binary - and it's easier to just use whatever my distro packages.
#+begin_src emacs-lisp
  (if (require 'notmuch nil t)
      (message "Notmuch found, enabling notmuch & mail support")
    (message "Notmuch not found :("))

  (when (require 'notmuch nil t)
    (setq cm/mail-script "mail-sync")

    (defun cm/notmuch-poll ()
      (interactive)
      (unless (equal (call-process cm/mail-script nil nil) 0)
	(error "Notmuch: poll script `%s' failed!" notmuch-poll-script)))

    (defun cm/notmuch-refresh-buffer-after-poll (proc state)
      (let ((buffer (process-buffer proc)))
	(with-current-buffer buffer
	  (with-current-buffer notmuch-buffer-to-refresh
	  (when notmuch-buffer-refresh-function
	    (call-interactively notmuch-buffer-refresh-function))))))

    (defun cm/notmuch-poll-and-refresh-this-buffer ()
      (interactive)
      (let ((old-buff (current-buffer)))
	(with-current-buffer (get-buffer-create "*notmuch-mail-sync*")
	  (set (make-local-variable 'notmuch-buffer-to-refresh) old-buff)
	  (let ((process (start-process-shell-command "async proc mail-sync" (current-buffer) "mail-sync")))
	    (set-process-sentinel process #'cm/notmuch-refresh-buffer-after-poll)))))

    (advice-add 'notmuch-poll :override #'cm/notmuch-poll)

    (advice-add 'notmuch-poll-and-refresh-this-buffer :override #'cm/notmuch-poll-and-refresh-this-buffer))
#+end_src
**** Sending mail
     :PROPERTIES:
     :ID:       58944cd4-e6a8-4053-8b9f-b51cd3e8bf34
     :END:
We're just borrowing the gnus settings here..
#+begin_src emacs-lisp
;  (setq smtpmail-auth-credentials "~/.netrc") ;; is this needed?
#+end_src
The smtpmail-multi-accounts block has a strict ordering. By using ssl
I get to avoid most of the complications. It goes, in order:

1. =smtpmail-smtp-user=
2. =smtpmail-smtp-server=
3. =stmpmail-smtp-service= (port)
4. =mail-specify-envelope-from= (not needed, especially if you're
   using this.
5. =smtpmail-stream-type= (ssl, starttls, or plain. USE SSL if you
   want to live)
6. starttls crap
7. starttls crap
8. =smtpmail-local-domain= (hostname to use as where it's sent from. I
   set this usually to the hostname of the email provider.)
  
#+begin_src emacs-lisp
  (when (require 'notmuch nil t)
    (setq smtpmail-multi-accounts '((google . ("jmickey@google.com"
					       "smtp.gmail.com"
					       465
					       nil
					       ssl
					       nil
					       nil
					       "google.com"))
				    (codemac . ("codemac@fastmail.com"
						"mail.messagingengine.com"
						465
						nil
						ssl
						nil
						nil
						"codemac.net"))))
  
    (setq smtpmail-multi-default-account 'codemac)
    (setq smtpmail-multi-associations '(("jmickey@google.com" google)
					("j@codemac.net\\|jeff@archlinux.org\\|j@mickey.email\\|jeff@mickey.email\\|jm@vt.edu\\|jmickey@vt.edu" codemac)))
  
    (setq send-mail-function 'smtpmail-multi-send-it)
    (setq message-send-mail-function 'smtpmail-multi-send-it))
#+end_src
***** queueing
      :PROPERTIES:
      :ID:       f884dff3-0e19-41e1-969b-8911fcc05f68
      :END:
#+begin_src emacs-lisp
  (when (require 'notmuch nil t)
    (setq smtpmail-queue-mail  t  ;; start in non-queuing mode
	  smtpmail-queue-dir   "~/mail/queue")

    (setq user-full-name "Jeff Mickey")
    (if (cl-equalp (system-name) "jmickey-glaptop")
	(setq user-mail-address "jmickey@google.com")
      (setq user-mail-address "j@codemac.net")))
#+end_src
**** Drafts Handling
:PROPERTIES:
:ID:       0cf3d2ed-a014-4ff9-9718-950346378780
:END:
Ridiculous hacks to get sensible synced drafts. Sometimes I end up
with way too many drafts saved due to mbsync being fast, but that's a
good problem to me :)
#+begin_src emacs-lisp
  (when (require 'notmuch nil t)
    ;; how to get these things to not suck
    (setq message-draft-headers '(From References Subject Date (optional . In-Reply-To) Message-ID (optional . User-Agent)))
    (setq message-generate-headers-first t) ;; would love to do this without Date
    (setq message-auto-save-directory "~/mail/cm/Drafts/cur")

    (defun cm/draft-insert-mail-header-separator ()
      "Insert `mail-header-separator' in the first empty line of the message.
  `message-mode' needs this line to know where the headers end and
  the body starts. Note, in `mu4e-compose-mode', we use
  `before-save-hook' and `after-save-hook' to ensure that this
  separator is never written to the message file. Also see
  `mu4e-remove-mail-header-separator'."
      ;; we set this here explicitly, since (as it has happened) a wrong
      ;; value for this (such as "") breaks address completion and other things
      (set (make-local-variable 'mail-header-separator)
	   (purecopy "--text follows this line--"))
      (put 'mail-header-separator 'permanent-local t)
      (save-excursion
	;; make sure there's not one already
	(cm/draft-remove-mail-header-separator)
	(let ((sepa (propertize mail-header-separator
				'intangible t
				;; don't make this read-only, message-mode
				;; seems to require it being writable in some cases
				;;'read-only "Can't touch this"
				'rear-nonsticky t
				'font-lock-face 'message-separator)))
	  (widen)
	  ;; search for the first empty line
	  (goto-char (point-min))
	  (if (search-forward-regexp "^$" nil t)
	      (replace-match sepa)
	    (progn ;; no empty line? then prepend one
	      (goto-char (point-max))
	      (insert "\n" sepa))))))

    (defun cm/draft-remove-mail-header-separator ()
      "Remove `mail-header-separator; we do this before saving a
  file (and restore it afterwards), to ensure that the separator
  never hits the disk. Also see `mu4e-draft-insert-mail-header-separator."
      (interactive)
      (save-excursion
	(widen)
	(goto-char (point-min))
	;; remove the --text follows this line-- separator
	(when (search-forward-regexp (concat "^" mail-header-separator) nil t)
	  (let ((inhibit-read-only t))
	    (replace-match "")))))

    (defun cm/notmuch-message-setup ()
      "Configures a bunch of hooks for notmuch message windows"
      (message-add-action `(message "debug: done exit actions") 'exit)
      (message-add-action `(message "debug: done postpone actions") 'postpone)
      (message-add-action `(message "debug: done kill actions") 'kill)
      (message-add-action 'notmuch-message-postpone-keep 'postpone)
      (message-add-action 'notmuch-message-postpone-cleanup 'exit))

    (add-hook 'message-mode-hook 'cm/notmuch-message-setup)
    (add-hook 'message-mode-hook
	      (lambda ()
		(add-hook 'after-save-hook 'cm/draft-insert-mail-header-separator nil 'make-it-local)
		(add-hook 'before-save-hook 'cm/draft-remove-mail-header-separator nil 'make-it-local)))

    (defun notmuch-message-postpone-cleanup ()
      "Remove autosave and postponed messages for that buffer"
      (message "debug: postpone cleanup hook")
      (message "deleting draft file: %s" notmuch-draft-filename)
      (if (file-exists-p notmuch-draft-filename)
	  (progn
	    (kill-buffer)
	    (delete-file notmuch-draft-filename)
	    (if (file-exists-p notmuch-draft-filename)
		(message "failed to delete file %s" notmuch-draft-filename)
	      (message "debug: file deleted"))
	    )
	(message "draft file %s doesn't exist" notmuch-draft-filename)))

    (defun notmuch-message-postpone-keep ()
      "Moves the previous buffer into the postponed folder and then kill it"
      (save-excursion
	(set-buffer (last-buffer))
	(cm/draft-remove-mail-header-separator)
	(notmuch-maildir-fcc-write-buffer-to-maildir "~/mail/cm/drafts" t)
	(kill-buffer)))

    ;; (defun notmuch-show-resume-message ()
    ;;   "Resume a postponed message."
    ;;   (interactive)
    ;;   (setq tmpfilename (notmuch-show-get-filename))
    ;;   (notmuch-show-view-raw-message)
    ;;   (setq buffer-file-name tmpfilename)
    ;;   (message "debug: set buffer file name to %s" buffer-file-name)
    ;;   (setq notmuch-draft-filename buffer-file-name)
    ;;   (make-local-variable 'notmuch-draft-filename)
    ;;   (message "debug: set draft file name to %s" notmuch-draft-filename)
    ;;   (message-mode)
    ;;   (cm/draft-insert-mail-header-separator))

    ;; ;; set these to something damn high I hate elided messages
    ;; (setq notmuch-wash-citation-lines-prefix 1024)
    ;; (setq notmuch-wash-citation-lines-suffix 1024)
    ;; (setq notmuch-wash-signature-lines-max 0)
    ;; (setq notmuch-wash-wrap-lines-length (if (< fill-column 100) 100 fill-column))

    ;; (setq notmuch-maildir-use-notmuch-insert nil)
    ;; (require 'notmuch-show)
    ;; (define-key notmuch-show-mode-map "e" 'notmuch-show-resume-message)
  )
#+end_src
**** Keybindings
     :PROPERTIES:
     :ID:       dd303b47-13d6-48df-bb7f-93a81ac25edc
     :END:
For some reason the ~=~ sign is used for refresh in notmuch. This is
horrifying.
#+begin_src emacs-lisp
  (when (require 'notmuch nil t)
    (setq notmuch-archive-tags '("-inbox" "-unread" "+archive"))

    (defun cm/notmuch-archive-unread-all ()
      (interactive)
      (notmuch-search-tag-all notmuch-archive-tags))

    (defvar cm/private-notmuch-saved-searches '()
      "Saved searches not to be published publicly")

    (setq notmuch-saved-searches
	  '((:name "inbox"         :query "tag:inbox"                 :key "i"  :sort-order oldest-first)
	    (:name "flagged"       :query "tag:flagged"               :key "f"  :sort-order newest-first)
	    (:name "unread"        :query "tag:unread"                :key "u"  :sort-order newest-first)
	    (:name "work-inbox"    :query "tag:work AND tag:inbox"    :key "wi" :sort-order oldest-first)
	    (:name "work-bulk"     :query "tag:work AND tag:unread"
		   :key "wb" :sort-order newest-first)
	    (:name "inbox-codemac" :query "tag:codemac AND tag:inbox" :key "c" :sort-order newest-first)
	    (:name "drafts"        :query "tag:draft"                 :key "d" :sort-order newest-first)
	    (:name "today"         :query "date:today..!"             :key "t" :sort-order oldest-first)
	    (:name "sent"          :query "tag:sent"                  :key "n")))

    (cm/defun-local-wrap cm/notmuch-jump-search notmuch-jump-search)

    ;; we now use this for imenu
    ;; (global-set-key (kbd "C-c i") #'cm/notmuch-jump-search)

    ;; keep the "goto address" logic consistent with org mode
    (define-key notmuch-show-mode-map (kbd "C-c C-o") 'goto-address-at-point)
    (setq notmuch-tagging-keys
	  `((,(kbd "a") notmuch-archive-tags "Archive")
	    (,(kbd "u") notmuch-show-mark-read-tags "Mark read")
	    (,(kbd "f")
	     ("+flagged")
	     "Flag")
	    (,(kbd "m")
	     ("+muted")
	     "Mute")
	    (,(kbd "s")
	     ("+spam" "-inbox")
	     "Mark as spam")
	    (,(kbd "d")
	     ("+deleted" "-inbox")
	     "Delete")))

    (cm/defun-local cm/read-mail-command-notmuch ()
		    (notmuch-search "tag:inbox" t))

    (setq read-mail-command #'cm/read-mail-command-notmuch)
  )
#+end_src
What is this sillyness? =g= should always refresh a buffer, shit man.
#+begin_src emacs-lisp
  (when (require 'notmuch nil t)
    (eval-after-load 'notmuch
      '(define-key notmuch-common-keymap "g" 'notmuch-refresh-this-buffer))
    (eval-after-load 'notmuch
      '(define-key notmuch-common-keymap "A" 'cm/notmuch-archive-unread-all))
  )
#+end_src

Notmuch fcc dir handling
#+begin_src emacs-lisp
  (when (require 'notmuch nil t)
    (setq notmuch-fcc-dirs '((".*@google.com" . "work/sent")
			     (".*@codemac.net" . "cm/sent")))
  )
#+end_src
**** Message view
     :PROPERTIES:
     :ID:       609c8599-feea-4606-8444-3a243b306e2c
     :END:
The vast majority of this is around setting up drafts handling in
notmuch to be sync'd over IMAP. =notmuch= doesn't handle this for us,
and this is an amalgamation of things I found online. It currently
works with the cyrus IMAP server.
#+begin_src emacs-lisp
  (setq message-citation-line-format "* %f [%Y-%m-%d %H:%M]:")
  (setq message-citation-line-function 'message-insert-formatted-citation-line)
#+end_src
Set background color of eww rendered buffers to make wayyy more sense.
#+begin_src emacs-lisp
  (setq shr-color-visible-luminance-min 80)
#+end_src
Set the colors of each search result line based on the tags of the
result. This was inspired because notmuch changed them to have insane
defaults.

#+begin_src emacs-lisp
  (setq notmuch-search-line-faces `(("unread" . (:weight bold))
                                    ("flagged" . (:foreground "khaki"))))
#+end_src
#+begin_src emacs-lisp
  (when (require 'notmuch nil t)
    (require 'messages-are-flowing)
    (defun cm/message-mode-hook ()
      (local-set-key (kbd "C-c M-o") 'org-mime-htmlize)
      ;; orgstruct mode conflicts with hard-newlines. format=flowed is
      ;; *more* important than org-mime-htmlize.
      ;; (orgstruct-mode 1)
      (turn-off-auto-fill)
      (setq truncate-lines nil
	    word-wrap t
	    use-hard-newlines t)
      (visual-line-mode t)
      (messages-are-flowing-use-and-mark-hard-newlines))
  
    (add-hook 'message-mode-hook 'cm/message-mode-hook))
#+end_src
Indentations get really silly in corporate mail. I wish there was an
easier way to visually see "this is a reply" without indenting into
the future.
#+begin_src emacs-lisp
  (setq notmuch-show-indent-messages-width 0)
#+end_src

** Custom
   :PROPERTIES:
   :ID:       3897ecf3-7d82-47a2-b736-abf8204a83b4
   :END:
*** Guix
:PROPERTIES:
:ID:       503451bf-02e4-4237-a52c-473d8305eec4
:END:
#+begin_src emacs-lisp
  ;; load up guix if guix is installed!

  (require 'guix-init nil t)
#+end_src
*** Journal
    :PROPERTIES:
    :ID:       f11177ea-8f27-467c-bcc1-ee237fa6c0be
    :END:
Old text file journaling stuff. It really was quite nice, but org mode
once again ate my soul.
#+begin_src emacs-lisp
  (defun insert-date ()
    (interactive)
    (insert (format-time-string "%c")))
  
  (defun insert-header-newday ()
    (interactive)
    (insert "\n////////////////////////////////////////////////////////////////////////\n")
    (insert "// ")
    (insert-date)
    (insert "\n\n"))
  
  (defun insert-header-continue ()
    (interactive)
    (insert (format-time-string "\n                             ** %T **"))
    (insert "\n\n"))
  
  (defun insert-correct-header ()
    (interactive)
    (insert-header-newday))
  
  (defun journal ()
    (interactive)
    (find-file "~/doc/journal.txt")
    (end-of-buffer)
    (insert-correct-header)
    (auto-fill-mode 1)
    (flyspell-mode 1))
#+end_src
*** Blog
    :PROPERTIES:
    :ID:       5f6385d7-5212-4463-b3e8-df47357a4d69
    :END:
Some helper functions for publishing with ikiwiki
#+begin_src emacs-lisp
  (defun blog-insert-meta ()
    (interactive)
    (insert "[[!meta title=\"\"]]\n")
    (insert "[[!tag ]]\n")
    (insert "\n"))
  
  (defun blog-last ()
    (interactive)
    (let ((wiki-dir "~/www/wiki/blog/"))
      (find-file
       (concat wiki-dir
               (number-to-string (apply 'max (mapcar 'string-to-number
                                                     (mapcar '(lambda (a) (substring a 0 -5))
                                                             (directory-files wiki-dir nil "[0-9]*\\.mdwn" t )))))
               ".mdwn"))))
  
  (defun blog-find-next ()
    (interactive)
    (let ((wiki-dir "~/www/wiki/blog/"))
      (find-file 
       (concat wiki-dir 
               (number-to-string (1+ (apply 'max
                                            (mapcar 'string-to-number 
                                                    (mapcar '(lambda (a) (substring a 0 -5)) 
                                                            (directory-files wiki-dir nil "[0-9]*\\.mdwn" t))))))
               ".mdwn"))))
  
  (defun blog-next ()
    (interactive)
    (blog-find-next)
    (end-of-buffer)
    (blog-insert-meta))  
#+end_src
*** IronPort
    :PROPERTIES:
    :ID:       93a9fa67-ac11-4cc7-9a69-a0517086bc67
    :END:
A wholly owned subsidiary of Cisco.
#+begin_src emacs-lisp
  (defun ip-p4-cmd (command)
    "Run a command through p4 correctly, synchronously."
    (interactive)
    (let ((bn (buffer-file-name))
          (ppos (point)))
      (call-process-shell-command
       (concat
        "P4USER=jmickey "
        "P4PORT=perforce.ironport.com:1666 "
        "P4CONFIG=P4ENV "
        command " "
        bn))
      (find-alternate-file bn)
      (goto-char ppos)))
  
  (defun ip-p4-info (cmd)
    "Run a command through p4 asynchronously in an output buffer"
    (interactive)
    (let* ((bfn (buffer-file-name))
          (nbn (concat "*p4i:" (buffer-name) "*")))
          
      (start-process-shell-command nbn
                                   (get-buffer-create nbn)
                                   (concat
                                    "P4USER=jmickey "
                                    "P4PORT=perforce.ironport.com:1666 "
                                    "P4CONFIG=P4ENV "
                                    cmd " "
                                    bfn))
      (switch-to-buffer nbn)))
  
  (defun ip-p4-edit ()
    "Mark file as edit in perforce, reload buffer as editable, reset pointer"
    (interactive)
    (ip-p4-cmd "p4 edit"))
  
  (defun ip-p4 ()
    "Run arbitrary p4 command on current file"
    (interactive)
    (ip-p4-cmd (concat "p4 " (ido-completing-read "p4 "
                                                  (list
                                                   "edit"
                                                   "revert")))))
    
  (defun ip-p4-filelog ()
    "Show filelog output"
    (interactive)
    (ip-p4-info "p4 filelog -i"))
  
  (defun ip-p4pr ()
    "Show perforce blame"
    (interactive)
    (ip-p4-info "p4pr"))
  
  (defun sql-connect-preset (name)
    "Connect to a predefined SQL connection listed in `sql-connection-alist'"
    (eval `(let ,(cdr (assoc name ip-sql-connection-alist))
      (flet ((sql-get-login (&rest what)))
        (sql-product-interactive sql-product)))))
  
  (defun ip-sql-get-names (tlist)
    (if tlist (append (list (caar tlist)) (ip-sql-get-names (cdr tlist)))))
  
  (defun ip-sql-connect ()
    "Ido ask which!"
    (interactive)
    (sql-connect-preset (ido-completing-read "Connect to: " (ip-sql-get-names ip-sql-connection-alist))))
#+end_src
*** Tup
    :PROPERTIES:
    :ID:       b14441a2-77bc-4444-bcda-db6ef2ea9331
    :END:
#+begin_src emacs-lisp
  (require 'tup-mode)
#+end_src
*** Find file hydra
:PROPERTIES:
:ID:       b4982d55-d30d-4c04-8b5c-4758b07d4d54
:END:
#+begin_src emacs-lisp
  (defhydra hydra-find-file (global-map "C-c f" :exit t)
    "Find a file"
    ("f" ffap "file at point")
    ("h" (let ((default-directory (file-name-as-directory (getenv "HOME"))))
	   (call-interactively #'find-file))
     "home files")
    ("q" nil "quit"))
  (global-set-key (kbd "C-c f") 'hydra-find-file/body)
#+end_src

* Tools
:PROPERTIES:
:ID:       4560dbdb-bda5-4e38-be2c-d5bf9dd44ae4
:END:

** Tea Timer
:PROPERTIES:
:ID:       fe707b7b-0666-4f7d-882f-03b4c6a8e067
:END:

#+begin_src emacs-lisp
  (defun cm/timer (timeval msg)
    "Ask how long the tea should draw and start a timer.
  Cancel prevoius timer, started by this function"
    (interactive "sHow long (mins or h:mm:ss)? \nsMessage: ")
    (with-current-buffer (get-buffer-create (concat " " msg))
      (org-mode)
      (insert (format "* %s\n" msg))
      (org-timer-set-timer timeval)))

  (defun cm/gtd-timer ()
    (interactive)
    (cm/timer "2" "Two minute task is complete!"))
#+end_src
** Time Saved Calculater
:PROPERTIES:
:ID:       c85a7fcf-22a6-4344-87cd-4618bcaeb7b3
:END:
The =cm/timesaved= function is a user interface for calculating how
much time someone saves if they shave off some amount of time per
occurrence of a task. Good example: morning routines, imagine if you
shaved off 10 seconds, but you know you're going to do that every day
for the rest of your life, those 10 seconds add up! In fact, you save
2 days 12 hours and 50 minutes.

The idea for this comes from https://xkcd.com/1205/
#+begin_src emacs-lisp
(defun cm/timesaved-unit-message (totalremaining unit)
  (let ((total (floor (/ totalremaining (cm/timesaved-seconds-in-time unit)))))
    (format
     "%s %s "
     total
     (if (> total 1) (concat unit "s") unit))))

(defun cm/timesaved-subtract-unit (totalremaining unit)
  (mod totalremaining (cm/timesaved-seconds-in-time unit)))


(defun cm/timesaved-seconds-to-breakdown (seconds)
  (let ((totalremaining seconds)
	(messagestring ""))
    (mapc (lambda (unit)
	    (when (> totalremaining (cm/timesaved-seconds-in-time unit))
	      (setq messagestring (concat messagestring (cm/timesaved-unit-message totalremaining unit)))
	      (setq totalremaining (cm/timesaved-subtract-unit totalremaining unit))))
	  (list "year" "month" "week" "day" "hour" "minute" "second"))
    (message messagestring)))

(defun cm/timesaved-times-per-year (time)
  (/ (cm/time-saved-seconds-in-time "year")
     (cm/time-saved-seconds-in-time time)))

(defun cm/timesaved-seconds-in-time (time)
  (message (format "intern time: %S" (intern time)))
  (pcase (intern time)
    ('second 1)
    ('minute 60)
    ('hour (* 60 60))
    ('day (* 60 60 24))
    ('week (* 60 60 24 7))
    ('month (* 60 60 24 30))
    ('year (* 60 60 24 365))
    (_ (error "No proper time string"))))

;; Notations:
;;
;; would be awesome to think of a much shorter notation
;;   <number meaning x times><character meaning for y units> <number of years>

;; my lowest unit is a second, so we convert everything to seconds
(defun cm/timesaved (occurrenceunit occurrences years savedunit savedperoccurrence)
  (interactive
   (list
    (completing-read
     "Multiple occurrences per what unit? "
     '("second" "minute" "hour" "day" "week" "month" "year"))
    (string-to-number (read-string "How many occurances per unit? "))
    (string-to-number (read-string "How many years will this event repeat for? "))
    (completing-read
     "What unit of measure for how much is saved? "
     '("second" "minute" "hour" "day" "week" "month" "year"))
    (string-to-number (read-string "How much of the unit is saved per occurance? "))))

  (message (format "You will save: %s"
		   (cm/timesaved-seconds-to-breakdown
		    (* (cm/timesaved-times-per-year occurrenceunit) occurrences years
		       savedperoccurrence (cm/timesaved-seconds-in-time savedunit))))))
    
#+end_src

** Capture all open buffers
:PROPERTIES:
:ID:       932d21e3-99de-4449-9bee-f42bf6916695
:END:
The david allen special inbox magic
#+begin_src emacs-lisp
  (defvar cm/obvious-buffers
    '("*Help*" "*scratch*" "*GNU Emacs*" "*Messages*" "diary" "bbdb")
    "Buffers that are obviously not relevant")

  (defun cm/filter-out-obvious (ls)
    (require 'seq)
    (let ((obv-buffs (append cm/obvious-buffers
			     (org-agenda-files))))
      (seq-remove (lambda (x) (or (string-prefix-p " " (buffer-name x))
				  (and (string-prefix-p "*" (buffer-name x))
				       (string-suffix-p "*" (buffer-name x)))
				  (member (buffer-name x) obv-buffs)
				  (member (buffer-file-name x) obv-buffs)))
		  ls)))

  (defun cm/capture-buffer-links ()
    (delete
     nil
     (cl-mapcar (lambda (buffer)
		  (with-current-buffer buffer
		    (if (and buffer-file-name
			     (y-or-n-p (format "store link from %s and close? " buffer-file-name)))
			(progn
			  (let ((toret (org-store-link nil)))
			    (kill-buffer (current-buffer))
			    toret)))))
		(cm/filter-out-obvious (buffer-list)))))

  (defun cm/chrome-debug-tabs ()
    (list
     (delete
      nil
      (mapcar
       (lambda (x)
	 (if (equal (cdr (assq 'type x)) "page")
	     (cons (cdr (assq 'title x)) (cdr (assq 'url x)))))
       (with-current-buffer
	   (url-retrieve-synchronously "http://127.0.0.1:9222/json")
	 (replace-regexp "HTTP/1.1 200 OK\nContent-Length:.*\n.*UTF-8\n\n" "" nil (point-min) (point-max))
	 (beginning-of-buffer)
	 (json-read))))))

  (defun cm/firefox-profile ()
    (concat (car (directory-files (concat (getenv "HOME") "/.mozilla/firefox") t ".*default" t))
	    "/sessionstore-backups/recovery.js"))

  (defun cm/firefox-tabs ()
    "Retrieves the list of tabs from the current firefox session,
  without any pinned tabs"
    (mapcar
     (lambda (x)
       (delete
	nil
	(mapcar
	 (lambda (y)
	   (let* ((entries (cdr (assq 'entries y)))
		  (pinned (not (null (assq 'pinned y))))
		  (lastentry (aref entries (- (length entries) 1)))
		  (url (cdr (assq 'url lastentry)))
		  (title (cdr (assq 'title lastentry))))
	     (if (not pinned)
		 (cons title url))))
	 (cdr (assq 'tabs x)))))
     (cdr (assq 'windows (json-read-file (cm/firefox-profile))))))

  (defun cm/get-browser-tabs ()
    (interactive)
    "Makes a single list of all tabs open in all browsers"
    (let ((tabs (apply #'append (append (cm/firefox-tabs) (cm/chrome-debug-tabs)))))
      (delete nil
	      (cl-mapcar (lambda (title-url)
			   (if (and title-url (y-or-n-p (format "store %s - %s ? " (car title-url) (cdr title-url))))
			       (org-make-link-string (cdr title-url) (car title-url))))
			 tabs))))


  (defun cm/close-n-capture ()
    (interactive)
    (org-capture-string (mapconcat #'identity
				   (append
				    (cm/capture-buffer-links)
				    (cm/get-browser-tabs))
				   "\n")
			"t"))

  ;; I never use this
  ;;(global-set-key (kbd "C-c x") 'cm/close-n-capture)
#+end_src


** Global Abbrev Support
:PROPERTIES:
:ID:       3e3efa9d-6512-4aa4-a8b9-be72dac07c6a
:END:
So something that cracks me up, is the concept of textexpander being
so "powerful". It's not powerful - it's just global.

Let's use completing read for fuzzy matching on our abbrev. In emacs
we can do it *after* typing the abbrev, I'll need to figure out how to
accomplish that across x11 apps though.

#+begin_src emacs-lisp
  (defvar cm/emacs-expander-alist
    "alist of things to expand to"
    '(("//" . (text "  //  mickey"))))

  (setq cm/emacs-expander-alist
	`(("//" . (cmd ("<space>" "<space>"  "/" "/" "<space>" "<space>" "m" "i" "c" "k" "e" "y")))
	  ("sg." . (cmd ("S-s" "o" "u" "n" "d" "s" " " "g" "o" "o" "d" ".")))
	  ("mail" . (cmd ,(lambda () '("S-m" "a" "i" "l"))))))

  (defun cm/youinput-command (cmd)
    (let ((youinput-cmd (if (functionp cmd) (funcall cmd) cmd)))
      (message "About to do: %s" cmd)
      (make-process
       :name "youinput command process"
       :buffer "youinput-process-buffer"
       :command `("youinput" ,@youinput-cmd)
       :connection-type 'pipe
       :sentinel #'cm/expander-sentinel)))

  (defun cm/xdotool-key (key)
    (make-process
     :name "xdotool key process"
     :buffer "xdotool-process-buffer"
     :command `("xdotool" "key" "--clearmodifiers" "--delay" "5" ,key)
     :connection-type 'pipe
     :sentinel #'cm/expander-sentinel))

  (defun cm/xdotool-type (text)
    (let ((proc (make-process
		 :name "xdotool type process"
		 :buffer "xdotool-process-buffer"
		 :command '("xdotool" "type" "--clearmodifiers" "--delay" "5" "--file" "-")
		 :connection-type 'pipe
		 :sentinel #'cm/expander-sentinel)))
      (process-send-string proc text)
      (process-send-eof proc)))

  (defvar cm/expander-temp-storage-reply
    "So the callback can reply!" '())

  (defun cm/expander-sentinel (proc event)
    (cm/run-expander-plist cm/expander-temp-storage-reply))

  (defun cm/run-expander-plist (pls)
    (when (> (length pls) 1)
      (let ((sym (car pls))
	    (val (cadr pls)))
	(setq cm/expander-temp-storage-reply (cddr pls))
	(pcase sym
	  ('text (cm/xdotool-type val))
	  ('key (cm/xdotool-key val))
	  ('cmd (cm/youinput-command val))))))

  (defun cm/emacs-expander ()
    (interactive)
    (save-window-excursion
      (let* ((key (completing-read "Abbrev to expand: " cm/emacs-expander-alist))
	     (kpl (cdr (assoc key cm/emacs-expander-alist))))
	(cm/emacs-expander-frame-cleanup)
	(cm/run-expander-plist kpl))))

  (defun cm/emacs-expander-frame ()
    "Create a new frame and run cm/emacs-expander."
    (interactive)
    (save-window-excursion
      (make-frame '((name . "emacs-expander")
		    (width . 120)
		    (height . 20)
		    (menu-bar-lines . 0)
		    (tool-bar-lines . 0)
		    (minibuffer . only)
		    (auto-lower . nil)
		    (auto-raise . t)))
      (select-frame-by-name "emacs-expander")
      (condition-case nil
	  (progn (cm/emacs-expander) t)
	((error debug quit) nil)))
    (cm/emacs-expander-frame-cleanup))

  (defun cm/emacs-expander-frame-cleanup ()
    "Close the emacs-expander frame."
    (dolist (elem (frame-list))
      (if (cl-equalp "emacs-expander" (frame-parameter elem 'name))
	  (save-window-excursion
	    (delete-frame elem)))))
#+end_src

** YasEmacsExpander
:PROPERTIES:
:ID:       92268700-9099-463b-bb64-1c11221e4b19
:END:
This is a new version I'm developing of what's above, that should
hopefully replace it by using yasnippet + youinput.

#+begin_src emacs-lisp
  (use-package yasnippet
    :diminish yasnippet-mode)

  (defun cm/yas-expand-input-youinput-command (cmd)
    (message "cmd: %s" cmd)
    (make-process
     :name "youinput command process"
     :buffer "youinput-process-buffer"
     :command `("youinput" ,@cmd)
     :connection-type 'pipe
     :sentinel #'cm/yas-expand-input-sentinel))

  (defun cm/yas-expand-input-sentinel (proc event)
    (message "yas-expand: youinput: %s %s" proc event))

  (defun cm/yas-expand-input ()
    (interactive)
    ;; create buffer
    (let ((buffer (generate-new-buffer "yas-expand-input")))
      (switch-to-buffer buffer)
      (yas-expand-input-mode)
      (yas-minor-mode-on)
      (yas-reload-all)
      (call-interactively #'yas-insert-snippet)))

  (defun cm/yas-expand-input-parse-youinput-args (contents)
    (let* ((case-fold-search nil)
	   (thestrs (mapcar 'char-to-string contents))
	   (filtered (mapcar (lambda (x)
			       (cond
				((string= x "\n") "<ret>")
				((string= x "	") "<tab>")
  ;;			      ((string-match-p "[A-Z]" x) (concat "S-" (downcase x)))
				(t x)))
			     thestrs)))
      (message "About to run youinput this way: %s" filtered)
      filtered))

  (defun cm/yas-expand-input-finish ()
    (interactive)
    ;; grab the entire text of the current buffer
    (let* ((contents (buffer-string))
	   (youinput-cmd (cm/yas-expand-input-parse-youinput-args contents)))
      (cm/yas-expand-input-emacs-frame-cleanup)
      (cm/yas-expand-input-youinput-command youinput-cmd)))

  (defun cm/yas-expand-input-emacs-frame ()
    "Create a new frame and run cm/yas-expand-input."
    (interactive)
    (save-window-excursion
      (with-selected-frame
	  (make-frame '((name . "yas-expand-input")
			(width . 120)
			(height . 20)
			(menu-bar-lines . 0)
			(tool-bar-lines . 0)
			(minibuffer . t)
			(auto-lower . nil)
			(auto-raise . t)))
	(condition-case nil
	    (progn
	      (cm/yas-expand-input)
	      t)
	  ((error debug quit) nil)))))

  (defun cm/yas-expand-input-emacs-frame-cleanup ()
    "Close yas-expand-input frame & buffer."
    (interactive)
    (delete-frame))

  (defvar yas-expand-input-mode-map nil "Keymap for `yas-expand-input-mode'")

  (setq yas-expand-input-mode-map (make-sparse-keymap))

  (define-key yas-expand-input-mode-map (kbd "C-c RET") 'cm/yas-expand-input-finish)
  (define-key yas-expand-input-mode-map (kbd "C-c C-k") 'cm/yas-expand-input-emacs-frame-cleanup)

  (define-derived-mode yas-expand-input-mode
    text-mode "YasExpand"
    "Major mode for yas expansion input.")
#+end_src
** PDF Splitting Workflow
:PROPERTIES:
:ID:       a6787d3b-f0f8-4ffc-b3fa-bf4559425187
:END:
PDF's are generally how I store digital information, and usually I
just scan them all into one huge PDF, and then split them up back at
my computer.

#+begin_src emacs-lisp
  (defun cm/pdf-splitter--create-step-buffer (file)
    ;; create new buffer in fundamental mode
    ;; insert commented instructions at the top
    ;; insert one line per page, with step syntax
    ;;   step syntax:
    ;;   (cm/pdf-splitter-page number orientation)
    ;;
    ;; On finalize, create a pile of PDFs named
    ;; <something>_<pagenum>.pdf and rejoin whatever the
    ;; pdf-splitter-doc says to with the given file names.
    ;;
    ;; So something like:
    ;;
    ;;  (page 1 'O)
    ;;  (page 2 'O)
    ;;  (page 3 'O)
    ;;  (page 4 'O)
    ;;   ....
    ;;  (doc "filename"
    ;;   '(
    ;;     1
    ;;     2
    ;;     3
    ;;     4
    ;;    ))
    ;;

    nil)


  (defun cm/pdf-splitter (file)
    (interactive "fFile: ")
    (find-file file)
    (cm/pdf-splitter--create-step-buffer file)
    (cm/pdf-splitter--arrange-windows file))

  (defun cm/pdf-splitter--finalize (file)
    ;; take step buffer
    ;; execute buffer
    nil)

  (defun cm/pdf-splitter-doc (pages)
    nil)


#+end_src
** NYT front page
:PROPERTIES:
:ID:       3848fe6f-d3d0-474a-8feb-d1ebd27f244b
:END:
#+begin_src emacs-lisp
  (defun cm/read-nyt ()
    (interactive)
    (let* ((urldatestr (format-time-string "%Y/%m/%d"))
	   (filedatestr (format-time-string "%Y-%m-%d"))
	   (tmpfile (concat (temporary-file-directory) "nyt-" filedatestr ".pdf")))
      (url-copy-file (concat "https://static01.nyt.com/images/" urldatestr "/nytfrontpage/scan.pdf") tmpfile)
      (find-file tmpfile)))
#+end_src
** Timestamp parsing
:PROPERTIES:
:ID:       ee9dba3a-4f27-4b38-9107-545669291718
:END:

This is a utility function to basically turn a big number into it's
=(hi lo usec psec)= formatting. 
#+begin_src emacs-lisp
  (defun cm/number-base-to-time (number base)
    ;; base = 1, seconds
    ;; base = 1000, milliseconds
    ;; base = 1000000 microseconds
    ;; base = 1000000000 nanoseconds
    ;; base = 1000000000000 picoseconds
    (let* ((seconds (truncate (/ number base)))
	   (hi (lsh seconds -16))
	   (lo (logand seconds 65535))
	   (usec (truncate (* (/ (- number (* seconds base 1.0)) base) 1000000)))
	   (psec (truncate (* (/ (- number (* seconds base 1.0) (* (/ usec 1000000.0) base)) base) 1000000000000))))
      (list hi lo usec psec)))
#+end_src

I prefer ISO8601-ish dates.
#+begin_src emacs-lisp
  (defvar cm/time-format "%Y-%m-%d %H:%M:%S.%N %Z"
    "my preferred time format")
#+end_src

Now for the main formatting function.

#+begin_src emacs-lisp
  (defun cm/timestamp (input)
    (interactive "sTimestamp: ")
    ;; trim leading whitespace
    (require 'subr-x)
    (let* ((input (string-trim input))
	   (no-comma-input (replace-regexp-in-string "," "" input))
	   (as-number (string-to-number no-comma-input))
	   (candidate
	    (cond
	     ((not (= as-number 0)) as-number)
	     ((string-match "^0?x?[a-fA-F0-9]+$" input) (string-to-number (string-trim-left input "0x") 10))
	     (t (error "Not a parseable time: %s" input))))
	   (y2k 946713600)
	   ;; is the number too small to be pico, nano, micro milli,
	   ;; seconds. Basically, if the date is before the year 2000, it's
	   ;; unlikely I meant that time.
	   (base-candidate
	    (cond
	     ((> candidate (* y2k 1000000000000)) 1000000000000)
	     ((> candidate (* y2k 100000000000)) 100000000000)
	     ((> candidate (* y2k 10000000000)) 10000000000)
	     ((> candidate (* y2k 1000000000)) 1000000000)
	     ((> candidate (* y2k 100000000)) 100000000)
	     ((> candidate (* y2k 10000000)) 10000000)
	     ((> candidate (* y2k 1000000)) 1000000)
	     ((> candidate (* y2k 100000)) 100000)
	     ((> candidate (* y2k 10000)) 10000)
	     ((> candidate (* y2k 1000)) 1000)
	     (t 1))))
      (message "%s => %s" input (format-time-string cm/time-format (cm/number-base-to-time candidate base-candidate)))))

  ;; TODO implement string parsing as well, not as useful however.
    ;; try string dates:
    ;;   use various string formats, attempting to parse as a date:
    ;;     NoTz MM/dd/yyyy
    ;;     NoTz yyyy/MM/dd
    ;;     NoTz yyyy-MM-dd
    ;;     NoTz yyyy-MM-dd hh:mm:ss
    ;;     NoTz yyyy-MM-dd hh:mm:ss.SS
    ;;     NoTz yyyy/MM/dd-hh:mm:ss
    ;;     NoTz yyyy/MM/dd-hh:mm:ss.SS
    ;;     NoTz dd MMM yyyy
    ;;     NoTz dd MMM yyyy hhaa
    ;;     NoTz MM/dd/yyyy, hh:mm:ss aa
    ;;     NoTz MMdd hh:mm:ss.SS
    ;;     WithTz yyyy-MM-dd hh:mm:ss ZZZ
    ;;     Utc yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\''
    ;;     Utc yyyyMMddhhmmss\'UTC\''
    ;; try any emacs string -> date libraries available
#+end_src

* Directory Specific Code
  :PROPERTIES:
  :ID:       2fbd3ec2-ed82-414f-9bf9-bfecad2a9db5
  :END:
** Directory classes
   :PROPERTIES:
   :ID:       50d34be2-13f5-43c5-8b0a-e1dfbd05fc16
   :END:
#+begin_src emacs-lisp
  ;; check in all the time! (Need to learn to avoid master as well..)
  (defun cm/after-save-commit ()
    (if cm/gitty-files
        (call-interactively 
         (lambda (title)
           (interactive "sCommit title: ")
           (let* ((bfn (buffer-file-name))
                  (gitroot (substring (shell-command-to-string "git rev-parse --show-toplevel") 0 -1))
                  (shortname (car (split-string bfn (concat gitroot "/") t))))
             (shell-command (concat "git add " bfn " && git commit -m '" shortname ": " title "'")))))))

  ;; set this variable in your .dir-locals.el so saving becomes enabled
  (defvar cm/gitty-files nil)

  (defun cm/igneous-product-config ()
    ;; add an after-save-hook that runs git commit!
    (add-hook 'after-save-hook 'cm/after-save-commit))
#+end_src
** Directories
   :PROPERTIES:
   :ID:       f6cd9ef5-406e-40db-824b-3e8a2631420a
   :END:
* Disabled lisp
  :PROPERTIES:
  :ID:       0daffd72-11cb-4c40-9803-d8052e4d3009
  :END:
#+begin_src emacs-lisp
  ; have to figure out how to comment multiple lines...
#+end_src

** Desktop
    :PROPERTIES:
    :ID:       a920b9cb-92ec-4652-a937-bb296f32bad6
    :END:
Saves everything! Very useful for the epic emacs restarters (me)
#+begin_src emacs-lisp
  ;; (require 'desktop)
  ;; 
  ;; (desktop-save-mode 1)
  ;; 
  ;; ;; auto-save emacs instance
  ;; (defun cm/desktop-save ()
  ;;   (interactive)
  ;;   (if (eq (desktop-owner) (emacs-pid))
  ;;       (desktop-save desktop-dirname)))
  ;; 
  ;; (add-hook 'auto-save-hook 'cm/desktop-save)
#+end_src
** All edit in occur
   :PROPERTIES:
   :ID:       afa1fcb9-1dbe-41d1-ad68-2362ba5d4b76
   :END:
Turns out that occur actually handles this just fine..

#+begin_src emacs-lisp
  ;; (require 'all)
  ;; (defun isearch-all ()
  ;;   "Invoke `all' from within isearch."
  ;;   (interactive)
  ;;   (let ((case-fold-search isearch-case-fold-search))
  ;;     (all (if isearch-regexp isearch-string (regexp-quote isearch-string)))))
  
  ;; (define-key isearch-mode-map (kbd "C-e") 'isearch-all)
#+end_src
** Hippe tab
   :PROPERTIES:
   :ID:       715b10ba-f8ac-4cb2-a242-3d2a6fff0a37
   :END:
I.. don't use this anymore
#+begin_src emacs-lisp
  ;(global-set-key (kbd "TAB") 'hippie-expand)
#+end_src
** ECB - Emacs Code Browser
   :PROPERTIES:
   :ID:       200c1819-7436-4f11-a439-b0d1aa07f528
   :END:
#+begin_src emacs-lisp
  ;(require 'ecb-autoloads)
#+end_src
** xcscope
   :PROPERTIES:
   :ID:       18e348cb-787b-4994-ae29-25b7a78b9169
   :END:
Gotta love cscope. Using GNU Global now.
#+begin_src emacs-lisp
  ;(require 'xcscope)
  ;(setq cscope-do-not-update-database t)
  ;
  ;(defun xcscope-minor-mode ()
  ;  (interactive)
  ;  (cscope:hook)
  ;)
  ;
  ;(add-hook 'python-mode-hook (function cscope:hook))
#+end_src
** acscope
   :PROPERTIES:
   :ID:       a1cc38e6-519f-4a58-909d-856907e9f78c
   :END:
Another way of handling cscope, though I rarely built cscope db's locally, so this was rarely used.
#+begin_src emacs-lisp
  ;(require 'ascope)
  ;
  ;;; The following line corresponds to be beginning of the "Cscope" menu.
  ;(define-key cscope:map "\C-css" 'ascope-find-this-symbol)
  ;(define-key cscope:map "\C-csg" 'ascope-find-global-definition)
  ;;(define-key cscope:map "\C-csG" 'cscope-find-global-definition-no-prompting)
  ;(define-key cscope:map "\C-csc" 'ascope-find-functions-calling-this-function)
  ;(define-key cscope:map "\C-csC" 'ascope-find-called-functions)
  ;(define-key cscope:map "\C-cst" 'ascope-find-this-text-string)
  ;;(define-key cscope:map "\C-cse" 'cscope-find-egrep-pattern)
  ;;(define-key cscope:map "\C-csf" 'cscope-find-this-file)
  ;(define-key cscope:map "\C-csi" 'ascope-find-files-including-file)
  ;(define-key cscope:map "\C-csa" 'ascope-all-symbol-assignments)
  ;;; --- (The '---' indicates that this line corresponds to a menu separator.)
  ;;(define-key cscope:map "\C-csb" 'cscope-display-buffer)
  ;;(define-key cscope:map "\C-csB" 'cscope-display-buffer-toggle)
  ;;(define-key cscope:map "\C-csn" 'cscope-next-symbol)
  ;;(define-key cscope:map "\C-csN" 'cscope-next-file)
  ;;(define-key cscope:map "\C-csp" 'cscope-prev-symbol)
  ;;(define-key cscope:map "\C-csP" 'cscope-prev-file)
  ;;(define-key cscope:map "\C-csu" 'cscope-pop-mark)
  ;;; ---
  ;;(define-key cscope:map "\C-csa" 'cscope-set-initial-directory)
  ;;(define-key cscope:map "\C-csA" 'cscope-unset-initial-directory)
  ;;; ---
  ;;(define-key cscope:map "\C-csL" 'cscope-create-list-of-files-to-index)
  ;;(define-key cscope:map "\C-csI" 'cscope-index-files)
  ;;(define-key cscope:map "\C-csE" 'cscope-edit-list-of-files-to-index)
  ;;(define-key cscope:map "\C-csW" 'cscope-tell-user-about-directory)
  ;;(define-key cscope:map "\C-csS" 'cscope-tell-user-about-directory)
  ;;(define-key cscope:map "\C-csT" 'cscope-tell-user-about-directory)
  ;;(define-key cscope:map "\C-csD" 'cscope-dired-directory))
#+end_src
** Perspective
   :PROPERTIES:
   :ID:       0174a769-874a-4b50-a5ce-dd09c03521a0
   :END:
#+begin_src emacs-lisp
  ;(require 'perspective)
  ;(persp-mode)
#+end_src
** Tabbar
   :PROPERTIES:
   :ID:       d4497aba-dae0-42df-85de-6e8388337d7e
   :END:
Nice to have going along the top sometimes. Disabled, I never used it.
#+begin_src emacs-lisp
  ;(require 'tabbar)
  ;(tabbar-mode)
  ;
  ;(global-set-key (kbd "<C-tab>") 'tabbar-forward)
  ;(global-set-key (kbd "<C-S-iso-lefttab>") 'tabbar-forward-group)
#+end_src

** End diasbled code
   :PROPERTIES:
   :ID:       cb8445c2-04c4-4fa4-980f-4037e747ba3f
   :END:
#+begin_src emacs-lisp
  ; this is where the ending mark would be
#+end_src
** Command Frequency
   :PROPERTIES:
   :ID:       9c53a156-0cb0-4367-9a19-24d6056f4ba4
   :END:
This can be useful to figure out what commands you do and don't use
all the time, so you can figure out what keybindings you need to
fix. I found that I never used the data though..
#+begin_src emacs-lisp
  ;; (require 'command-frequency)
  
  ;; (setq-default command-frequency-table-file "~/.emacs-frequency")
  
  ;; (command-frequency-table-load)
  ;; (command-frequency-mode 1)
  ;; (command-frequency-autosave-mode 1)
#+end_src

** Ido
   :PROPERTIES:
   :ID:       72b1beb3-ca21-4ef1-8741-30fac3e98ca8
   :END:
Everyone should use Ido. (well, maybe helm)
#+begin_src emacs-lisp
  ;(require 'ido)
  ;(put 'ido-exit-minibuffer 'disabled nil)
  ;(ido-mode t)
#+end_src
If the exact name isn't found, then flex matching will match against
anything with the characters in the order you've typed. It matches
only for strings that have that sequence of characters in order.
#+begin_src emacs-lisp
  ;(setq ido-enable-flex-matching t)
#+end_src

** Identica
   :PROPERTIES:
   :ID:       357a3a6d-12b9-471b-a48b-c801eb7103ea
   :END:
Microblog, baby.
#+begin_src emacs-lisp
  ;(autoload 'identica-mode "identica-mode" "" t)
  ;(setq identica-username cm/identica-username
  ;      identica-password cm/identica-password)
  ;
  ;(global-set-key "\C-cip" 'identica-update-status-interactive)
  ;(global-set-key "\C-cid" 'identica-direct-message-interactive)
#+end_src
** Helm
    :PROPERTIES:
    :ID:       9e11b4e9-8161-41e8-8e1f-0dabd83a8145
    :END:
Helm is the new Anything. Helm will help steer you in the right
direction!

Configure helm to be used for =M-x=... well let's just use it for
everything. Helm is GNU for emacs. Helm is borg. We are the helm. You
will be assimilated.

Mostly lifted from https://tuhdo.github.io/helm-intro.html (note that
this page is *STUPID* slow in eww)

#+begin_src emacs-lisp
  ;; (use-package helm
  ;;   :diminish helm-mode
  ;;   :bind (("M-x" . helm-M-x)
  ;;          ("M-y" . helm-show-kill-ring)
  ;;          ("C-x b" . helm-mini)
  ;;          ("C-x C-f" . helm-find-files)
  ;;          ("C-h SPC" . helm-all-mark-rings))
  ;;   :init
  ;;   (require 'helm-config)
  ;;   (global-set-key (kbd "C-c h") 'helm-command-prefix)
  ;;   (when cm/using-rc
  ;;       (setq helm-top-command "COLUNMS=%s top -b -n 1"))

  ;;   (helm-mode 1)
  ;;   :config
  ;;   (setq helm-split-window-in-side-p t
  ;;         helm-ff-file-name-history-use-recentf t
  ;;         helm-ff-search-library-in-sexp t
  ;;         helm-move-to-line-cycle-in-source t
  ;;         helm-scroll-amount 8
  ;;         helm-ff-file-name-history-use-recentf t
  ;;         helm-man-or-woman-function 'woman)
  ;;   (when (executable-find "curl")
  ;;     (setq helm-google-suggest-use-curl-p t))
  ;;   (delete helm-source-locate helm-for-files-preferred-list)

  ;;   ;; bindings I haven't figured out with :bind
  ;;   (global-unset-key (kbd "C-x c"))
  ;;   (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ;;   (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  ;;   (define-key helm-map (kbd "C-z")  'helm-select-action)
  ;;   (global-set-key (kbd "C-c h o") 'helm-occur)
  ;;   (global-set-key (kbd "C-c h x") 'helm-register))
#+end_src

I dislike helm grep immensely (super slow!) and I don't use =ack= /
=ag= / etc. This disables =C-c p s <g,a,s>= and just does =C-c p s=
like it used to.
#+begin_src emacs-lisp
  ;; (use-package helm-projectile
  ;;   :init
  ;;   (setq projectile-completion-system 'helm)
  ;;   (helm-projectile-on)
  ;;   (define-key projectile-command-map [remap projectile-grep] nil)
  ;;   (define-key projectile-command-map [remap helm-projectile-grep] 'projectile-grep))
#+end_src
*** Mac os x hacks
     :PROPERTIES:
     :ID:       ca5c4755-da49-491b-ae37-6255407b5598
     :END:
Get spotlight into list of the files that helm can inspect, and get
top output that doesn't suck
#+begin_src emacs-lisp
  ;; (when (eq system-type 'darwin)
  ;;   (add-to-list 'helm-for-files-preferred-list 'helm-c-source-mac-spotlight)
  ;;   (setq helm-c-top-command "COLUMNS=%s top -l 1"))
#+end_src
*** Global Tags
     :PROPERTIES:
     :ID:       17f2f463-4bb3-4901-86e6-2acb32572dbf
     :END:
Yay gtags support for helm!
#+begin_src emacs-lisp
  ;; (use-package helm-gtags
  ;;   :config
  ;;   (add-hook 'c-mode-hook (lambda () (helm-gtags-mode)))
  ;;   
  ;;   ;; customize
  ;;   (setq helm-c-gtags-path-style 'absolute)
  ;;   (setq helm-c-gtags-ignore-case t)
  ;;   (setq helm-c-gtags-read-only nil)
  ;;   
  ;;   ;; key bindings
  ;;   (add-hook 'helm-gtags-mode-hook
  ;;             '(lambda ()
  ;;                (local-set-key (kbd "C-c g t") 'helm-gtags-find-tag)
  ;;                (local-set-key (kbd "C-c g r") 'helm-gtags-find-rtag)
  ;;                (local-set-key (kbd "C-c g s") 'helm-gtags-find-symbol)
  ;;                (local-set-key (kbd "C-c g f") 'helm-gtags-find-files)
  ;;                (local-set-key (kbd "C-t") 'helm-gtags-pop-stack))))
#+end_src
** mu4e
   :PROPERTIES:
   :ID:       67b2693a-b95f-47fc-8db4-92a9b669a177
   :END:
=mu4e= is a Maildir emacs mail mode. It's quite simple, but it's
design goals fall right in the "super perfect" range, and I think it
has a huge opportunity to succeed. It is similar to notmuch.
#+begin_src emacs-lisp
;  (setq message-draft-headers '(From References Subject Date (optional . In-Reply-To) Message-ID (optional . User-Agent)))
;  (setq message-generate-headers-first t) ;; would love to do this without Date
;  (setq message-auto-save-directory "~/mail/cm/drafts/cur")
;  (setq smtpmail-auth-credentials "~/.netrc") ;; is this needed?
;  (defun cm/make-dynamic-folder (init)
;    (lexical-let ((name init))
;      #'(lambda (msg)
;	  (when (not msg)
;	    (error (concat "Blank msg in " name)))
;	  (let ((maildir (mu4e-message-field msg :maildir)))
;	    (cond
;	     ((string-match "cm/" maildir)
;	      (concat "/cm/" name))
;	     ((string-match "work/" maildir)
;	      (concat "/work/" name))
;	     (t
;	      (error "Could not find message?")))))))
;
;  (use-package mu4e
;    :bind (("C-c i" . mu4e))
;    :init
;    (setq mu4e-maildir                "~/mail"
;	  mu4e-sent-folder            "/work/sent"
;	  mu4e-drafts-folder          "/cm/drafts"
;	  mu4e-trash-folder           (cm/make-dynamic-folder "trash")
;	  mu4e-refile-folder          (cm/make-dynamic-folder "all")
;	  mu4e-get-mail-command       "mbsync -a" ;; mbsync -a is running by cron
;	  mu4e-sent-messages-behavior 'sent
;	  mu4e-org-contacts-file      (cm/org-dir "_notes/contacts.org")
;	  mu4e-use-fancy-chars        nil
;	  mu4e-view-show-images       t
;	  mu4e-view-show-addresses    t
;	  mail-user-agent             'mu4e-user-agent
;	  mu4e-compose-format-flowed  t
;	  fill-flowed-encode-column   60
;	  mu4e-change-filenames-when-moving t
;	  mu4e-headers-fields '((:human-date . 12)
;				(:flags      .  6)
;				(:from       . 32)
;				(:subject        ))
;	  mu4e-headers-time-format "%H:%M"
;	  mu4e-headers-date-format "%Y-%m-%d"
;	  mu4e-maildir-shortcuts
;	  '(("/work/INBOX" . ?i)
;	    ("/work/all"   . ?a)
;	    ("/work/sent"  . ?s)))
;    :config
;    (setq mu4e-bookmarks
;	  (list
;	   (make-mu4e-bookmark
;	    :name "Combined Inbox"
;	    :query "maildir:/work/INBOX OR maildir:/cm/INBOX"
;	    :key ?i)
;	   (make-mu4e-bookmark
;	    :name "Flagged"
;	    :query "flag:flagged"
;	    :key ?f)
;	   (make-mu4e-bookmark
;	    :name "Unread"
;	    :query "flag:unread"
;	    :key ?u)
;	   (make-mu4e-bookmark
;	    :name "Past Week - All"
;	    :query "date:8d..1d"
;	    :key ?w)
;	   (make-mu4e-bookmark
;	    :name "Yesterday - All"
;	    :query "date:2d..1d"
;	    :key ?y)))
;    (require 'org-mu4e)
;    (add-to-list 'mu4e-headers-actions
;		 '("org-contact-add" . mu4e-action-add-org-contact) t)
;    (add-to-list 'mu4e-view-actions
;		 '("org-contact-add" . mu4e-action-add-org-contact) t))
#+end_src

** Jabber
    :PROPERTIES:
    :ID:       cf368eef-c121-411f-ad2c-1560d4a0882f
    :END:
Directly use jabber with elisp! It's painfully slow, and the single
threaded nature of emacs means it turns out to be quite a failure if
you are trying to edit anything.
#+begin_src emacs-lisp
  ;; (autoload 'jabber-connect-all "jabber" "" t)
  ;; ;; Show my status in the header along with theirs! woo!
  ;; (eval-after-load 'jabber
  ;;   (progn
  ;;     (setq jabber-chat-header-line-format
  ;; 	  '(" " (:eval (jabber-jid-displayname jabber-chatting-with))
  ;; 	    " " (:eval (jabber-jid-resource jabber-chatting-with)) "\t";
  ;; 	    (:eval (let ((buddy (jabber-jid-symbol jabber-chatting-with)))
  ;; 		     (propertize
  ;; 		      (or
  ;; 		       (cdr (assoc (get buddy 'show) jabber-presence-strings))
  ;; 		       (get buddy 'show))
  ;; 		      'face
  ;; 		      (or (cdr (assoc (get buddy 'show) jabber-presence-faces))
  ;; 			  'jabber-roster-user-online))))
  ;; 	    "\t" (:eval (get (jabber-jid-symbol jabber-chatting-with) 'status))
  ;; 	    (:eval (unless (equal "" *jabber-current-show*)
  ;; 		     (concat "\t You're " *jabber-current-show*
  ;; 			     " (" *jabber-current-status* ")")))))
  ;;     ;; Open urls!
  ;;     (add-hook 'jabber-chat-mode-hook 'goto-address)

  ;;     ;; fun keybindings!
  ;;     (defun my-jabber-chat-delete-or-bury ()
  ;;       (interactive)
  ;;       (if (eq 'jabber-chat-mode major-mode)
  ;; 	  (condition-case e 
  ;; 	      (delete-frame)
  ;; 	    (error 
  ;; 	     (if (string= "Attempt to delete the sole visible or iconified frame" 
  ;; 			  (cadr e))
  ;; 		 (bury-buffer))))))

  ;; 					;    (define-key jabber-chat-mode-map [escape] 'my-jabber-chat-delete-or-bury)
  ;;     (define-key mode-specific-map "jr"
  ;;       (lambda () 
  ;; 	(interactive) 
  ;; 	(switch-to-buffer "*-jabber-*")))
  ;;     (define-key mode-specific-map "jc"
  ;;       '(lambda () 
  ;; 	 (interactive) 
  ;; 	 (call-interactively 'jabber-connect)))
  ;;     (define-key mode-specific-map "jd"
  ;;       '(lambda () 
  ;; 	 (interactive) 
  ;; 	 (call-interactively 'jabber-disconnect)))
  ;;     (define-key mode-specific-map "jj"
  ;;       '(lambda () 
  ;; 	 (interactive) 
  ;; 	 (call-interactively 'jabber-chat-with)))
  ;;     (define-key mode-specific-map "ja"
  ;;       '(lambda () 
  ;; 	 (interactive) 
  ;; 	 (jabber-send-presence "away" "" 10)))
  ;;     (define-key mode-specific-map "jo"
  ;;       '(lambda () 
  ;; 	 (interactive) 
  ;; 	 (jabber-send-presence "" "" 10)))
  ;;     (define-key mode-specific-map "jx"
  ;;       '(lambda () 
  ;; 	 (interactive) 
  ;; 	 (jabber-send-presence "xa" "" 10)))))

  ;;   ;;;; hipchat support
  ;; (setq ssl-program-name "gnutls-cli"
  ;;       ssl-program-arguments '("--insecure" "-p" service host)
  ;;       ssl-certificate-verification-policy 1)

  ;; ;; Connect using jabber.el
  ;; ;; M-x jabber-connect <RET>

  ;; ;; Config
  ;; (setq jabber-account-list '(("75698_604162@chat.hipchat.com")))
  ;; (defvar hipchat-number "75698")
  ;; (defvar hipchat-nickname "Jeff Mickey")

  ;; ;; Join a room
  ;; (defun cm/hipchat-join (room)
  ;;   (interactive "sRoom name: ")
  ;;   (jabber-groupchat-join
  ;;    (jabber-read-account)
  ;;    (concat hipchat-number "_" room "@conf.hipchat.com")
  ;;    hipchat-nickname
  ;;    t))

  ;; ;; Mention nicknames in a way that HipChat clients will pickup
  ;; (defun hipchat-mention (nickname)
  ;;   (interactive
  ;;    (list (jabber-muc-read-nickname jabber-group "Nickname: ")))
  ;;   (insert (concat "@\"" nickname "\" "))) 

  ;; (defvar cm/hipchat-rooms '())

  ;; (defun cm/hipchat-joinall ()
  ;;   (interactive)
  ;;   (rcirc-cmd-join (mapconcat 'identity cm/hipchat-rooms ",") (rcirc-buffer-process (get-buffer "&bitlbee@localhost")) nil))
  ;
#+end_src
* Cursor color
  :PROPERTIES:
  :ID:       ec982e34-e2a7-429f-b2e0-9a4a7957ba1c
  :END:
Change cursor color according to mode; inspired by
http://www.emacswiki.org/emacs/ChangingCursorDynamically valid values
are t, nil, box, hollow, bar, (bar . WIDTH), hbar, (hbar. HEIGHT); see
the docs for set-cursor-type.

This is put at the very end so that way it can override any coloring
settings that occur above. Much easier this way.
#+begin_src emacs-lisp
  (defun cm/cursor ()
    "change cursor color and type according to some minor modes."
    (cond
      (buffer-read-only
       (setq cursor-type 'hbar))
      (t 
       (set-cursor-color "yellow")
       (setq cursor-type 'box))))


  (setq cursor-type 'box)
  ;;(add-hook 'post-command-hook 'cm/cursor)
  ;; oh god it flashes so much. Don't know how to do this better yet.

  (defun cm/cursor-theme-hook ()
    (blink-cursor-mode 0)
    (setq cm/cursor-color
     (pcase cm/theme-style
       ('dark "#ffff00")
       ('light "#000000")
       ('author "#000000")))
    (set-cursor-color cm/cursor-color)
    (set-mouse-color cm/cursor-color))

  (add-hook 'cm/theme-after-hook 'cm/cursor-theme-hook)

  (cm/cursor-theme-hook)

  (require 'frame)
  (defun cm/cursor-frame-hook (frame)
    (set-cursor-color cm/cursor-color)
    (modify-frame-parameters
     frame (list (cons 'cursor-color cm/cursor-color))))

  (add-hook 'after-make-frame-functions 'cm/cursor-frame-hook)
#+end_src
** Server process
   :PROPERTIES:
   :ID:       41e76b1a-d666-472b-a77e-b62478546956
   :END:
Start a server if it's not started, and I'm not root.
#+begin_src emacs-lisp
  (unless (string-equal "root" (getenv "USER"))
  ;; Only start server mode if it isn't started already
    (unless (server-running-p)
      (server-start)))

  (add-hook 'server-visit-hook 'raise-frame)
  (defun cm/raise-frame-and-give-focus ()
    (when window-system
      (raise-frame)
      (x-focus-frame (selected-frame))
      (set-mouse-pixel-position (selected-frame) 4 4)))
  (add-hook 'server-switch-hook 'cm/raise-frame-and-give-focus)
#+end_src
